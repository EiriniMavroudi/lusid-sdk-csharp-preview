/* 
 * LUSID API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.10.1381
 * Contact: info@finbourne.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using RestSharp.Portable;
using Lusid.Sdk.Client;
using Lusid.Sdk.Model;

namespace Lusid.Sdk.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IPersonsApi : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// [EXPERIMENTAL] Delete person
        /// </summary>
        /// <remarks>
        /// Delete a person. Deletion will be valid from the person&#39;s creation datetime.  This means that the person will no longer exist at any effective datetime from the asAt datetime of deletion.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">The scope of the person identifier type.</param>
        /// <param name="idTypeCode">The code of the person identifier type.</param>
        /// <param name="code">Code of the person under specified identifier type scope and code. This together with defined              identifier type uniquely identifies the person to delete.</param>
        /// <returns>DeletedEntityResponse</returns>
        DeletedEntityResponse DeletePerson (string idTypeScope, string idTypeCode, string code);

        /// <summary>
        /// [EXPERIMENTAL] Delete person
        /// </summary>
        /// <remarks>
        /// Delete a person. Deletion will be valid from the person&#39;s creation datetime.  This means that the person will no longer exist at any effective datetime from the asAt datetime of deletion.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">The scope of the person identifier type.</param>
        /// <param name="idTypeCode">The code of the person identifier type.</param>
        /// <param name="code">Code of the person under specified identifier type scope and code. This together with defined              identifier type uniquely identifies the person to delete.</param>
        /// <returns>ApiResponse of DeletedEntityResponse</returns>
        ApiResponse<DeletedEntityResponse> DeletePersonWithHttpInfo (string idTypeScope, string idTypeCode, string code);
        /// <summary>
        /// [EXPERIMENTAL] Delete a Person Access Metadata entry
        /// </summary>
        /// <remarks>
        /// Deletes the Person Access Metadata entry that exactly matches the provided identifier parts.    It is important to always check to verify success (or failure).
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier.</param>
        /// <param name="idTypeCode">Code of the person identifier.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code.</param>
        /// <param name="metadataKey">Key of the metadata entry to retrieve</param>
        /// <param name="effectiveAt">The effective date to delete at, if this is not supplied, it will delete all data found (optional)</param>
        /// <returns>DeletedEntityResponse</returns>
        DeletedEntityResponse DeletePersonAccessMetadata (string idTypeScope, string idTypeCode, string code, string metadataKey, DateTimeOrCutLabel effectiveAt = null);

        /// <summary>
        /// [EXPERIMENTAL] Delete a Person Access Metadata entry
        /// </summary>
        /// <remarks>
        /// Deletes the Person Access Metadata entry that exactly matches the provided identifier parts.    It is important to always check to verify success (or failure).
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier.</param>
        /// <param name="idTypeCode">Code of the person identifier.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code.</param>
        /// <param name="metadataKey">Key of the metadata entry to retrieve</param>
        /// <param name="effectiveAt">The effective date to delete at, if this is not supplied, it will delete all data found (optional)</param>
        /// <returns>ApiResponse of DeletedEntityResponse</returns>
        ApiResponse<DeletedEntityResponse> DeletePersonAccessMetadataWithHttpInfo (string idTypeScope, string idTypeCode, string code, string metadataKey, DateTimeOrCutLabel effectiveAt = null);
        /// <summary>
        /// [EXPERIMENTAL] Get Access Metadata rules for a Person
        /// </summary>
        /// <remarks>
        /// Pass the Scope and Code of the Person identifier along with the person code parameter to retrieve the associated Access Metadata
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier.</param>
        /// <param name="idTypeCode">Code of the person identifier.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code.</param>
        /// <param name="effectiveAt">The effectiveAt datetime at which to retrieve the Access Metadata (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the Access Metadata (optional)</param>
        /// <returns>Dictionary&lt;string, List&lt;AccessMetadataValue&gt;&gt;</returns>
        Dictionary<string, List<AccessMetadataValue>> GetAllPersonAccessMetadata (string idTypeScope, string idTypeCode, string code, DateTimeOrCutLabel effectiveAt = null, DateTimeOffset? asAt = null);

        /// <summary>
        /// [EXPERIMENTAL] Get Access Metadata rules for a Person
        /// </summary>
        /// <remarks>
        /// Pass the Scope and Code of the Person identifier along with the person code parameter to retrieve the associated Access Metadata
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier.</param>
        /// <param name="idTypeCode">Code of the person identifier.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code.</param>
        /// <param name="effectiveAt">The effectiveAt datetime at which to retrieve the Access Metadata (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the Access Metadata (optional)</param>
        /// <returns>ApiResponse of Dictionary&lt;string, List&lt;AccessMetadataValue&gt;&gt;</returns>
        ApiResponse<Dictionary<string, List<AccessMetadataValue>>> GetAllPersonAccessMetadataWithHttpInfo (string idTypeScope, string idTypeCode, string code, DateTimeOrCutLabel effectiveAt = null, DateTimeOffset? asAt = null);
        /// <summary>
        /// [EXPERIMENTAL] Get Person
        /// </summary>
        /// <remarks>
        /// Retrieve the definition of a person.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier type.</param>
        /// <param name="idTypeCode">Code of the person identifier type.</param>
        /// <param name="code">Code of the person under specified scope and code. This together with stated identifier type uniquely              identifies the person.</param>
        /// <param name="propertyKeys">A list of property keys from the \&quot;Person\&quot; domain to decorate onto each person.              These take the format {domain}/{scope}/{code} e.g. \&quot;Person/ContactDetails/Address\&quot;. Defaults to include all properties if not specified. (optional)</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to retrieve the person. Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the person. Defaults to return the latest version of the person if not specified. (optional)</param>
        /// <returns>Person</returns>
        Person GetPerson (string idTypeScope, string idTypeCode, string code, List<string> propertyKeys = null, DateTimeOrCutLabel effectiveAt = null, DateTimeOffset? asAt = null);

        /// <summary>
        /// [EXPERIMENTAL] Get Person
        /// </summary>
        /// <remarks>
        /// Retrieve the definition of a person.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier type.</param>
        /// <param name="idTypeCode">Code of the person identifier type.</param>
        /// <param name="code">Code of the person under specified scope and code. This together with stated identifier type uniquely              identifies the person.</param>
        /// <param name="propertyKeys">A list of property keys from the \&quot;Person\&quot; domain to decorate onto each person.              These take the format {domain}/{scope}/{code} e.g. \&quot;Person/ContactDetails/Address\&quot;. Defaults to include all properties if not specified. (optional)</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to retrieve the person. Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the person. Defaults to return the latest version of the person if not specified. (optional)</param>
        /// <returns>ApiResponse of Person</returns>
        ApiResponse<Person> GetPersonWithHttpInfo (string idTypeScope, string idTypeCode, string code, List<string> propertyKeys = null, DateTimeOrCutLabel effectiveAt = null, DateTimeOffset? asAt = null);
        /// <summary>
        /// [EXPERIMENTAL] Get an entry identified by a metadataKey in the Access Metadata of a Person
        /// </summary>
        /// <remarks>
        /// Get a specific Person Access Metadata by specifying the corresponding identifier parts and Person code                No matching will be performed through this endpoint. To retrieve an entry, it is necessary to specify, exactly, the identifier of the entry
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier.</param>
        /// <param name="idTypeCode">Code of the person identifier.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code.</param>
        /// <param name="metadataKey">Key of the metadata entry to retrieve</param>
        /// <param name="effectiveAt">The effectiveAt datetime at which to retrieve the Access Metadata (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the Access Metadata (optional)</param>
        /// <returns>ICollection&lt;AccessMetadataValue&gt;</returns>
        ICollection<AccessMetadataValue> GetPersonAccessMetadataByKey (string idTypeScope, string idTypeCode, string code, string metadataKey, DateTimeOrCutLabel effectiveAt = null, DateTimeOffset? asAt = null);

        /// <summary>
        /// [EXPERIMENTAL] Get an entry identified by a metadataKey in the Access Metadata of a Person
        /// </summary>
        /// <remarks>
        /// Get a specific Person Access Metadata by specifying the corresponding identifier parts and Person code                No matching will be performed through this endpoint. To retrieve an entry, it is necessary to specify, exactly, the identifier of the entry
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier.</param>
        /// <param name="idTypeCode">Code of the person identifier.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code.</param>
        /// <param name="metadataKey">Key of the metadata entry to retrieve</param>
        /// <param name="effectiveAt">The effectiveAt datetime at which to retrieve the Access Metadata (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the Access Metadata (optional)</param>
        /// <returns>ApiResponse of ICollection&lt;AccessMetadataValue&gt;</returns>
        ApiResponse<ICollection<AccessMetadataValue>> GetPersonAccessMetadataByKeyWithHttpInfo (string idTypeScope, string idTypeCode, string code, string metadataKey, DateTimeOrCutLabel effectiveAt = null, DateTimeOffset? asAt = null);
        /// <summary>
        /// [EXPERIMENTAL] List Persons
        /// </summary>
        /// <remarks>
        /// List persons which has identifier of specific identifier type&#39;s scope and code, and satisfies filter criteria.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier type.</param>
        /// <param name="idTypeCode">Code of the person identifier type.</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to list the people. Defaults to the current LUSID              system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to list the people. Defaults to return the latest version              of each people if not specified. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing portfolios from a previous call to list portfolios. This  value is returned from the previous call. If a pagination token is provided the filter, effectiveAt  and asAt fields must not have changed since the original request. Also, if set, a start value cannot be provided. (optional)</param>
        /// <param name="start">When paginating, skip this number of results. (optional)</param>
        /// <param name="limit">When paginating, limit the number of returned results to this many. Defaults to 65,535 if not specified. (optional)</param>
        /// <param name="filter">Expression to filter the result set.               For example, to filter on the LUPID, use \&quot;lusidPersonId eq &#39;string&#39;\&quot;              Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid. (optional)</param>
        /// <param name="propertyKeys">A list of property keys from the \&quot;Person\&quot; domain to decorate onto each person.              These take the format {domain}/{scope}/{code} e.g. \&quot;Person/ContactDetails/Address\&quot;. Defaults to include all properties if not specified. (optional)</param>
        /// <returns>ResourceListOfPerson</returns>
        ResourceListOfPerson ListPersons (string idTypeScope, string idTypeCode, DateTimeOrCutLabel effectiveAt = null, DateTimeOffset? asAt = null, string page = null, int? start = null, int? limit = null, string filter = null, List<string> propertyKeys = null);

        /// <summary>
        /// [EXPERIMENTAL] List Persons
        /// </summary>
        /// <remarks>
        /// List persons which has identifier of specific identifier type&#39;s scope and code, and satisfies filter criteria.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier type.</param>
        /// <param name="idTypeCode">Code of the person identifier type.</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to list the people. Defaults to the current LUSID              system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to list the people. Defaults to return the latest version              of each people if not specified. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing portfolios from a previous call to list portfolios. This  value is returned from the previous call. If a pagination token is provided the filter, effectiveAt  and asAt fields must not have changed since the original request. Also, if set, a start value cannot be provided. (optional)</param>
        /// <param name="start">When paginating, skip this number of results. (optional)</param>
        /// <param name="limit">When paginating, limit the number of returned results to this many. Defaults to 65,535 if not specified. (optional)</param>
        /// <param name="filter">Expression to filter the result set.               For example, to filter on the LUPID, use \&quot;lusidPersonId eq &#39;string&#39;\&quot;              Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid. (optional)</param>
        /// <param name="propertyKeys">A list of property keys from the \&quot;Person\&quot; domain to decorate onto each person.              These take the format {domain}/{scope}/{code} e.g. \&quot;Person/ContactDetails/Address\&quot;. Defaults to include all properties if not specified. (optional)</param>
        /// <returns>ApiResponse of ResourceListOfPerson</returns>
        ApiResponse<ResourceListOfPerson> ListPersonsWithHttpInfo (string idTypeScope, string idTypeCode, DateTimeOrCutLabel effectiveAt = null, DateTimeOffset? asAt = null, string page = null, int? start = null, int? limit = null, string filter = null, List<string> propertyKeys = null);
        /// <summary>
        /// [EXPERIMENTAL] Upsert Person
        /// </summary>
        /// <remarks>
        /// Create or update new person under specified scope
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="request">Request to create or update a person. (optional)</param>
        /// <returns>Person</returns>
        Person UpsertPerson (UpsertPersonRequest request = null);

        /// <summary>
        /// [EXPERIMENTAL] Upsert Person
        /// </summary>
        /// <remarks>
        /// Create or update new person under specified scope
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="request">Request to create or update a person. (optional)</param>
        /// <returns>ApiResponse of Person</returns>
        ApiResponse<Person> UpsertPersonWithHttpInfo (UpsertPersonRequest request = null);
        /// <summary>
        /// [EXPERIMENTAL] Upsert a Person Access Metadata entry associated with a specific metadataKey. This creates or updates the data in LUSID.
        /// </summary>
        /// <remarks>
        /// Update or insert one Person Access Metadata entry in a single scope. An item will be updated if it already exists  and inserted if it does not.                The response will return the successfully updated or inserted Person Access Metadata rule or failure message if unsuccessful.                It is important to always check to verify success (or failure).                Multiple rules for a metadataKey can exist with different effective at dates, when resources are accessed the rule that is active for the current time will be fetched.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier.</param>
        /// <param name="idTypeCode">Code of the person identifier.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code.</param>
        /// <param name="metadataKey">Key of the metadata entry to retrieve</param>
        /// <param name="request">The Person Access Metadata entry to upsert</param>
        /// <param name="effectiveAt">The effectiveAt datetime at which to upsert the Access Metadata (optional)</param>
        /// <returns>ResourceListOfAccessMetadataValueOf</returns>
        ResourceListOfAccessMetadataValueOf UpsertPersonAccessMetadata (string idTypeScope, string idTypeCode, string code, string metadataKey, UpsertPersonAccessMetadataRequest request, DateTimeOrCutLabel effectiveAt = null);

        /// <summary>
        /// [EXPERIMENTAL] Upsert a Person Access Metadata entry associated with a specific metadataKey. This creates or updates the data in LUSID.
        /// </summary>
        /// <remarks>
        /// Update or insert one Person Access Metadata entry in a single scope. An item will be updated if it already exists  and inserted if it does not.                The response will return the successfully updated or inserted Person Access Metadata rule or failure message if unsuccessful.                It is important to always check to verify success (or failure).                Multiple rules for a metadataKey can exist with different effective at dates, when resources are accessed the rule that is active for the current time will be fetched.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier.</param>
        /// <param name="idTypeCode">Code of the person identifier.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code.</param>
        /// <param name="metadataKey">Key of the metadata entry to retrieve</param>
        /// <param name="request">The Person Access Metadata entry to upsert</param>
        /// <param name="effectiveAt">The effectiveAt datetime at which to upsert the Access Metadata (optional)</param>
        /// <returns>ApiResponse of ResourceListOfAccessMetadataValueOf</returns>
        ApiResponse<ResourceListOfAccessMetadataValueOf> UpsertPersonAccessMetadataWithHttpInfo (string idTypeScope, string idTypeCode, string code, string metadataKey, UpsertPersonAccessMetadataRequest request, DateTimeOrCutLabel effectiveAt = null);
        #endregion Synchronous Operations
        #region Asynchronous Operations
        /// <summary>
        /// [EXPERIMENTAL] Delete person
        /// </summary>
        /// <remarks>
        /// Delete a person. Deletion will be valid from the person&#39;s creation datetime.  This means that the person will no longer exist at any effective datetime from the asAt datetime of deletion.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">The scope of the person identifier type.</param>
        /// <param name="idTypeCode">The code of the person identifier type.</param>
        /// <param name="code">Code of the person under specified identifier type scope and code. This together with defined              identifier type uniquely identifies the person to delete.</param>
        /// <returns>Task of DeletedEntityResponse</returns>
        System.Threading.Tasks.Task<DeletedEntityResponse> DeletePersonAsync (string idTypeScope, string idTypeCode, string code);

        /// <summary>
        /// [EXPERIMENTAL] Delete person
        /// </summary>
        /// <remarks>
        /// Delete a person. Deletion will be valid from the person&#39;s creation datetime.  This means that the person will no longer exist at any effective datetime from the asAt datetime of deletion.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">The scope of the person identifier type.</param>
        /// <param name="idTypeCode">The code of the person identifier type.</param>
        /// <param name="code">Code of the person under specified identifier type scope and code. This together with defined              identifier type uniquely identifies the person to delete.</param>
        /// <returns>Task of ApiResponse (DeletedEntityResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<DeletedEntityResponse>> DeletePersonAsyncWithHttpInfo (string idTypeScope, string idTypeCode, string code);
        /// <summary>
        /// [EXPERIMENTAL] Delete a Person Access Metadata entry
        /// </summary>
        /// <remarks>
        /// Deletes the Person Access Metadata entry that exactly matches the provided identifier parts.    It is important to always check to verify success (or failure).
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier.</param>
        /// <param name="idTypeCode">Code of the person identifier.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code.</param>
        /// <param name="metadataKey">Key of the metadata entry to retrieve</param>
        /// <param name="effectiveAt">The effective date to delete at, if this is not supplied, it will delete all data found (optional)</param>
        /// <returns>Task of DeletedEntityResponse</returns>
        System.Threading.Tasks.Task<DeletedEntityResponse> DeletePersonAccessMetadataAsync (string idTypeScope, string idTypeCode, string code, string metadataKey, DateTimeOrCutLabel effectiveAt = null);

        /// <summary>
        /// [EXPERIMENTAL] Delete a Person Access Metadata entry
        /// </summary>
        /// <remarks>
        /// Deletes the Person Access Metadata entry that exactly matches the provided identifier parts.    It is important to always check to verify success (or failure).
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier.</param>
        /// <param name="idTypeCode">Code of the person identifier.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code.</param>
        /// <param name="metadataKey">Key of the metadata entry to retrieve</param>
        /// <param name="effectiveAt">The effective date to delete at, if this is not supplied, it will delete all data found (optional)</param>
        /// <returns>Task of ApiResponse (DeletedEntityResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<DeletedEntityResponse>> DeletePersonAccessMetadataAsyncWithHttpInfo (string idTypeScope, string idTypeCode, string code, string metadataKey, DateTimeOrCutLabel effectiveAt = null);
        /// <summary>
        /// [EXPERIMENTAL] Get Access Metadata rules for a Person
        /// </summary>
        /// <remarks>
        /// Pass the Scope and Code of the Person identifier along with the person code parameter to retrieve the associated Access Metadata
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier.</param>
        /// <param name="idTypeCode">Code of the person identifier.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code.</param>
        /// <param name="effectiveAt">The effectiveAt datetime at which to retrieve the Access Metadata (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the Access Metadata (optional)</param>
        /// <returns>Task of Dictionary&lt;string, List&lt;AccessMetadataValue&gt;&gt;</returns>
        System.Threading.Tasks.Task<Dictionary<string, List<AccessMetadataValue>>> GetAllPersonAccessMetadataAsync (string idTypeScope, string idTypeCode, string code, DateTimeOrCutLabel effectiveAt = null, DateTimeOffset? asAt = null);

        /// <summary>
        /// [EXPERIMENTAL] Get Access Metadata rules for a Person
        /// </summary>
        /// <remarks>
        /// Pass the Scope and Code of the Person identifier along with the person code parameter to retrieve the associated Access Metadata
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier.</param>
        /// <param name="idTypeCode">Code of the person identifier.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code.</param>
        /// <param name="effectiveAt">The effectiveAt datetime at which to retrieve the Access Metadata (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the Access Metadata (optional)</param>
        /// <returns>Task of ApiResponse (Dictionary&lt;string, List&lt;AccessMetadataValue&gt;&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<Dictionary<string, List<AccessMetadataValue>>>> GetAllPersonAccessMetadataAsyncWithHttpInfo (string idTypeScope, string idTypeCode, string code, DateTimeOrCutLabel effectiveAt = null, DateTimeOffset? asAt = null);
        /// <summary>
        /// [EXPERIMENTAL] Get Person
        /// </summary>
        /// <remarks>
        /// Retrieve the definition of a person.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier type.</param>
        /// <param name="idTypeCode">Code of the person identifier type.</param>
        /// <param name="code">Code of the person under specified scope and code. This together with stated identifier type uniquely              identifies the person.</param>
        /// <param name="propertyKeys">A list of property keys from the \&quot;Person\&quot; domain to decorate onto each person.              These take the format {domain}/{scope}/{code} e.g. \&quot;Person/ContactDetails/Address\&quot;. Defaults to include all properties if not specified. (optional)</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to retrieve the person. Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the person. Defaults to return the latest version of the person if not specified. (optional)</param>
        /// <returns>Task of Person</returns>
        System.Threading.Tasks.Task<Person> GetPersonAsync (string idTypeScope, string idTypeCode, string code, List<string> propertyKeys = null, DateTimeOrCutLabel effectiveAt = null, DateTimeOffset? asAt = null);

        /// <summary>
        /// [EXPERIMENTAL] Get Person
        /// </summary>
        /// <remarks>
        /// Retrieve the definition of a person.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier type.</param>
        /// <param name="idTypeCode">Code of the person identifier type.</param>
        /// <param name="code">Code of the person under specified scope and code. This together with stated identifier type uniquely              identifies the person.</param>
        /// <param name="propertyKeys">A list of property keys from the \&quot;Person\&quot; domain to decorate onto each person.              These take the format {domain}/{scope}/{code} e.g. \&quot;Person/ContactDetails/Address\&quot;. Defaults to include all properties if not specified. (optional)</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to retrieve the person. Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the person. Defaults to return the latest version of the person if not specified. (optional)</param>
        /// <returns>Task of ApiResponse (Person)</returns>
        System.Threading.Tasks.Task<ApiResponse<Person>> GetPersonAsyncWithHttpInfo (string idTypeScope, string idTypeCode, string code, List<string> propertyKeys = null, DateTimeOrCutLabel effectiveAt = null, DateTimeOffset? asAt = null);
        /// <summary>
        /// [EXPERIMENTAL] Get an entry identified by a metadataKey in the Access Metadata of a Person
        /// </summary>
        /// <remarks>
        /// Get a specific Person Access Metadata by specifying the corresponding identifier parts and Person code                No matching will be performed through this endpoint. To retrieve an entry, it is necessary to specify, exactly, the identifier of the entry
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier.</param>
        /// <param name="idTypeCode">Code of the person identifier.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code.</param>
        /// <param name="metadataKey">Key of the metadata entry to retrieve</param>
        /// <param name="effectiveAt">The effectiveAt datetime at which to retrieve the Access Metadata (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the Access Metadata (optional)</param>
        /// <returns>Task of ICollection&lt;AccessMetadataValue&gt;</returns>
        System.Threading.Tasks.Task<ICollection<AccessMetadataValue>> GetPersonAccessMetadataByKeyAsync (string idTypeScope, string idTypeCode, string code, string metadataKey, DateTimeOrCutLabel effectiveAt = null, DateTimeOffset? asAt = null);

        /// <summary>
        /// [EXPERIMENTAL] Get an entry identified by a metadataKey in the Access Metadata of a Person
        /// </summary>
        /// <remarks>
        /// Get a specific Person Access Metadata by specifying the corresponding identifier parts and Person code                No matching will be performed through this endpoint. To retrieve an entry, it is necessary to specify, exactly, the identifier of the entry
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier.</param>
        /// <param name="idTypeCode">Code of the person identifier.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code.</param>
        /// <param name="metadataKey">Key of the metadata entry to retrieve</param>
        /// <param name="effectiveAt">The effectiveAt datetime at which to retrieve the Access Metadata (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the Access Metadata (optional)</param>
        /// <returns>Task of ApiResponse (ICollection&lt;AccessMetadataValue&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<ICollection<AccessMetadataValue>>> GetPersonAccessMetadataByKeyAsyncWithHttpInfo (string idTypeScope, string idTypeCode, string code, string metadataKey, DateTimeOrCutLabel effectiveAt = null, DateTimeOffset? asAt = null);
        /// <summary>
        /// [EXPERIMENTAL] List Persons
        /// </summary>
        /// <remarks>
        /// List persons which has identifier of specific identifier type&#39;s scope and code, and satisfies filter criteria.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier type.</param>
        /// <param name="idTypeCode">Code of the person identifier type.</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to list the people. Defaults to the current LUSID              system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to list the people. Defaults to return the latest version              of each people if not specified. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing portfolios from a previous call to list portfolios. This  value is returned from the previous call. If a pagination token is provided the filter, effectiveAt  and asAt fields must not have changed since the original request. Also, if set, a start value cannot be provided. (optional)</param>
        /// <param name="start">When paginating, skip this number of results. (optional)</param>
        /// <param name="limit">When paginating, limit the number of returned results to this many. Defaults to 65,535 if not specified. (optional)</param>
        /// <param name="filter">Expression to filter the result set.               For example, to filter on the LUPID, use \&quot;lusidPersonId eq &#39;string&#39;\&quot;              Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid. (optional)</param>
        /// <param name="propertyKeys">A list of property keys from the \&quot;Person\&quot; domain to decorate onto each person.              These take the format {domain}/{scope}/{code} e.g. \&quot;Person/ContactDetails/Address\&quot;. Defaults to include all properties if not specified. (optional)</param>
        /// <returns>Task of ResourceListOfPerson</returns>
        System.Threading.Tasks.Task<ResourceListOfPerson> ListPersonsAsync (string idTypeScope, string idTypeCode, DateTimeOrCutLabel effectiveAt = null, DateTimeOffset? asAt = null, string page = null, int? start = null, int? limit = null, string filter = null, List<string> propertyKeys = null);

        /// <summary>
        /// [EXPERIMENTAL] List Persons
        /// </summary>
        /// <remarks>
        /// List persons which has identifier of specific identifier type&#39;s scope and code, and satisfies filter criteria.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier type.</param>
        /// <param name="idTypeCode">Code of the person identifier type.</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to list the people. Defaults to the current LUSID              system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to list the people. Defaults to return the latest version              of each people if not specified. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing portfolios from a previous call to list portfolios. This  value is returned from the previous call. If a pagination token is provided the filter, effectiveAt  and asAt fields must not have changed since the original request. Also, if set, a start value cannot be provided. (optional)</param>
        /// <param name="start">When paginating, skip this number of results. (optional)</param>
        /// <param name="limit">When paginating, limit the number of returned results to this many. Defaults to 65,535 if not specified. (optional)</param>
        /// <param name="filter">Expression to filter the result set.               For example, to filter on the LUPID, use \&quot;lusidPersonId eq &#39;string&#39;\&quot;              Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid. (optional)</param>
        /// <param name="propertyKeys">A list of property keys from the \&quot;Person\&quot; domain to decorate onto each person.              These take the format {domain}/{scope}/{code} e.g. \&quot;Person/ContactDetails/Address\&quot;. Defaults to include all properties if not specified. (optional)</param>
        /// <returns>Task of ApiResponse (ResourceListOfPerson)</returns>
        System.Threading.Tasks.Task<ApiResponse<ResourceListOfPerson>> ListPersonsAsyncWithHttpInfo (string idTypeScope, string idTypeCode, DateTimeOrCutLabel effectiveAt = null, DateTimeOffset? asAt = null, string page = null, int? start = null, int? limit = null, string filter = null, List<string> propertyKeys = null);
        /// <summary>
        /// [EXPERIMENTAL] Upsert Person
        /// </summary>
        /// <remarks>
        /// Create or update new person under specified scope
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="request">Request to create or update a person. (optional)</param>
        /// <returns>Task of Person</returns>
        System.Threading.Tasks.Task<Person> UpsertPersonAsync (UpsertPersonRequest request = null);

        /// <summary>
        /// [EXPERIMENTAL] Upsert Person
        /// </summary>
        /// <remarks>
        /// Create or update new person under specified scope
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="request">Request to create or update a person. (optional)</param>
        /// <returns>Task of ApiResponse (Person)</returns>
        System.Threading.Tasks.Task<ApiResponse<Person>> UpsertPersonAsyncWithHttpInfo (UpsertPersonRequest request = null);
        /// <summary>
        /// [EXPERIMENTAL] Upsert a Person Access Metadata entry associated with a specific metadataKey. This creates or updates the data in LUSID.
        /// </summary>
        /// <remarks>
        /// Update or insert one Person Access Metadata entry in a single scope. An item will be updated if it already exists  and inserted if it does not.                The response will return the successfully updated or inserted Person Access Metadata rule or failure message if unsuccessful.                It is important to always check to verify success (or failure).                Multiple rules for a metadataKey can exist with different effective at dates, when resources are accessed the rule that is active for the current time will be fetched.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier.</param>
        /// <param name="idTypeCode">Code of the person identifier.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code.</param>
        /// <param name="metadataKey">Key of the metadata entry to retrieve</param>
        /// <param name="request">The Person Access Metadata entry to upsert</param>
        /// <param name="effectiveAt">The effectiveAt datetime at which to upsert the Access Metadata (optional)</param>
        /// <returns>Task of ResourceListOfAccessMetadataValueOf</returns>
        System.Threading.Tasks.Task<ResourceListOfAccessMetadataValueOf> UpsertPersonAccessMetadataAsync (string idTypeScope, string idTypeCode, string code, string metadataKey, UpsertPersonAccessMetadataRequest request, DateTimeOrCutLabel effectiveAt = null);

        /// <summary>
        /// [EXPERIMENTAL] Upsert a Person Access Metadata entry associated with a specific metadataKey. This creates or updates the data in LUSID.
        /// </summary>
        /// <remarks>
        /// Update or insert one Person Access Metadata entry in a single scope. An item will be updated if it already exists  and inserted if it does not.                The response will return the successfully updated or inserted Person Access Metadata rule or failure message if unsuccessful.                It is important to always check to verify success (or failure).                Multiple rules for a metadataKey can exist with different effective at dates, when resources are accessed the rule that is active for the current time will be fetched.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier.</param>
        /// <param name="idTypeCode">Code of the person identifier.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code.</param>
        /// <param name="metadataKey">Key of the metadata entry to retrieve</param>
        /// <param name="request">The Person Access Metadata entry to upsert</param>
        /// <param name="effectiveAt">The effectiveAt datetime at which to upsert the Access Metadata (optional)</param>
        /// <returns>Task of ApiResponse (ResourceListOfAccessMetadataValueOf)</returns>
        System.Threading.Tasks.Task<ApiResponse<ResourceListOfAccessMetadataValueOf>> UpsertPersonAccessMetadataAsyncWithHttpInfo (string idTypeScope, string idTypeCode, string code, string metadataKey, UpsertPersonAccessMetadataRequest request, DateTimeOrCutLabel effectiveAt = null);
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class PersonsApi : IPersonsApi
    {
        private Lusid.Sdk.Client.ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Initializes a new instance of the <see cref="PersonsApi"/> class.
        /// </summary>
        /// <returns></returns>
        public PersonsApi(String basePath)
        {
            this.Configuration = new Lusid.Sdk.Client.Configuration { BasePath = basePath };

            ExceptionFactory = Lusid.Sdk.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="PersonsApi"/> class
        /// </summary>
        /// <returns></returns>
        public PersonsApi()
        {
            this.Configuration = Lusid.Sdk.Client.Configuration.Default;

            ExceptionFactory = Lusid.Sdk.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="PersonsApi"/> class
        /// using Configuration object
        /// </summary>
        /// <param name="configuration">An instance of Configuration</param>
        /// <returns></returns>
        public PersonsApi(Lusid.Sdk.Client.Configuration configuration = null)
        {
            if (configuration == null) // use the default one in Configuration
                this.Configuration = Lusid.Sdk.Client.Configuration.Default;
            else
                this.Configuration = configuration;

            ExceptionFactory = Lusid.Sdk.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public String GetBasePath()
        {
            return this.Configuration.ApiClient.RestClient.BaseUrl.ToString();
        }

        /// <summary>
        /// Sets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        [Obsolete("SetBasePath is deprecated, please do 'Configuration.ApiClient = new ApiClient(\"http://new-path\")' instead.")]
        public void SetBasePath(String basePath)
        {
            // do nothing
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public Lusid.Sdk.Client.Configuration Configuration {get; set;}

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public Lusid.Sdk.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }

        /// <summary>
        /// Gets the default header.
        /// </summary>
        /// <returns>Dictionary of HTTP header</returns>
        [Obsolete("DefaultHeader is deprecated, please use Configuration.DefaultHeader instead.")]
        public IDictionary<String, String> DefaultHeader()
        {
            return new ReadOnlyDictionary<string, string>(this.Configuration.DefaultHeader);
        }

        /// <summary>
        /// Add default header.
        /// </summary>
        /// <param name="key">Header field name.</param>
        /// <param name="value">Header field value.</param>
        /// <returns></returns>
        [Obsolete("AddDefaultHeader is deprecated, please use Configuration.AddDefaultHeader instead.")]
        public void AddDefaultHeader(string key, string value)
        {
            this.Configuration.AddDefaultHeader(key, value);
        }

        /// <summary>
        /// [EXPERIMENTAL] Delete person Delete a person. Deletion will be valid from the person&#39;s creation datetime.  This means that the person will no longer exist at any effective datetime from the asAt datetime of deletion.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">The scope of the person identifier type.</param>
        /// <param name="idTypeCode">The code of the person identifier type.</param>
        /// <param name="code">Code of the person under specified identifier type scope and code. This together with defined              identifier type uniquely identifies the person to delete.</param>
        /// <returns>DeletedEntityResponse</returns>
        public DeletedEntityResponse DeletePerson (string idTypeScope, string idTypeCode, string code)
        {
             ApiResponse<DeletedEntityResponse> localVarResponse = DeletePersonWithHttpInfo(idTypeScope, idTypeCode, code);
             return localVarResponse.Data;
        }

        /// <summary>
        /// [EXPERIMENTAL] Delete person Delete a person. Deletion will be valid from the person&#39;s creation datetime.  This means that the person will no longer exist at any effective datetime from the asAt datetime of deletion.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">The scope of the person identifier type.</param>
        /// <param name="idTypeCode">The code of the person identifier type.</param>
        /// <param name="code">Code of the person under specified identifier type scope and code. This together with defined              identifier type uniquely identifies the person to delete.</param>
        /// <returns>ApiResponse of DeletedEntityResponse</returns>
        public ApiResponse< DeletedEntityResponse > DeletePersonWithHttpInfo (string idTypeScope, string idTypeCode, string code)
        {
            // verify the required parameter 'idTypeScope' is set
            if (idTypeScope == null)
                throw new ApiException(400, "Missing required parameter 'idTypeScope' when calling PersonsApi->DeletePerson");
            // verify the required parameter 'idTypeCode' is set
            if (idTypeCode == null)
                throw new ApiException(400, "Missing required parameter 'idTypeCode' when calling PersonsApi->DeletePerson");
            // verify the required parameter 'code' is set
            if (code == null)
                throw new ApiException(400, "Missing required parameter 'code' when calling PersonsApi->DeletePerson");

            var localVarPath = "./api/persons/{idTypeScope}/{idTypeCode}/{code}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "text/plain",
                "application/json",
                "text/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (idTypeScope != null) localVarPathParams.Add("idTypeScope", this.Configuration.ApiClient.ParameterToString(idTypeScope)); // path parameter
            if (idTypeCode != null) localVarPathParams.Add("idTypeCode", this.Configuration.ApiClient.ParameterToString(idTypeCode)); // path parameter
            if (code != null) localVarPathParams.Add("code", this.Configuration.ApiClient.ParameterToString(code)); // path parameter

            // authentication (oauth2) required
            // oauth required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeletePerson", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<DeletedEntityResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => string.Join(",", x.Value)),
                (DeletedEntityResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(DeletedEntityResponse)));
        }

        /// <summary>
        /// [EXPERIMENTAL] Delete person Delete a person. Deletion will be valid from the person&#39;s creation datetime.  This means that the person will no longer exist at any effective datetime from the asAt datetime of deletion.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">The scope of the person identifier type.</param>
        /// <param name="idTypeCode">The code of the person identifier type.</param>
        /// <param name="code">Code of the person under specified identifier type scope and code. This together with defined              identifier type uniquely identifies the person to delete.</param>
        /// <returns>Task of DeletedEntityResponse</returns>
        public async System.Threading.Tasks.Task<DeletedEntityResponse> DeletePersonAsync (string idTypeScope, string idTypeCode, string code)
        {
             ApiResponse<DeletedEntityResponse> localVarResponse = await DeletePersonAsyncWithHttpInfo(idTypeScope, idTypeCode, code);
             return localVarResponse.Data;

        }

        /// <summary>
        /// [EXPERIMENTAL] Delete person Delete a person. Deletion will be valid from the person&#39;s creation datetime.  This means that the person will no longer exist at any effective datetime from the asAt datetime of deletion.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">The scope of the person identifier type.</param>
        /// <param name="idTypeCode">The code of the person identifier type.</param>
        /// <param name="code">Code of the person under specified identifier type scope and code. This together with defined              identifier type uniquely identifies the person to delete.</param>
        /// <returns>Task of ApiResponse (DeletedEntityResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<DeletedEntityResponse>> DeletePersonAsyncWithHttpInfo (string idTypeScope, string idTypeCode, string code)
        {
            // verify the required parameter 'idTypeScope' is set
            if (idTypeScope == null)
                throw new ApiException(400, "Missing required parameter 'idTypeScope' when calling PersonsApi->DeletePerson");
            // verify the required parameter 'idTypeCode' is set
            if (idTypeCode == null)
                throw new ApiException(400, "Missing required parameter 'idTypeCode' when calling PersonsApi->DeletePerson");
            // verify the required parameter 'code' is set
            if (code == null)
                throw new ApiException(400, "Missing required parameter 'code' when calling PersonsApi->DeletePerson");

            var localVarPath = "./api/persons/{idTypeScope}/{idTypeCode}/{code}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "text/plain",
                "application/json",
                "text/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (idTypeScope != null) localVarPathParams.Add("idTypeScope", this.Configuration.ApiClient.ParameterToString(idTypeScope)); // path parameter
            if (idTypeCode != null) localVarPathParams.Add("idTypeCode", this.Configuration.ApiClient.ParameterToString(idTypeCode)); // path parameter
            if (code != null) localVarPathParams.Add("code", this.Configuration.ApiClient.ParameterToString(code)); // path parameter

            // authentication (oauth2) required
            // oauth required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeletePerson", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<DeletedEntityResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => string.Join(",", x.Value)),
                (DeletedEntityResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(DeletedEntityResponse)));
        }

        /// <summary>
        /// [EXPERIMENTAL] Delete a Person Access Metadata entry Deletes the Person Access Metadata entry that exactly matches the provided identifier parts.    It is important to always check to verify success (or failure).
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier.</param>
        /// <param name="idTypeCode">Code of the person identifier.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code.</param>
        /// <param name="metadataKey">Key of the metadata entry to retrieve</param>
        /// <param name="effectiveAt">The effective date to delete at, if this is not supplied, it will delete all data found (optional)</param>
        /// <returns>DeletedEntityResponse</returns>
        public DeletedEntityResponse DeletePersonAccessMetadata (string idTypeScope, string idTypeCode, string code, string metadataKey, DateTimeOrCutLabel effectiveAt = null)
        {
             ApiResponse<DeletedEntityResponse> localVarResponse = DeletePersonAccessMetadataWithHttpInfo(idTypeScope, idTypeCode, code, metadataKey, effectiveAt);
             return localVarResponse.Data;
        }

        /// <summary>
        /// [EXPERIMENTAL] Delete a Person Access Metadata entry Deletes the Person Access Metadata entry that exactly matches the provided identifier parts.    It is important to always check to verify success (or failure).
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier.</param>
        /// <param name="idTypeCode">Code of the person identifier.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code.</param>
        /// <param name="metadataKey">Key of the metadata entry to retrieve</param>
        /// <param name="effectiveAt">The effective date to delete at, if this is not supplied, it will delete all data found (optional)</param>
        /// <returns>ApiResponse of DeletedEntityResponse</returns>
        public ApiResponse< DeletedEntityResponse > DeletePersonAccessMetadataWithHttpInfo (string idTypeScope, string idTypeCode, string code, string metadataKey, DateTimeOrCutLabel effectiveAt = null)
        {
            // verify the required parameter 'idTypeScope' is set
            if (idTypeScope == null)
                throw new ApiException(400, "Missing required parameter 'idTypeScope' when calling PersonsApi->DeletePersonAccessMetadata");
            // verify the required parameter 'idTypeCode' is set
            if (idTypeCode == null)
                throw new ApiException(400, "Missing required parameter 'idTypeCode' when calling PersonsApi->DeletePersonAccessMetadata");
            // verify the required parameter 'code' is set
            if (code == null)
                throw new ApiException(400, "Missing required parameter 'code' when calling PersonsApi->DeletePersonAccessMetadata");
            // verify the required parameter 'metadataKey' is set
            if (metadataKey == null)
                throw new ApiException(400, "Missing required parameter 'metadataKey' when calling PersonsApi->DeletePersonAccessMetadata");

            var localVarPath = "./api/persons/{idTypeScope}/{idTypeCode}/{code}/metadata/{metadataKey}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "text/plain",
                "application/json",
                "text/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (idTypeScope != null) localVarPathParams.Add("idTypeScope", this.Configuration.ApiClient.ParameterToString(idTypeScope)); // path parameter
            if (idTypeCode != null) localVarPathParams.Add("idTypeCode", this.Configuration.ApiClient.ParameterToString(idTypeCode)); // path parameter
            if (code != null) localVarPathParams.Add("code", this.Configuration.ApiClient.ParameterToString(code)); // path parameter
            if (metadataKey != null) localVarPathParams.Add("metadataKey", this.Configuration.ApiClient.ParameterToString(metadataKey)); // path parameter
            if (effectiveAt != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "effectiveAt", effectiveAt)); // query parameter

            // authentication (oauth2) required
            // oauth required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeletePersonAccessMetadata", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<DeletedEntityResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => string.Join(",", x.Value)),
                (DeletedEntityResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(DeletedEntityResponse)));
        }

        /// <summary>
        /// [EXPERIMENTAL] Delete a Person Access Metadata entry Deletes the Person Access Metadata entry that exactly matches the provided identifier parts.    It is important to always check to verify success (or failure).
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier.</param>
        /// <param name="idTypeCode">Code of the person identifier.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code.</param>
        /// <param name="metadataKey">Key of the metadata entry to retrieve</param>
        /// <param name="effectiveAt">The effective date to delete at, if this is not supplied, it will delete all data found (optional)</param>
        /// <returns>Task of DeletedEntityResponse</returns>
        public async System.Threading.Tasks.Task<DeletedEntityResponse> DeletePersonAccessMetadataAsync (string idTypeScope, string idTypeCode, string code, string metadataKey, DateTimeOrCutLabel effectiveAt = null)
        {
             ApiResponse<DeletedEntityResponse> localVarResponse = await DeletePersonAccessMetadataAsyncWithHttpInfo(idTypeScope, idTypeCode, code, metadataKey, effectiveAt);
             return localVarResponse.Data;

        }

        /// <summary>
        /// [EXPERIMENTAL] Delete a Person Access Metadata entry Deletes the Person Access Metadata entry that exactly matches the provided identifier parts.    It is important to always check to verify success (or failure).
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier.</param>
        /// <param name="idTypeCode">Code of the person identifier.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code.</param>
        /// <param name="metadataKey">Key of the metadata entry to retrieve</param>
        /// <param name="effectiveAt">The effective date to delete at, if this is not supplied, it will delete all data found (optional)</param>
        /// <returns>Task of ApiResponse (DeletedEntityResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<DeletedEntityResponse>> DeletePersonAccessMetadataAsyncWithHttpInfo (string idTypeScope, string idTypeCode, string code, string metadataKey, DateTimeOrCutLabel effectiveAt = null)
        {
            // verify the required parameter 'idTypeScope' is set
            if (idTypeScope == null)
                throw new ApiException(400, "Missing required parameter 'idTypeScope' when calling PersonsApi->DeletePersonAccessMetadata");
            // verify the required parameter 'idTypeCode' is set
            if (idTypeCode == null)
                throw new ApiException(400, "Missing required parameter 'idTypeCode' when calling PersonsApi->DeletePersonAccessMetadata");
            // verify the required parameter 'code' is set
            if (code == null)
                throw new ApiException(400, "Missing required parameter 'code' when calling PersonsApi->DeletePersonAccessMetadata");
            // verify the required parameter 'metadataKey' is set
            if (metadataKey == null)
                throw new ApiException(400, "Missing required parameter 'metadataKey' when calling PersonsApi->DeletePersonAccessMetadata");

            var localVarPath = "./api/persons/{idTypeScope}/{idTypeCode}/{code}/metadata/{metadataKey}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "text/plain",
                "application/json",
                "text/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (idTypeScope != null) localVarPathParams.Add("idTypeScope", this.Configuration.ApiClient.ParameterToString(idTypeScope)); // path parameter
            if (idTypeCode != null) localVarPathParams.Add("idTypeCode", this.Configuration.ApiClient.ParameterToString(idTypeCode)); // path parameter
            if (code != null) localVarPathParams.Add("code", this.Configuration.ApiClient.ParameterToString(code)); // path parameter
            if (metadataKey != null) localVarPathParams.Add("metadataKey", this.Configuration.ApiClient.ParameterToString(metadataKey)); // path parameter
            if (effectiveAt != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "effectiveAt", effectiveAt)); // query parameter

            // authentication (oauth2) required
            // oauth required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeletePersonAccessMetadata", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<DeletedEntityResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => string.Join(",", x.Value)),
                (DeletedEntityResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(DeletedEntityResponse)));
        }

        /// <summary>
        /// [EXPERIMENTAL] Get Access Metadata rules for a Person Pass the Scope and Code of the Person identifier along with the person code parameter to retrieve the associated Access Metadata
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier.</param>
        /// <param name="idTypeCode">Code of the person identifier.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code.</param>
        /// <param name="effectiveAt">The effectiveAt datetime at which to retrieve the Access Metadata (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the Access Metadata (optional)</param>
        /// <returns>Dictionary&lt;string, List&lt;AccessMetadataValue&gt;&gt;</returns>
        public Dictionary<string, List<AccessMetadataValue>> GetAllPersonAccessMetadata (string idTypeScope, string idTypeCode, string code, DateTimeOrCutLabel effectiveAt = null, DateTimeOffset? asAt = null)
        {
             ApiResponse<Dictionary<string, List<AccessMetadataValue>>> localVarResponse = GetAllPersonAccessMetadataWithHttpInfo(idTypeScope, idTypeCode, code, effectiveAt, asAt);
             return localVarResponse.Data;
        }

        /// <summary>
        /// [EXPERIMENTAL] Get Access Metadata rules for a Person Pass the Scope and Code of the Person identifier along with the person code parameter to retrieve the associated Access Metadata
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier.</param>
        /// <param name="idTypeCode">Code of the person identifier.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code.</param>
        /// <param name="effectiveAt">The effectiveAt datetime at which to retrieve the Access Metadata (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the Access Metadata (optional)</param>
        /// <returns>ApiResponse of Dictionary&lt;string, List&lt;AccessMetadataValue&gt;&gt;</returns>
        public ApiResponse< Dictionary<string, List<AccessMetadataValue>> > GetAllPersonAccessMetadataWithHttpInfo (string idTypeScope, string idTypeCode, string code, DateTimeOrCutLabel effectiveAt = null, DateTimeOffset? asAt = null)
        {
            // verify the required parameter 'idTypeScope' is set
            if (idTypeScope == null)
                throw new ApiException(400, "Missing required parameter 'idTypeScope' when calling PersonsApi->GetAllPersonAccessMetadata");
            // verify the required parameter 'idTypeCode' is set
            if (idTypeCode == null)
                throw new ApiException(400, "Missing required parameter 'idTypeCode' when calling PersonsApi->GetAllPersonAccessMetadata");
            // verify the required parameter 'code' is set
            if (code == null)
                throw new ApiException(400, "Missing required parameter 'code' when calling PersonsApi->GetAllPersonAccessMetadata");

            var localVarPath = "./api/persons/{idTypeScope}/{idTypeCode}/{code}/metadata";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "text/plain",
                "application/json",
                "text/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (idTypeScope != null) localVarPathParams.Add("idTypeScope", this.Configuration.ApiClient.ParameterToString(idTypeScope)); // path parameter
            if (idTypeCode != null) localVarPathParams.Add("idTypeCode", this.Configuration.ApiClient.ParameterToString(idTypeCode)); // path parameter
            if (code != null) localVarPathParams.Add("code", this.Configuration.ApiClient.ParameterToString(code)); // path parameter
            if (effectiveAt != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "effectiveAt", effectiveAt)); // query parameter
            if (asAt != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "asAt", asAt)); // query parameter

            // authentication (oauth2) required
            // oauth required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetAllPersonAccessMetadata", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Dictionary<string, List<AccessMetadataValue>>>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => string.Join(",", x.Value)),
                (Dictionary<string, List<AccessMetadataValue>>) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(Dictionary<string, List<AccessMetadataValue>>)));
        }

        /// <summary>
        /// [EXPERIMENTAL] Get Access Metadata rules for a Person Pass the Scope and Code of the Person identifier along with the person code parameter to retrieve the associated Access Metadata
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier.</param>
        /// <param name="idTypeCode">Code of the person identifier.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code.</param>
        /// <param name="effectiveAt">The effectiveAt datetime at which to retrieve the Access Metadata (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the Access Metadata (optional)</param>
        /// <returns>Task of Dictionary&lt;string, List&lt;AccessMetadataValue&gt;&gt;</returns>
        public async System.Threading.Tasks.Task<Dictionary<string, List<AccessMetadataValue>>> GetAllPersonAccessMetadataAsync (string idTypeScope, string idTypeCode, string code, DateTimeOrCutLabel effectiveAt = null, DateTimeOffset? asAt = null)
        {
             ApiResponse<Dictionary<string, List<AccessMetadataValue>>> localVarResponse = await GetAllPersonAccessMetadataAsyncWithHttpInfo(idTypeScope, idTypeCode, code, effectiveAt, asAt);
             return localVarResponse.Data;

        }

        /// <summary>
        /// [EXPERIMENTAL] Get Access Metadata rules for a Person Pass the Scope and Code of the Person identifier along with the person code parameter to retrieve the associated Access Metadata
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier.</param>
        /// <param name="idTypeCode">Code of the person identifier.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code.</param>
        /// <param name="effectiveAt">The effectiveAt datetime at which to retrieve the Access Metadata (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the Access Metadata (optional)</param>
        /// <returns>Task of ApiResponse (Dictionary&lt;string, List&lt;AccessMetadataValue&gt;&gt;)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Dictionary<string, List<AccessMetadataValue>>>> GetAllPersonAccessMetadataAsyncWithHttpInfo (string idTypeScope, string idTypeCode, string code, DateTimeOrCutLabel effectiveAt = null, DateTimeOffset? asAt = null)
        {
            // verify the required parameter 'idTypeScope' is set
            if (idTypeScope == null)
                throw new ApiException(400, "Missing required parameter 'idTypeScope' when calling PersonsApi->GetAllPersonAccessMetadata");
            // verify the required parameter 'idTypeCode' is set
            if (idTypeCode == null)
                throw new ApiException(400, "Missing required parameter 'idTypeCode' when calling PersonsApi->GetAllPersonAccessMetadata");
            // verify the required parameter 'code' is set
            if (code == null)
                throw new ApiException(400, "Missing required parameter 'code' when calling PersonsApi->GetAllPersonAccessMetadata");

            var localVarPath = "./api/persons/{idTypeScope}/{idTypeCode}/{code}/metadata";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "text/plain",
                "application/json",
                "text/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (idTypeScope != null) localVarPathParams.Add("idTypeScope", this.Configuration.ApiClient.ParameterToString(idTypeScope)); // path parameter
            if (idTypeCode != null) localVarPathParams.Add("idTypeCode", this.Configuration.ApiClient.ParameterToString(idTypeCode)); // path parameter
            if (code != null) localVarPathParams.Add("code", this.Configuration.ApiClient.ParameterToString(code)); // path parameter
            if (effectiveAt != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "effectiveAt", effectiveAt)); // query parameter
            if (asAt != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "asAt", asAt)); // query parameter

            // authentication (oauth2) required
            // oauth required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetAllPersonAccessMetadata", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Dictionary<string, List<AccessMetadataValue>>>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => string.Join(",", x.Value)),
                (Dictionary<string, List<AccessMetadataValue>>) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(Dictionary<string, List<AccessMetadataValue>>)));
        }

        /// <summary>
        /// [EXPERIMENTAL] Get Person Retrieve the definition of a person.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier type.</param>
        /// <param name="idTypeCode">Code of the person identifier type.</param>
        /// <param name="code">Code of the person under specified scope and code. This together with stated identifier type uniquely              identifies the person.</param>
        /// <param name="propertyKeys">A list of property keys from the \&quot;Person\&quot; domain to decorate onto each person.              These take the format {domain}/{scope}/{code} e.g. \&quot;Person/ContactDetails/Address\&quot;. Defaults to include all properties if not specified. (optional)</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to retrieve the person. Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the person. Defaults to return the latest version of the person if not specified. (optional)</param>
        /// <returns>Person</returns>
        public Person GetPerson (string idTypeScope, string idTypeCode, string code, List<string> propertyKeys = null, DateTimeOrCutLabel effectiveAt = null, DateTimeOffset? asAt = null)
        {
             ApiResponse<Person> localVarResponse = GetPersonWithHttpInfo(idTypeScope, idTypeCode, code, propertyKeys, effectiveAt, asAt);
             return localVarResponse.Data;
        }

        /// <summary>
        /// [EXPERIMENTAL] Get Person Retrieve the definition of a person.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier type.</param>
        /// <param name="idTypeCode">Code of the person identifier type.</param>
        /// <param name="code">Code of the person under specified scope and code. This together with stated identifier type uniquely              identifies the person.</param>
        /// <param name="propertyKeys">A list of property keys from the \&quot;Person\&quot; domain to decorate onto each person.              These take the format {domain}/{scope}/{code} e.g. \&quot;Person/ContactDetails/Address\&quot;. Defaults to include all properties if not specified. (optional)</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to retrieve the person. Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the person. Defaults to return the latest version of the person if not specified. (optional)</param>
        /// <returns>ApiResponse of Person</returns>
        public ApiResponse< Person > GetPersonWithHttpInfo (string idTypeScope, string idTypeCode, string code, List<string> propertyKeys = null, DateTimeOrCutLabel effectiveAt = null, DateTimeOffset? asAt = null)
        {
            // verify the required parameter 'idTypeScope' is set
            if (idTypeScope == null)
                throw new ApiException(400, "Missing required parameter 'idTypeScope' when calling PersonsApi->GetPerson");
            // verify the required parameter 'idTypeCode' is set
            if (idTypeCode == null)
                throw new ApiException(400, "Missing required parameter 'idTypeCode' when calling PersonsApi->GetPerson");
            // verify the required parameter 'code' is set
            if (code == null)
                throw new ApiException(400, "Missing required parameter 'code' when calling PersonsApi->GetPerson");

            var localVarPath = "./api/persons/{idTypeScope}/{idTypeCode}/{code}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "text/plain",
                "application/json",
                "text/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (idTypeScope != null) localVarPathParams.Add("idTypeScope", this.Configuration.ApiClient.ParameterToString(idTypeScope)); // path parameter
            if (idTypeCode != null) localVarPathParams.Add("idTypeCode", this.Configuration.ApiClient.ParameterToString(idTypeCode)); // path parameter
            if (code != null) localVarPathParams.Add("code", this.Configuration.ApiClient.ParameterToString(code)); // path parameter
            if (propertyKeys != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "propertyKeys", propertyKeys)); // query parameter
            if (effectiveAt != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "effectiveAt", effectiveAt)); // query parameter
            if (asAt != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "asAt", asAt)); // query parameter

            // authentication (oauth2) required
            // oauth required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetPerson", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Person>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => string.Join(",", x.Value)),
                (Person) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(Person)));
        }

        /// <summary>
        /// [EXPERIMENTAL] Get Person Retrieve the definition of a person.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier type.</param>
        /// <param name="idTypeCode">Code of the person identifier type.</param>
        /// <param name="code">Code of the person under specified scope and code. This together with stated identifier type uniquely              identifies the person.</param>
        /// <param name="propertyKeys">A list of property keys from the \&quot;Person\&quot; domain to decorate onto each person.              These take the format {domain}/{scope}/{code} e.g. \&quot;Person/ContactDetails/Address\&quot;. Defaults to include all properties if not specified. (optional)</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to retrieve the person. Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the person. Defaults to return the latest version of the person if not specified. (optional)</param>
        /// <returns>Task of Person</returns>
        public async System.Threading.Tasks.Task<Person> GetPersonAsync (string idTypeScope, string idTypeCode, string code, List<string> propertyKeys = null, DateTimeOrCutLabel effectiveAt = null, DateTimeOffset? asAt = null)
        {
             ApiResponse<Person> localVarResponse = await GetPersonAsyncWithHttpInfo(idTypeScope, idTypeCode, code, propertyKeys, effectiveAt, asAt);
             return localVarResponse.Data;

        }

        /// <summary>
        /// [EXPERIMENTAL] Get Person Retrieve the definition of a person.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier type.</param>
        /// <param name="idTypeCode">Code of the person identifier type.</param>
        /// <param name="code">Code of the person under specified scope and code. This together with stated identifier type uniquely              identifies the person.</param>
        /// <param name="propertyKeys">A list of property keys from the \&quot;Person\&quot; domain to decorate onto each person.              These take the format {domain}/{scope}/{code} e.g. \&quot;Person/ContactDetails/Address\&quot;. Defaults to include all properties if not specified. (optional)</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to retrieve the person. Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the person. Defaults to return the latest version of the person if not specified. (optional)</param>
        /// <returns>Task of ApiResponse (Person)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Person>> GetPersonAsyncWithHttpInfo (string idTypeScope, string idTypeCode, string code, List<string> propertyKeys = null, DateTimeOrCutLabel effectiveAt = null, DateTimeOffset? asAt = null)
        {
            // verify the required parameter 'idTypeScope' is set
            if (idTypeScope == null)
                throw new ApiException(400, "Missing required parameter 'idTypeScope' when calling PersonsApi->GetPerson");
            // verify the required parameter 'idTypeCode' is set
            if (idTypeCode == null)
                throw new ApiException(400, "Missing required parameter 'idTypeCode' when calling PersonsApi->GetPerson");
            // verify the required parameter 'code' is set
            if (code == null)
                throw new ApiException(400, "Missing required parameter 'code' when calling PersonsApi->GetPerson");

            var localVarPath = "./api/persons/{idTypeScope}/{idTypeCode}/{code}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "text/plain",
                "application/json",
                "text/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (idTypeScope != null) localVarPathParams.Add("idTypeScope", this.Configuration.ApiClient.ParameterToString(idTypeScope)); // path parameter
            if (idTypeCode != null) localVarPathParams.Add("idTypeCode", this.Configuration.ApiClient.ParameterToString(idTypeCode)); // path parameter
            if (code != null) localVarPathParams.Add("code", this.Configuration.ApiClient.ParameterToString(code)); // path parameter
            if (propertyKeys != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "propertyKeys", propertyKeys)); // query parameter
            if (effectiveAt != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "effectiveAt", effectiveAt)); // query parameter
            if (asAt != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "asAt", asAt)); // query parameter

            // authentication (oauth2) required
            // oauth required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetPerson", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Person>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => string.Join(",", x.Value)),
                (Person) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(Person)));
        }

        /// <summary>
        /// [EXPERIMENTAL] Get an entry identified by a metadataKey in the Access Metadata of a Person Get a specific Person Access Metadata by specifying the corresponding identifier parts and Person code                No matching will be performed through this endpoint. To retrieve an entry, it is necessary to specify, exactly, the identifier of the entry
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier.</param>
        /// <param name="idTypeCode">Code of the person identifier.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code.</param>
        /// <param name="metadataKey">Key of the metadata entry to retrieve</param>
        /// <param name="effectiveAt">The effectiveAt datetime at which to retrieve the Access Metadata (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the Access Metadata (optional)</param>
        /// <returns>ICollection&lt;AccessMetadataValue&gt;</returns>
        public ICollection<AccessMetadataValue> GetPersonAccessMetadataByKey (string idTypeScope, string idTypeCode, string code, string metadataKey, DateTimeOrCutLabel effectiveAt = null, DateTimeOffset? asAt = null)
        {
             ApiResponse<ICollection<AccessMetadataValue>> localVarResponse = GetPersonAccessMetadataByKeyWithHttpInfo(idTypeScope, idTypeCode, code, metadataKey, effectiveAt, asAt);
             return localVarResponse.Data;
        }

        /// <summary>
        /// [EXPERIMENTAL] Get an entry identified by a metadataKey in the Access Metadata of a Person Get a specific Person Access Metadata by specifying the corresponding identifier parts and Person code                No matching will be performed through this endpoint. To retrieve an entry, it is necessary to specify, exactly, the identifier of the entry
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier.</param>
        /// <param name="idTypeCode">Code of the person identifier.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code.</param>
        /// <param name="metadataKey">Key of the metadata entry to retrieve</param>
        /// <param name="effectiveAt">The effectiveAt datetime at which to retrieve the Access Metadata (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the Access Metadata (optional)</param>
        /// <returns>ApiResponse of ICollection&lt;AccessMetadataValue&gt;</returns>
        public ApiResponse< ICollection<AccessMetadataValue> > GetPersonAccessMetadataByKeyWithHttpInfo (string idTypeScope, string idTypeCode, string code, string metadataKey, DateTimeOrCutLabel effectiveAt = null, DateTimeOffset? asAt = null)
        {
            // verify the required parameter 'idTypeScope' is set
            if (idTypeScope == null)
                throw new ApiException(400, "Missing required parameter 'idTypeScope' when calling PersonsApi->GetPersonAccessMetadataByKey");
            // verify the required parameter 'idTypeCode' is set
            if (idTypeCode == null)
                throw new ApiException(400, "Missing required parameter 'idTypeCode' when calling PersonsApi->GetPersonAccessMetadataByKey");
            // verify the required parameter 'code' is set
            if (code == null)
                throw new ApiException(400, "Missing required parameter 'code' when calling PersonsApi->GetPersonAccessMetadataByKey");
            // verify the required parameter 'metadataKey' is set
            if (metadataKey == null)
                throw new ApiException(400, "Missing required parameter 'metadataKey' when calling PersonsApi->GetPersonAccessMetadataByKey");

            var localVarPath = "./api/persons/{idTypeScope}/{idTypeCode}/{code}/metadata/{metadataKey}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "text/plain",
                "application/json",
                "text/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (idTypeScope != null) localVarPathParams.Add("idTypeScope", this.Configuration.ApiClient.ParameterToString(idTypeScope)); // path parameter
            if (idTypeCode != null) localVarPathParams.Add("idTypeCode", this.Configuration.ApiClient.ParameterToString(idTypeCode)); // path parameter
            if (code != null) localVarPathParams.Add("code", this.Configuration.ApiClient.ParameterToString(code)); // path parameter
            if (metadataKey != null) localVarPathParams.Add("metadataKey", this.Configuration.ApiClient.ParameterToString(metadataKey)); // path parameter
            if (effectiveAt != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "effectiveAt", effectiveAt)); // query parameter
            if (asAt != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "asAt", asAt)); // query parameter

            // authentication (oauth2) required
            // oauth required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetPersonAccessMetadataByKey", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<ICollection<AccessMetadataValue>>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => string.Join(",", x.Value)),
                (ICollection<AccessMetadataValue>) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(List<AccessMetadataValue>)));
        }

        /// <summary>
        /// [EXPERIMENTAL] Get an entry identified by a metadataKey in the Access Metadata of a Person Get a specific Person Access Metadata by specifying the corresponding identifier parts and Person code                No matching will be performed through this endpoint. To retrieve an entry, it is necessary to specify, exactly, the identifier of the entry
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier.</param>
        /// <param name="idTypeCode">Code of the person identifier.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code.</param>
        /// <param name="metadataKey">Key of the metadata entry to retrieve</param>
        /// <param name="effectiveAt">The effectiveAt datetime at which to retrieve the Access Metadata (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the Access Metadata (optional)</param>
        /// <returns>Task of ICollection&lt;AccessMetadataValue&gt;</returns>
        public async System.Threading.Tasks.Task<ICollection<AccessMetadataValue>> GetPersonAccessMetadataByKeyAsync (string idTypeScope, string idTypeCode, string code, string metadataKey, DateTimeOrCutLabel effectiveAt = null, DateTimeOffset? asAt = null)
        {
             ApiResponse<ICollection<AccessMetadataValue>> localVarResponse = await GetPersonAccessMetadataByKeyAsyncWithHttpInfo(idTypeScope, idTypeCode, code, metadataKey, effectiveAt, asAt);
             return localVarResponse.Data;

        }

        /// <summary>
        /// [EXPERIMENTAL] Get an entry identified by a metadataKey in the Access Metadata of a Person Get a specific Person Access Metadata by specifying the corresponding identifier parts and Person code                No matching will be performed through this endpoint. To retrieve an entry, it is necessary to specify, exactly, the identifier of the entry
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier.</param>
        /// <param name="idTypeCode">Code of the person identifier.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code.</param>
        /// <param name="metadataKey">Key of the metadata entry to retrieve</param>
        /// <param name="effectiveAt">The effectiveAt datetime at which to retrieve the Access Metadata (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the Access Metadata (optional)</param>
        /// <returns>Task of ApiResponse (ICollection&lt;AccessMetadataValue&gt;)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<ICollection<AccessMetadataValue>>> GetPersonAccessMetadataByKeyAsyncWithHttpInfo (string idTypeScope, string idTypeCode, string code, string metadataKey, DateTimeOrCutLabel effectiveAt = null, DateTimeOffset? asAt = null)
        {
            // verify the required parameter 'idTypeScope' is set
            if (idTypeScope == null)
                throw new ApiException(400, "Missing required parameter 'idTypeScope' when calling PersonsApi->GetPersonAccessMetadataByKey");
            // verify the required parameter 'idTypeCode' is set
            if (idTypeCode == null)
                throw new ApiException(400, "Missing required parameter 'idTypeCode' when calling PersonsApi->GetPersonAccessMetadataByKey");
            // verify the required parameter 'code' is set
            if (code == null)
                throw new ApiException(400, "Missing required parameter 'code' when calling PersonsApi->GetPersonAccessMetadataByKey");
            // verify the required parameter 'metadataKey' is set
            if (metadataKey == null)
                throw new ApiException(400, "Missing required parameter 'metadataKey' when calling PersonsApi->GetPersonAccessMetadataByKey");

            var localVarPath = "./api/persons/{idTypeScope}/{idTypeCode}/{code}/metadata/{metadataKey}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "text/plain",
                "application/json",
                "text/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (idTypeScope != null) localVarPathParams.Add("idTypeScope", this.Configuration.ApiClient.ParameterToString(idTypeScope)); // path parameter
            if (idTypeCode != null) localVarPathParams.Add("idTypeCode", this.Configuration.ApiClient.ParameterToString(idTypeCode)); // path parameter
            if (code != null) localVarPathParams.Add("code", this.Configuration.ApiClient.ParameterToString(code)); // path parameter
            if (metadataKey != null) localVarPathParams.Add("metadataKey", this.Configuration.ApiClient.ParameterToString(metadataKey)); // path parameter
            if (effectiveAt != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "effectiveAt", effectiveAt)); // query parameter
            if (asAt != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "asAt", asAt)); // query parameter

            // authentication (oauth2) required
            // oauth required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetPersonAccessMetadataByKey", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<ICollection<AccessMetadataValue>>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => string.Join(",", x.Value)),
                (ICollection<AccessMetadataValue>) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(List<AccessMetadataValue>)));
        }

        /// <summary>
        /// [EXPERIMENTAL] List Persons List persons which has identifier of specific identifier type&#39;s scope and code, and satisfies filter criteria.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier type.</param>
        /// <param name="idTypeCode">Code of the person identifier type.</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to list the people. Defaults to the current LUSID              system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to list the people. Defaults to return the latest version              of each people if not specified. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing portfolios from a previous call to list portfolios. This  value is returned from the previous call. If a pagination token is provided the filter, effectiveAt  and asAt fields must not have changed since the original request. Also, if set, a start value cannot be provided. (optional)</param>
        /// <param name="start">When paginating, skip this number of results. (optional)</param>
        /// <param name="limit">When paginating, limit the number of returned results to this many. Defaults to 65,535 if not specified. (optional)</param>
        /// <param name="filter">Expression to filter the result set.               For example, to filter on the LUPID, use \&quot;lusidPersonId eq &#39;string&#39;\&quot;              Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid. (optional)</param>
        /// <param name="propertyKeys">A list of property keys from the \&quot;Person\&quot; domain to decorate onto each person.              These take the format {domain}/{scope}/{code} e.g. \&quot;Person/ContactDetails/Address\&quot;. Defaults to include all properties if not specified. (optional)</param>
        /// <returns>ResourceListOfPerson</returns>
        public ResourceListOfPerson ListPersons (string idTypeScope, string idTypeCode, DateTimeOrCutLabel effectiveAt = null, DateTimeOffset? asAt = null, string page = null, int? start = null, int? limit = null, string filter = null, List<string> propertyKeys = null)
        {
             ApiResponse<ResourceListOfPerson> localVarResponse = ListPersonsWithHttpInfo(idTypeScope, idTypeCode, effectiveAt, asAt, page, start, limit, filter, propertyKeys);
             return localVarResponse.Data;
        }

        /// <summary>
        /// [EXPERIMENTAL] List Persons List persons which has identifier of specific identifier type&#39;s scope and code, and satisfies filter criteria.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier type.</param>
        /// <param name="idTypeCode">Code of the person identifier type.</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to list the people. Defaults to the current LUSID              system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to list the people. Defaults to return the latest version              of each people if not specified. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing portfolios from a previous call to list portfolios. This  value is returned from the previous call. If a pagination token is provided the filter, effectiveAt  and asAt fields must not have changed since the original request. Also, if set, a start value cannot be provided. (optional)</param>
        /// <param name="start">When paginating, skip this number of results. (optional)</param>
        /// <param name="limit">When paginating, limit the number of returned results to this many. Defaults to 65,535 if not specified. (optional)</param>
        /// <param name="filter">Expression to filter the result set.               For example, to filter on the LUPID, use \&quot;lusidPersonId eq &#39;string&#39;\&quot;              Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid. (optional)</param>
        /// <param name="propertyKeys">A list of property keys from the \&quot;Person\&quot; domain to decorate onto each person.              These take the format {domain}/{scope}/{code} e.g. \&quot;Person/ContactDetails/Address\&quot;. Defaults to include all properties if not specified. (optional)</param>
        /// <returns>ApiResponse of ResourceListOfPerson</returns>
        public ApiResponse< ResourceListOfPerson > ListPersonsWithHttpInfo (string idTypeScope, string idTypeCode, DateTimeOrCutLabel effectiveAt = null, DateTimeOffset? asAt = null, string page = null, int? start = null, int? limit = null, string filter = null, List<string> propertyKeys = null)
        {
            // verify the required parameter 'idTypeScope' is set
            if (idTypeScope == null)
                throw new ApiException(400, "Missing required parameter 'idTypeScope' when calling PersonsApi->ListPersons");
            // verify the required parameter 'idTypeCode' is set
            if (idTypeCode == null)
                throw new ApiException(400, "Missing required parameter 'idTypeCode' when calling PersonsApi->ListPersons");

            var localVarPath = "./api/persons/{idTypeScope}/{idTypeCode}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "text/plain",
                "application/json",
                "text/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (idTypeScope != null) localVarPathParams.Add("idTypeScope", this.Configuration.ApiClient.ParameterToString(idTypeScope)); // path parameter
            if (idTypeCode != null) localVarPathParams.Add("idTypeCode", this.Configuration.ApiClient.ParameterToString(idTypeCode)); // path parameter
            if (effectiveAt != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "effectiveAt", effectiveAt)); // query parameter
            if (asAt != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "asAt", asAt)); // query parameter
            if (page != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "page", page)); // query parameter
            if (start != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "start", start)); // query parameter
            if (limit != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "limit", limit)); // query parameter
            if (filter != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "filter", filter)); // query parameter
            if (propertyKeys != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "propertyKeys", propertyKeys)); // query parameter

            // authentication (oauth2) required
            // oauth required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ListPersons", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<ResourceListOfPerson>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => string.Join(",", x.Value)),
                (ResourceListOfPerson) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(ResourceListOfPerson)));
        }

        /// <summary>
        /// [EXPERIMENTAL] List Persons List persons which has identifier of specific identifier type&#39;s scope and code, and satisfies filter criteria.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier type.</param>
        /// <param name="idTypeCode">Code of the person identifier type.</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to list the people. Defaults to the current LUSID              system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to list the people. Defaults to return the latest version              of each people if not specified. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing portfolios from a previous call to list portfolios. This  value is returned from the previous call. If a pagination token is provided the filter, effectiveAt  and asAt fields must not have changed since the original request. Also, if set, a start value cannot be provided. (optional)</param>
        /// <param name="start">When paginating, skip this number of results. (optional)</param>
        /// <param name="limit">When paginating, limit the number of returned results to this many. Defaults to 65,535 if not specified. (optional)</param>
        /// <param name="filter">Expression to filter the result set.               For example, to filter on the LUPID, use \&quot;lusidPersonId eq &#39;string&#39;\&quot;              Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid. (optional)</param>
        /// <param name="propertyKeys">A list of property keys from the \&quot;Person\&quot; domain to decorate onto each person.              These take the format {domain}/{scope}/{code} e.g. \&quot;Person/ContactDetails/Address\&quot;. Defaults to include all properties if not specified. (optional)</param>
        /// <returns>Task of ResourceListOfPerson</returns>
        public async System.Threading.Tasks.Task<ResourceListOfPerson> ListPersonsAsync (string idTypeScope, string idTypeCode, DateTimeOrCutLabel effectiveAt = null, DateTimeOffset? asAt = null, string page = null, int? start = null, int? limit = null, string filter = null, List<string> propertyKeys = null)
        {
             ApiResponse<ResourceListOfPerson> localVarResponse = await ListPersonsAsyncWithHttpInfo(idTypeScope, idTypeCode, effectiveAt, asAt, page, start, limit, filter, propertyKeys);
             return localVarResponse.Data;

        }

        /// <summary>
        /// [EXPERIMENTAL] List Persons List persons which has identifier of specific identifier type&#39;s scope and code, and satisfies filter criteria.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier type.</param>
        /// <param name="idTypeCode">Code of the person identifier type.</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to list the people. Defaults to the current LUSID              system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to list the people. Defaults to return the latest version              of each people if not specified. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing portfolios from a previous call to list portfolios. This  value is returned from the previous call. If a pagination token is provided the filter, effectiveAt  and asAt fields must not have changed since the original request. Also, if set, a start value cannot be provided. (optional)</param>
        /// <param name="start">When paginating, skip this number of results. (optional)</param>
        /// <param name="limit">When paginating, limit the number of returned results to this many. Defaults to 65,535 if not specified. (optional)</param>
        /// <param name="filter">Expression to filter the result set.               For example, to filter on the LUPID, use \&quot;lusidPersonId eq &#39;string&#39;\&quot;              Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid. (optional)</param>
        /// <param name="propertyKeys">A list of property keys from the \&quot;Person\&quot; domain to decorate onto each person.              These take the format {domain}/{scope}/{code} e.g. \&quot;Person/ContactDetails/Address\&quot;. Defaults to include all properties if not specified. (optional)</param>
        /// <returns>Task of ApiResponse (ResourceListOfPerson)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<ResourceListOfPerson>> ListPersonsAsyncWithHttpInfo (string idTypeScope, string idTypeCode, DateTimeOrCutLabel effectiveAt = null, DateTimeOffset? asAt = null, string page = null, int? start = null, int? limit = null, string filter = null, List<string> propertyKeys = null)
        {
            // verify the required parameter 'idTypeScope' is set
            if (idTypeScope == null)
                throw new ApiException(400, "Missing required parameter 'idTypeScope' when calling PersonsApi->ListPersons");
            // verify the required parameter 'idTypeCode' is set
            if (idTypeCode == null)
                throw new ApiException(400, "Missing required parameter 'idTypeCode' when calling PersonsApi->ListPersons");

            var localVarPath = "./api/persons/{idTypeScope}/{idTypeCode}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "text/plain",
                "application/json",
                "text/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (idTypeScope != null) localVarPathParams.Add("idTypeScope", this.Configuration.ApiClient.ParameterToString(idTypeScope)); // path parameter
            if (idTypeCode != null) localVarPathParams.Add("idTypeCode", this.Configuration.ApiClient.ParameterToString(idTypeCode)); // path parameter
            if (effectiveAt != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "effectiveAt", effectiveAt)); // query parameter
            if (asAt != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "asAt", asAt)); // query parameter
            if (page != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "page", page)); // query parameter
            if (start != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "start", start)); // query parameter
            if (limit != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "limit", limit)); // query parameter
            if (filter != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "filter", filter)); // query parameter
            if (propertyKeys != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "propertyKeys", propertyKeys)); // query parameter

            // authentication (oauth2) required
            // oauth required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ListPersons", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<ResourceListOfPerson>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => string.Join(",", x.Value)),
                (ResourceListOfPerson) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(ResourceListOfPerson)));
        }

        /// <summary>
        /// [EXPERIMENTAL] Upsert Person Create or update new person under specified scope
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="request">Request to create or update a person. (optional)</param>
        /// <returns>Person</returns>
        public Person UpsertPerson (UpsertPersonRequest request = null)
        {
             ApiResponse<Person> localVarResponse = UpsertPersonWithHttpInfo(request);
             return localVarResponse.Data;
        }

        /// <summary>
        /// [EXPERIMENTAL] Upsert Person Create or update new person under specified scope
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="request">Request to create or update a person. (optional)</param>
        /// <returns>ApiResponse of Person</returns>
        public ApiResponse< Person > UpsertPersonWithHttpInfo (UpsertPersonRequest request = null)
        {

            var localVarPath = "./api/persons";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "text/plain",
                "application/json",
                "text/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (request != null && request.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(request); // http body (model) parameter
            }
            else
            {
                localVarPostBody = request; // byte array
            }

            // authentication (oauth2) required
            // oauth required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpsertPerson", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Person>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => string.Join(",", x.Value)),
                (Person) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(Person)));
        }

        /// <summary>
        /// [EXPERIMENTAL] Upsert Person Create or update new person under specified scope
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="request">Request to create or update a person. (optional)</param>
        /// <returns>Task of Person</returns>
        public async System.Threading.Tasks.Task<Person> UpsertPersonAsync (UpsertPersonRequest request = null)
        {
             ApiResponse<Person> localVarResponse = await UpsertPersonAsyncWithHttpInfo(request);
             return localVarResponse.Data;

        }

        /// <summary>
        /// [EXPERIMENTAL] Upsert Person Create or update new person under specified scope
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="request">Request to create or update a person. (optional)</param>
        /// <returns>Task of ApiResponse (Person)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Person>> UpsertPersonAsyncWithHttpInfo (UpsertPersonRequest request = null)
        {

            var localVarPath = "./api/persons";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "text/plain",
                "application/json",
                "text/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (request != null && request.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(request); // http body (model) parameter
            }
            else
            {
                localVarPostBody = request; // byte array
            }

            // authentication (oauth2) required
            // oauth required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpsertPerson", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Person>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => string.Join(",", x.Value)),
                (Person) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(Person)));
        }

        /// <summary>
        /// [EXPERIMENTAL] Upsert a Person Access Metadata entry associated with a specific metadataKey. This creates or updates the data in LUSID. Update or insert one Person Access Metadata entry in a single scope. An item will be updated if it already exists  and inserted if it does not.                The response will return the successfully updated or inserted Person Access Metadata rule or failure message if unsuccessful.                It is important to always check to verify success (or failure).                Multiple rules for a metadataKey can exist with different effective at dates, when resources are accessed the rule that is active for the current time will be fetched.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier.</param>
        /// <param name="idTypeCode">Code of the person identifier.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code.</param>
        /// <param name="metadataKey">Key of the metadata entry to retrieve</param>
        /// <param name="request">The Person Access Metadata entry to upsert</param>
        /// <param name="effectiveAt">The effectiveAt datetime at which to upsert the Access Metadata (optional)</param>
        /// <returns>ResourceListOfAccessMetadataValueOf</returns>
        public ResourceListOfAccessMetadataValueOf UpsertPersonAccessMetadata (string idTypeScope, string idTypeCode, string code, string metadataKey, UpsertPersonAccessMetadataRequest request, DateTimeOrCutLabel effectiveAt = null)
        {
             ApiResponse<ResourceListOfAccessMetadataValueOf> localVarResponse = UpsertPersonAccessMetadataWithHttpInfo(idTypeScope, idTypeCode, code, metadataKey, request, effectiveAt);
             return localVarResponse.Data;
        }

        /// <summary>
        /// [EXPERIMENTAL] Upsert a Person Access Metadata entry associated with a specific metadataKey. This creates or updates the data in LUSID. Update or insert one Person Access Metadata entry in a single scope. An item will be updated if it already exists  and inserted if it does not.                The response will return the successfully updated or inserted Person Access Metadata rule or failure message if unsuccessful.                It is important to always check to verify success (or failure).                Multiple rules for a metadataKey can exist with different effective at dates, when resources are accessed the rule that is active for the current time will be fetched.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier.</param>
        /// <param name="idTypeCode">Code of the person identifier.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code.</param>
        /// <param name="metadataKey">Key of the metadata entry to retrieve</param>
        /// <param name="request">The Person Access Metadata entry to upsert</param>
        /// <param name="effectiveAt">The effectiveAt datetime at which to upsert the Access Metadata (optional)</param>
        /// <returns>ApiResponse of ResourceListOfAccessMetadataValueOf</returns>
        public ApiResponse< ResourceListOfAccessMetadataValueOf > UpsertPersonAccessMetadataWithHttpInfo (string idTypeScope, string idTypeCode, string code, string metadataKey, UpsertPersonAccessMetadataRequest request, DateTimeOrCutLabel effectiveAt = null)
        {
            // verify the required parameter 'idTypeScope' is set
            if (idTypeScope == null)
                throw new ApiException(400, "Missing required parameter 'idTypeScope' when calling PersonsApi->UpsertPersonAccessMetadata");
            // verify the required parameter 'idTypeCode' is set
            if (idTypeCode == null)
                throw new ApiException(400, "Missing required parameter 'idTypeCode' when calling PersonsApi->UpsertPersonAccessMetadata");
            // verify the required parameter 'code' is set
            if (code == null)
                throw new ApiException(400, "Missing required parameter 'code' when calling PersonsApi->UpsertPersonAccessMetadata");
            // verify the required parameter 'metadataKey' is set
            if (metadataKey == null)
                throw new ApiException(400, "Missing required parameter 'metadataKey' when calling PersonsApi->UpsertPersonAccessMetadata");
            // verify the required parameter 'request' is set
            if (request == null)
                throw new ApiException(400, "Missing required parameter 'request' when calling PersonsApi->UpsertPersonAccessMetadata");

            var localVarPath = "./api/persons/{idTypeScope}/{idTypeCode}/{code}/metadata/{metadataKey}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "text/plain",
                "application/json",
                "text/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (idTypeScope != null) localVarPathParams.Add("idTypeScope", this.Configuration.ApiClient.ParameterToString(idTypeScope)); // path parameter
            if (idTypeCode != null) localVarPathParams.Add("idTypeCode", this.Configuration.ApiClient.ParameterToString(idTypeCode)); // path parameter
            if (code != null) localVarPathParams.Add("code", this.Configuration.ApiClient.ParameterToString(code)); // path parameter
            if (metadataKey != null) localVarPathParams.Add("metadataKey", this.Configuration.ApiClient.ParameterToString(metadataKey)); // path parameter
            if (effectiveAt != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "effectiveAt", effectiveAt)); // query parameter
            if (request != null && request.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(request); // http body (model) parameter
            }
            else
            {
                localVarPostBody = request; // byte array
            }

            // authentication (oauth2) required
            // oauth required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpsertPersonAccessMetadata", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<ResourceListOfAccessMetadataValueOf>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => string.Join(",", x.Value)),
                (ResourceListOfAccessMetadataValueOf) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(ResourceListOfAccessMetadataValueOf)));
        }

        /// <summary>
        /// [EXPERIMENTAL] Upsert a Person Access Metadata entry associated with a specific metadataKey. This creates or updates the data in LUSID. Update or insert one Person Access Metadata entry in a single scope. An item will be updated if it already exists  and inserted if it does not.                The response will return the successfully updated or inserted Person Access Metadata rule or failure message if unsuccessful.                It is important to always check to verify success (or failure).                Multiple rules for a metadataKey can exist with different effective at dates, when resources are accessed the rule that is active for the current time will be fetched.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier.</param>
        /// <param name="idTypeCode">Code of the person identifier.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code.</param>
        /// <param name="metadataKey">Key of the metadata entry to retrieve</param>
        /// <param name="request">The Person Access Metadata entry to upsert</param>
        /// <param name="effectiveAt">The effectiveAt datetime at which to upsert the Access Metadata (optional)</param>
        /// <returns>Task of ResourceListOfAccessMetadataValueOf</returns>
        public async System.Threading.Tasks.Task<ResourceListOfAccessMetadataValueOf> UpsertPersonAccessMetadataAsync (string idTypeScope, string idTypeCode, string code, string metadataKey, UpsertPersonAccessMetadataRequest request, DateTimeOrCutLabel effectiveAt = null)
        {
             ApiResponse<ResourceListOfAccessMetadataValueOf> localVarResponse = await UpsertPersonAccessMetadataAsyncWithHttpInfo(idTypeScope, idTypeCode, code, metadataKey, request, effectiveAt);
             return localVarResponse.Data;

        }

        /// <summary>
        /// [EXPERIMENTAL] Upsert a Person Access Metadata entry associated with a specific metadataKey. This creates or updates the data in LUSID. Update or insert one Person Access Metadata entry in a single scope. An item will be updated if it already exists  and inserted if it does not.                The response will return the successfully updated or inserted Person Access Metadata rule or failure message if unsuccessful.                It is important to always check to verify success (or failure).                Multiple rules for a metadataKey can exist with different effective at dates, when resources are accessed the rule that is active for the current time will be fetched.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier.</param>
        /// <param name="idTypeCode">Code of the person identifier.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code.</param>
        /// <param name="metadataKey">Key of the metadata entry to retrieve</param>
        /// <param name="request">The Person Access Metadata entry to upsert</param>
        /// <param name="effectiveAt">The effectiveAt datetime at which to upsert the Access Metadata (optional)</param>
        /// <returns>Task of ApiResponse (ResourceListOfAccessMetadataValueOf)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<ResourceListOfAccessMetadataValueOf>> UpsertPersonAccessMetadataAsyncWithHttpInfo (string idTypeScope, string idTypeCode, string code, string metadataKey, UpsertPersonAccessMetadataRequest request, DateTimeOrCutLabel effectiveAt = null)
        {
            // verify the required parameter 'idTypeScope' is set
            if (idTypeScope == null)
                throw new ApiException(400, "Missing required parameter 'idTypeScope' when calling PersonsApi->UpsertPersonAccessMetadata");
            // verify the required parameter 'idTypeCode' is set
            if (idTypeCode == null)
                throw new ApiException(400, "Missing required parameter 'idTypeCode' when calling PersonsApi->UpsertPersonAccessMetadata");
            // verify the required parameter 'code' is set
            if (code == null)
                throw new ApiException(400, "Missing required parameter 'code' when calling PersonsApi->UpsertPersonAccessMetadata");
            // verify the required parameter 'metadataKey' is set
            if (metadataKey == null)
                throw new ApiException(400, "Missing required parameter 'metadataKey' when calling PersonsApi->UpsertPersonAccessMetadata");
            // verify the required parameter 'request' is set
            if (request == null)
                throw new ApiException(400, "Missing required parameter 'request' when calling PersonsApi->UpsertPersonAccessMetadata");

            var localVarPath = "./api/persons/{idTypeScope}/{idTypeCode}/{code}/metadata/{metadataKey}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "text/plain",
                "application/json",
                "text/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (idTypeScope != null) localVarPathParams.Add("idTypeScope", this.Configuration.ApiClient.ParameterToString(idTypeScope)); // path parameter
            if (idTypeCode != null) localVarPathParams.Add("idTypeCode", this.Configuration.ApiClient.ParameterToString(idTypeCode)); // path parameter
            if (code != null) localVarPathParams.Add("code", this.Configuration.ApiClient.ParameterToString(code)); // path parameter
            if (metadataKey != null) localVarPathParams.Add("metadataKey", this.Configuration.ApiClient.ParameterToString(metadataKey)); // path parameter
            if (effectiveAt != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "effectiveAt", effectiveAt)); // query parameter
            if (request != null && request.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(request); // http body (model) parameter
            }
            else
            {
                localVarPostBody = request; // byte array
            }

            // authentication (oauth2) required
            // oauth required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpsertPersonAccessMetadata", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<ResourceListOfAccessMetadataValueOf>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => string.Join(",", x.Value)),
                (ResourceListOfAccessMetadataValueOf) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(ResourceListOfAccessMetadataValueOf)));
        }

    }
}
