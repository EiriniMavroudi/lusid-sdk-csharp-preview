/* 
 * LUSID API
 *
 * # Introduction  This page documents the [LUSID APIs](https://www.lusid.com/api/swagger), which allows authorised clients to query and update their data within the LUSID platform.  SDKs to interact with the LUSID APIs are available in the following languages and frameworks:  * [C#](https://github.com/finbourne/lusid-sdk-csharp) * [Java](https://github.com/finbourne/lusid-sdk-java) * [JavaScript](https://github.com/finbourne/lusid-sdk-js) * [Python](https://github.com/finbourne/lusid-sdk-python) * [Angular](https://github.com/finbourne/lusid-sdk-angular)  The LUSID platform is made up of a number of sub-applications. You can find the API / swagger documentation by following the links in the table below.   | Application | Description | API / Swagger Documentation | | - -- -- | - -- -- | - -- - | | LUSID | Open, API-first, developer-friendly investment data platform. | [Swagger](https://www.lusid.com/api/swagger/index.html) | | Web app | User-facing front end for LUSID. | [Swagger](https://www.lusid.com/app/swagger/index.html) | | Scheduler | Automated job scheduler. | [Swagger](https://www.lusid.com/scheduler2/swagger/index.html) | | Insights |Monitoring and troubleshooting service. | [Swagger](https://www.lusid.com/insights/swagger/index.html) | | Identity | Identity management for LUSID (in conjuction with Access) | [Swagger](https://www.lusid.com/identity/swagger/index.html) | | Access | Access control for LUSID (in conjunction with Identity) | [Swagger](https://www.lusid.com/access/swagger/index.html) | | Drive | Secure file repository and manager for collaboration. | [Swagger](https://www.lusid.com/drive/swagger/index.html) | | Luminesce | Data virtualisation service (query data from multiple providers, including LUSID) | [Swagger](https://www.lusid.com/honeycomb/swagger/index.html) | | Notification | Notification service. | [Swagger](https://www.lusid.com/notifications/swagger/index.html) | | Configuration | File store for secrets and other sensitive information. | [Swagger](https://www.lusid.com/configuration/swagger/index.html) | 
 *
 * The version of the OpenAPI document: 0.11.3417
 * Contact: info@finbourne.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using RestSharp.Portable;
using Lusid.Sdk.Client;
using Lusid.Sdk.Model;

namespace Lusid.Sdk.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IPersonsApi : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// [EXPERIMENTAL] Delete person
        /// </summary>
        /// <remarks>
        /// Delete a person. Deletion will be valid from the person&#39;s creation datetime.  This means that the person will no longer exist at any effective datetime from the asAt datetime of deletion.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">The scope of the person identifier type.</param>
        /// <param name="idTypeCode">The code of the person identifier type.</param>
        /// <param name="code">Code of the person under specified identifier type scope and code. This together with defined              identifier type uniquely identifies the person to delete.</param>
        /// <returns>DeletedEntityResponse</returns>
        DeletedEntityResponse DeletePerson (string idTypeScope, string idTypeCode, string code);

        /// <summary>
        /// [EXPERIMENTAL] Delete person
        /// </summary>
        /// <remarks>
        /// Delete a person. Deletion will be valid from the person&#39;s creation datetime.  This means that the person will no longer exist at any effective datetime from the asAt datetime of deletion.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">The scope of the person identifier type.</param>
        /// <param name="idTypeCode">The code of the person identifier type.</param>
        /// <param name="code">Code of the person under specified identifier type scope and code. This together with defined              identifier type uniquely identifies the person to delete.</param>
        /// <returns>ApiResponse of DeletedEntityResponse</returns>
        ApiResponse<DeletedEntityResponse> DeletePersonWithHttpInfo (string idTypeScope, string idTypeCode, string code);
        /// <summary>
        /// [EXPERIMENTAL] Delete a Person Access Metadata entry
        /// </summary>
        /// <remarks>
        /// Deletes the Person Access Metadata entry that exactly matches the provided identifier parts.    It is important to always check to verify success (or failure).
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier.</param>
        /// <param name="idTypeCode">Code of the person identifier.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code.</param>
        /// <param name="metadataKey">Key of the metadata entry to retrieve</param>
        /// <param name="effectiveAt">The effective date to delete at, if this is not supplied, it will delete all data found (optional)</param>
        /// <returns>DeletedEntityResponse</returns>
        DeletedEntityResponse DeletePersonAccessMetadata (string idTypeScope, string idTypeCode, string code, string metadataKey, DateTimeOrCutLabel effectiveAt = null);

        /// <summary>
        /// [EXPERIMENTAL] Delete a Person Access Metadata entry
        /// </summary>
        /// <remarks>
        /// Deletes the Person Access Metadata entry that exactly matches the provided identifier parts.    It is important to always check to verify success (or failure).
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier.</param>
        /// <param name="idTypeCode">Code of the person identifier.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code.</param>
        /// <param name="metadataKey">Key of the metadata entry to retrieve</param>
        /// <param name="effectiveAt">The effective date to delete at, if this is not supplied, it will delete all data found (optional)</param>
        /// <returns>ApiResponse of DeletedEntityResponse</returns>
        ApiResponse<DeletedEntityResponse> DeletePersonAccessMetadataWithHttpInfo (string idTypeScope, string idTypeCode, string code, string metadataKey, DateTimeOrCutLabel effectiveAt = null);
        /// <summary>
        /// [EXPERIMENTAL] Delete Person Identifiers
        /// </summary>
        /// <remarks>
        /// Delete identifiers that belong to the given property keys of the person.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier type.</param>
        /// <param name="idTypeCode">Code of the person identifier type.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code. This together with stated identifier type uniquely              identifies the person.</param>
        /// <param name="propertyKeys">The property keys of the identifiers to delete. These take the format              {domain}/{scope}/{code} e.g. \&quot;Person/CompanyDetails/Role\&quot;. Each property must be from the \&quot;Person\&quot; domain. Identifiers or identifiers not specified in request will not be changed.</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to delete the identifiers. Defaults to the current LUSID system datetime if not specified.              Must not include an effective datetime of identifiers are perpetual. (optional)</param>
        /// <returns>DeletedEntityResponse</returns>
        DeletedEntityResponse DeletePersonIdentifiers (string idTypeScope, string idTypeCode, string code, List<string> propertyKeys, DateTimeOrCutLabel effectiveAt = null);

        /// <summary>
        /// [EXPERIMENTAL] Delete Person Identifiers
        /// </summary>
        /// <remarks>
        /// Delete identifiers that belong to the given property keys of the person.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier type.</param>
        /// <param name="idTypeCode">Code of the person identifier type.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code. This together with stated identifier type uniquely              identifies the person.</param>
        /// <param name="propertyKeys">The property keys of the identifiers to delete. These take the format              {domain}/{scope}/{code} e.g. \&quot;Person/CompanyDetails/Role\&quot;. Each property must be from the \&quot;Person\&quot; domain. Identifiers or identifiers not specified in request will not be changed.</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to delete the identifiers. Defaults to the current LUSID system datetime if not specified.              Must not include an effective datetime of identifiers are perpetual. (optional)</param>
        /// <returns>ApiResponse of DeletedEntityResponse</returns>
        ApiResponse<DeletedEntityResponse> DeletePersonIdentifiersWithHttpInfo (string idTypeScope, string idTypeCode, string code, List<string> propertyKeys, DateTimeOrCutLabel effectiveAt = null);
        /// <summary>
        /// [EXPERIMENTAL] Delete Person Properties
        /// </summary>
        /// <remarks>
        /// Delete all properties that belong to the given property keys of the person.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier type.</param>
        /// <param name="idTypeCode">Code of the person identifier type.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code. This together with stated identifier type uniquely              identifies the person.</param>
        /// <param name="propertyKeys">The property keys of the person&#39;s properties to delete. These take the format              {domain}/{scope}/{code} e.g. \&quot;Person/CompanyDetails/Role\&quot;. Each property must be from the \&quot;Person\&quot; domain. Properties or identifiers not specified in request will not be changed.</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to delete the properties. Defaults to the current LUSID system datetime if not specified.              Must not include an effective datetime of properties are perpetual. (optional)</param>
        /// <returns>DeletedEntityResponse</returns>
        DeletedEntityResponse DeletePersonProperties (string idTypeScope, string idTypeCode, string code, List<string> propertyKeys, DateTimeOrCutLabel effectiveAt = null);

        /// <summary>
        /// [EXPERIMENTAL] Delete Person Properties
        /// </summary>
        /// <remarks>
        /// Delete all properties that belong to the given property keys of the person.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier type.</param>
        /// <param name="idTypeCode">Code of the person identifier type.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code. This together with stated identifier type uniquely              identifies the person.</param>
        /// <param name="propertyKeys">The property keys of the person&#39;s properties to delete. These take the format              {domain}/{scope}/{code} e.g. \&quot;Person/CompanyDetails/Role\&quot;. Each property must be from the \&quot;Person\&quot; domain. Properties or identifiers not specified in request will not be changed.</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to delete the properties. Defaults to the current LUSID system datetime if not specified.              Must not include an effective datetime of properties are perpetual. (optional)</param>
        /// <returns>ApiResponse of DeletedEntityResponse</returns>
        ApiResponse<DeletedEntityResponse> DeletePersonPropertiesWithHttpInfo (string idTypeScope, string idTypeCode, string code, List<string> propertyKeys, DateTimeOrCutLabel effectiveAt = null);
        /// <summary>
        /// [EXPERIMENTAL] Get Access Metadata rules for a Person
        /// </summary>
        /// <remarks>
        /// Pass the Scope and Code of the Person identifier along with the person code parameter to retrieve the associated Access Metadata
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier.</param>
        /// <param name="idTypeCode">Code of the person identifier.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code.</param>
        /// <param name="effectiveAt">The effectiveAt datetime at which to retrieve the Access Metadata (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the Access Metadata (optional)</param>
        /// <returns>Dictionary&lt;string, List&lt;AccessMetadataValue&gt;&gt;</returns>
        Dictionary<string, List<AccessMetadataValue>> GetAllPersonAccessMetadata (string idTypeScope, string idTypeCode, string code, DateTimeOrCutLabel effectiveAt = null, DateTimeOffset? asAt = null);

        /// <summary>
        /// [EXPERIMENTAL] Get Access Metadata rules for a Person
        /// </summary>
        /// <remarks>
        /// Pass the Scope and Code of the Person identifier along with the person code parameter to retrieve the associated Access Metadata
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier.</param>
        /// <param name="idTypeCode">Code of the person identifier.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code.</param>
        /// <param name="effectiveAt">The effectiveAt datetime at which to retrieve the Access Metadata (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the Access Metadata (optional)</param>
        /// <returns>ApiResponse of Dictionary&lt;string, List&lt;AccessMetadataValue&gt;&gt;</returns>
        ApiResponse<Dictionary<string, List<AccessMetadataValue>>> GetAllPersonAccessMetadataWithHttpInfo (string idTypeScope, string idTypeCode, string code, DateTimeOrCutLabel effectiveAt = null, DateTimeOffset? asAt = null);
        /// <summary>
        /// [EXPERIMENTAL] Get Person
        /// </summary>
        /// <remarks>
        /// Retrieve the definition of a person.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier type.</param>
        /// <param name="idTypeCode">Code of the person identifier type.</param>
        /// <param name="code">Code of the person under specified scope and code. This together with stated identifier type uniquely              identifies the person.</param>
        /// <param name="propertyKeys">A list of property keys from the \&quot;Person\&quot; domain to decorate onto each person.              These take the format {domain}/{scope}/{code} e.g. \&quot;Person/ContactDetails/Address\&quot;. Defaults to include all properties if not specified. (optional)</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to retrieve the person. Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the person. Defaults to return the latest version of the person if not specified. (optional)</param>
        /// <returns>Person</returns>
        Person GetPerson (string idTypeScope, string idTypeCode, string code, List<string> propertyKeys = null, DateTimeOrCutLabel effectiveAt = null, DateTimeOffset? asAt = null);

        /// <summary>
        /// [EXPERIMENTAL] Get Person
        /// </summary>
        /// <remarks>
        /// Retrieve the definition of a person.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier type.</param>
        /// <param name="idTypeCode">Code of the person identifier type.</param>
        /// <param name="code">Code of the person under specified scope and code. This together with stated identifier type uniquely              identifies the person.</param>
        /// <param name="propertyKeys">A list of property keys from the \&quot;Person\&quot; domain to decorate onto each person.              These take the format {domain}/{scope}/{code} e.g. \&quot;Person/ContactDetails/Address\&quot;. Defaults to include all properties if not specified. (optional)</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to retrieve the person. Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the person. Defaults to return the latest version of the person if not specified. (optional)</param>
        /// <returns>ApiResponse of Person</returns>
        ApiResponse<Person> GetPersonWithHttpInfo (string idTypeScope, string idTypeCode, string code, List<string> propertyKeys = null, DateTimeOrCutLabel effectiveAt = null, DateTimeOffset? asAt = null);
        /// <summary>
        /// [EXPERIMENTAL] Get an entry identified by a metadataKey in the Access Metadata of a Person
        /// </summary>
        /// <remarks>
        /// Get a specific Person Access Metadata by specifying the corresponding identifier parts and Person code                No matching will be performed through this endpoint. To retrieve an entry, it is necessary to specify, exactly, the identifier of the entry
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier.</param>
        /// <param name="idTypeCode">Code of the person identifier.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code.</param>
        /// <param name="metadataKey">Key of the metadata entry to retrieve</param>
        /// <param name="effectiveAt">The effectiveAt datetime at which to retrieve the Access Metadata (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the Access Metadata (optional)</param>
        /// <returns>ICollection&lt;AccessMetadataValue&gt;</returns>
        ICollection<AccessMetadataValue> GetPersonAccessMetadataByKey (string idTypeScope, string idTypeCode, string code, string metadataKey, DateTimeOrCutLabel effectiveAt = null, DateTimeOffset? asAt = null);

        /// <summary>
        /// [EXPERIMENTAL] Get an entry identified by a metadataKey in the Access Metadata of a Person
        /// </summary>
        /// <remarks>
        /// Get a specific Person Access Metadata by specifying the corresponding identifier parts and Person code                No matching will be performed through this endpoint. To retrieve an entry, it is necessary to specify, exactly, the identifier of the entry
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier.</param>
        /// <param name="idTypeCode">Code of the person identifier.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code.</param>
        /// <param name="metadataKey">Key of the metadata entry to retrieve</param>
        /// <param name="effectiveAt">The effectiveAt datetime at which to retrieve the Access Metadata (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the Access Metadata (optional)</param>
        /// <returns>ApiResponse of ICollection&lt;AccessMetadataValue&gt;</returns>
        ApiResponse<ICollection<AccessMetadataValue>> GetPersonAccessMetadataByKeyWithHttpInfo (string idTypeScope, string idTypeCode, string code, string metadataKey, DateTimeOrCutLabel effectiveAt = null, DateTimeOffset? asAt = null);
        /// <summary>
        /// [EXPERIMENTAL] Get Person Property Time Series
        /// </summary>
        /// <remarks>
        /// List the complete time series of a person property.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier type.</param>
        /// <param name="idTypeCode">Code of the person identifier type.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code. This together with stated identifier type uniquely identifies the person.</param>
        /// <param name="propertyKey">The property key of the property that will have its history shown. These must be in the format {domain}/{scope}/{code} e.g. \&quot;Person/CompanyDetails/Role\&quot;.              Each property must be from the \&quot;Person\&quot; domain. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to list the person&#39;s property history. Defaults to return the current datetime if not supplied. (optional)</param>
        /// <param name="filter">Expression to filter the result set. Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing properties from a previous call to get property time series.              This value is returned from the previous call. If a pagination token is provided the filter and asAt fields              must not have changed since the original request. (optional)</param>
        /// <param name="limit">When paginating, limit the number of returned results to this many. (optional)</param>
        /// <returns>ResourceListOfPropertyInterval</returns>
        ResourceListOfPropertyInterval GetPersonPropertyTimeSeries (string idTypeScope, string idTypeCode, string code, string propertyKey = null, DateTimeOffset? asAt = null, string filter = null, string page = null, int? limit = null);

        /// <summary>
        /// [EXPERIMENTAL] Get Person Property Time Series
        /// </summary>
        /// <remarks>
        /// List the complete time series of a person property.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier type.</param>
        /// <param name="idTypeCode">Code of the person identifier type.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code. This together with stated identifier type uniquely identifies the person.</param>
        /// <param name="propertyKey">The property key of the property that will have its history shown. These must be in the format {domain}/{scope}/{code} e.g. \&quot;Person/CompanyDetails/Role\&quot;.              Each property must be from the \&quot;Person\&quot; domain. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to list the person&#39;s property history. Defaults to return the current datetime if not supplied. (optional)</param>
        /// <param name="filter">Expression to filter the result set. Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing properties from a previous call to get property time series.              This value is returned from the previous call. If a pagination token is provided the filter and asAt fields              must not have changed since the original request. (optional)</param>
        /// <param name="limit">When paginating, limit the number of returned results to this many. (optional)</param>
        /// <returns>ApiResponse of ResourceListOfPropertyInterval</returns>
        ApiResponse<ResourceListOfPropertyInterval> GetPersonPropertyTimeSeriesWithHttpInfo (string idTypeScope, string idTypeCode, string code, string propertyKey = null, DateTimeOffset? asAt = null, string filter = null, string page = null, int? limit = null);
        /// <summary>
        /// [EXPERIMENTAL] Get Relations for Person
        /// </summary>
        /// <remarks>
        /// Get relations for the specified person.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier type.</param>
        /// <param name="idTypeCode">Code of the person identifier type.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code. This together with stated identifier type uniquely              identifies the person.</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to get relations. Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the person&#39;s relations. Defaults to return the latest LUSID AsAt time if not specified. (optional)</param>
        /// <param name="filter">Expression to filter the relations. Users should provide null or empty string for this field until further notice. (optional)</param>
        /// <param name="identifierTypes">Identifiers types (as property keys) used for referencing Persons or Legal Entities. These take the format              {domain}/{scope}/{code} e.g. \&quot;Person/CompanyDetails/Role\&quot;. They must be from the \&quot;Person\&quot; or \&quot;LegalEntity\&quot; domain.              Only identifier types stated will be used to look up relevant entities in relations. If not applicable, provide an empty array. (optional)</param>
        /// <returns>ResourceListOfRelation</returns>
        ResourceListOfRelation GetPersonRelations (string idTypeScope, string idTypeCode, string code, DateTimeOrCutLabel effectiveAt = null, DateTimeOffset? asAt = null, string filter = null, List<string> identifierTypes = null);

        /// <summary>
        /// [EXPERIMENTAL] Get Relations for Person
        /// </summary>
        /// <remarks>
        /// Get relations for the specified person.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier type.</param>
        /// <param name="idTypeCode">Code of the person identifier type.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code. This together with stated identifier type uniquely              identifies the person.</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to get relations. Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the person&#39;s relations. Defaults to return the latest LUSID AsAt time if not specified. (optional)</param>
        /// <param name="filter">Expression to filter the relations. Users should provide null or empty string for this field until further notice. (optional)</param>
        /// <param name="identifierTypes">Identifiers types (as property keys) used for referencing Persons or Legal Entities. These take the format              {domain}/{scope}/{code} e.g. \&quot;Person/CompanyDetails/Role\&quot;. They must be from the \&quot;Person\&quot; or \&quot;LegalEntity\&quot; domain.              Only identifier types stated will be used to look up relevant entities in relations. If not applicable, provide an empty array. (optional)</param>
        /// <returns>ApiResponse of ResourceListOfRelation</returns>
        ApiResponse<ResourceListOfRelation> GetPersonRelationsWithHttpInfo (string idTypeScope, string idTypeCode, string code, DateTimeOrCutLabel effectiveAt = null, DateTimeOffset? asAt = null, string filter = null, List<string> identifierTypes = null);
        /// <summary>
        /// [EXPERIMENTAL] Get Relationships for Person
        /// </summary>
        /// <remarks>
        /// Get relationships for the specified person.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person&#39;s identifier type.</param>
        /// <param name="idTypeCode">Code of the person&#39;s identifier type.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code. This together with stated identifier type uniquely              identifies the person.</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to get relationships. Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve relationships. Defaults to return the latest LUSID AsAt time if not specified. (optional)</param>
        /// <param name="filter">Expression to filter relationships. Users should provide null or empty string for this field until further notice. (optional)</param>
        /// <param name="identifierTypes">Identifiers types (as property keys) used for referencing Persons or Legal Entities. These take the format              {domain}/{scope}/{code} e.g. \&quot;Person/CompanyDetails/Role\&quot;. They must be from the \&quot;Person\&quot; or \&quot;LegalEntity\&quot; domain.              Only identifier types stated will be used to look up relevant entities in relationships. If not applicable, provide an empty array. (optional)</param>
        /// <returns>ResourceListOfRelationship</returns>
        ResourceListOfRelationship GetPersonRelationships (string idTypeScope, string idTypeCode, string code, DateTimeOrCutLabel effectiveAt = null, DateTimeOffset? asAt = null, string filter = null, List<string> identifierTypes = null);

        /// <summary>
        /// [EXPERIMENTAL] Get Relationships for Person
        /// </summary>
        /// <remarks>
        /// Get relationships for the specified person.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person&#39;s identifier type.</param>
        /// <param name="idTypeCode">Code of the person&#39;s identifier type.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code. This together with stated identifier type uniquely              identifies the person.</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to get relationships. Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve relationships. Defaults to return the latest LUSID AsAt time if not specified. (optional)</param>
        /// <param name="filter">Expression to filter relationships. Users should provide null or empty string for this field until further notice. (optional)</param>
        /// <param name="identifierTypes">Identifiers types (as property keys) used for referencing Persons or Legal Entities. These take the format              {domain}/{scope}/{code} e.g. \&quot;Person/CompanyDetails/Role\&quot;. They must be from the \&quot;Person\&quot; or \&quot;LegalEntity\&quot; domain.              Only identifier types stated will be used to look up relevant entities in relationships. If not applicable, provide an empty array. (optional)</param>
        /// <returns>ApiResponse of ResourceListOfRelationship</returns>
        ApiResponse<ResourceListOfRelationship> GetPersonRelationshipsWithHttpInfo (string idTypeScope, string idTypeCode, string code, DateTimeOrCutLabel effectiveAt = null, DateTimeOffset? asAt = null, string filter = null, List<string> identifierTypes = null);
        /// <summary>
        /// [EXPERIMENTAL] List Persons
        /// </summary>
        /// <remarks>
        /// List persons which have identifiers of a specific identifier type&#39;s scope and code, and satisfies filter criteria.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier type.</param>
        /// <param name="idTypeCode">Code of the person identifier type.</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to list the people. Defaults to the current LUSID              system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to list the people. Defaults to return the latest version              of each people if not specified. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing portfolios from a previous call to list portfolios. This  value is returned from the previous call. If a pagination token is provided the filter, effectiveAt  and asAt fields must not have changed since the original request. Also, if set, a start value cannot be provided. (optional)</param>
        /// <param name="start">When paginating, skip this number of results. (optional)</param>
        /// <param name="limit">When paginating, limit the number of returned results to this many. Defaults to 65,535 if not specified. (optional)</param>
        /// <param name="filter">Expression to filter the result set.               For example, to filter on the LUPID, use \&quot;lusidPersonId eq &#39;string&#39;\&quot;              Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid. (optional)</param>
        /// <param name="propertyKeys">A list of property keys from the \&quot;Person\&quot; domain to decorate onto each person.              These take the format {domain}/{scope}/{code} e.g. \&quot;Person/ContactDetails/Address\&quot;. (optional)</param>
        /// <returns>PagedResourceListOfPerson</returns>
        PagedResourceListOfPerson ListPersons (string idTypeScope, string idTypeCode, DateTimeOrCutLabel effectiveAt = null, DateTimeOffset? asAt = null, string page = null, int? start = null, int? limit = null, string filter = null, List<string> propertyKeys = null);

        /// <summary>
        /// [EXPERIMENTAL] List Persons
        /// </summary>
        /// <remarks>
        /// List persons which have identifiers of a specific identifier type&#39;s scope and code, and satisfies filter criteria.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier type.</param>
        /// <param name="idTypeCode">Code of the person identifier type.</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to list the people. Defaults to the current LUSID              system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to list the people. Defaults to return the latest version              of each people if not specified. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing portfolios from a previous call to list portfolios. This  value is returned from the previous call. If a pagination token is provided the filter, effectiveAt  and asAt fields must not have changed since the original request. Also, if set, a start value cannot be provided. (optional)</param>
        /// <param name="start">When paginating, skip this number of results. (optional)</param>
        /// <param name="limit">When paginating, limit the number of returned results to this many. Defaults to 65,535 if not specified. (optional)</param>
        /// <param name="filter">Expression to filter the result set.               For example, to filter on the LUPID, use \&quot;lusidPersonId eq &#39;string&#39;\&quot;              Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid. (optional)</param>
        /// <param name="propertyKeys">A list of property keys from the \&quot;Person\&quot; domain to decorate onto each person.              These take the format {domain}/{scope}/{code} e.g. \&quot;Person/ContactDetails/Address\&quot;. (optional)</param>
        /// <returns>ApiResponse of PagedResourceListOfPerson</returns>
        ApiResponse<PagedResourceListOfPerson> ListPersonsWithHttpInfo (string idTypeScope, string idTypeCode, DateTimeOrCutLabel effectiveAt = null, DateTimeOffset? asAt = null, string page = null, int? start = null, int? limit = null, string filter = null, List<string> propertyKeys = null);
        /// <summary>
        /// [EXPERIMENTAL] Set Person Identifiers
        /// </summary>
        /// <remarks>
        /// Set identifiers of the person.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier type.</param>
        /// <param name="idTypeCode">Code of the person identifier type.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code. This together with stated identifier type uniquely              identifies the person.</param>
        /// <param name="setPersonIdentifiersRequest">Request containing identifiers to set for the person. Identifiers not specified in request will not be changed.</param>
        /// <returns>Person</returns>
        Person SetPersonIdentifiers (string idTypeScope, string idTypeCode, string code, SetPersonIdentifiersRequest setPersonIdentifiersRequest);

        /// <summary>
        /// [EXPERIMENTAL] Set Person Identifiers
        /// </summary>
        /// <remarks>
        /// Set identifiers of the person.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier type.</param>
        /// <param name="idTypeCode">Code of the person identifier type.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code. This together with stated identifier type uniquely              identifies the person.</param>
        /// <param name="setPersonIdentifiersRequest">Request containing identifiers to set for the person. Identifiers not specified in request will not be changed.</param>
        /// <returns>ApiResponse of Person</returns>
        ApiResponse<Person> SetPersonIdentifiersWithHttpInfo (string idTypeScope, string idTypeCode, string code, SetPersonIdentifiersRequest setPersonIdentifiersRequest);
        /// <summary>
        /// [EXPERIMENTAL] Set Person Properties
        /// </summary>
        /// <remarks>
        /// Set properties of the person.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier type.</param>
        /// <param name="idTypeCode">Code of the person identifier type.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code. This together with stated identifier type uniquely              identifies the person.</param>
        /// <param name="setPersonPropertiesRequest">Request containing properties to set for the person. Properties not specified in request will not be changed.</param>
        /// <returns>Person</returns>
        Person SetPersonProperties (string idTypeScope, string idTypeCode, string code, SetPersonPropertiesRequest setPersonPropertiesRequest);

        /// <summary>
        /// [EXPERIMENTAL] Set Person Properties
        /// </summary>
        /// <remarks>
        /// Set properties of the person.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier type.</param>
        /// <param name="idTypeCode">Code of the person identifier type.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code. This together with stated identifier type uniquely              identifies the person.</param>
        /// <param name="setPersonPropertiesRequest">Request containing properties to set for the person. Properties not specified in request will not be changed.</param>
        /// <returns>ApiResponse of Person</returns>
        ApiResponse<Person> SetPersonPropertiesWithHttpInfo (string idTypeScope, string idTypeCode, string code, SetPersonPropertiesRequest setPersonPropertiesRequest);
        /// <summary>
        /// [EXPERIMENTAL] Upsert Person
        /// </summary>
        /// <remarks>
        /// Create or update a new person under the specified scope.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="upsertPersonRequest">Request to create or update a person.</param>
        /// <returns>Person</returns>
        Person UpsertPerson (UpsertPersonRequest upsertPersonRequest);

        /// <summary>
        /// [EXPERIMENTAL] Upsert Person
        /// </summary>
        /// <remarks>
        /// Create or update a new person under the specified scope.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="upsertPersonRequest">Request to create or update a person.</param>
        /// <returns>ApiResponse of Person</returns>
        ApiResponse<Person> UpsertPersonWithHttpInfo (UpsertPersonRequest upsertPersonRequest);
        /// <summary>
        /// [EXPERIMENTAL] Upsert a Person Access Metadata entry associated with a specific metadataKey. This creates or updates the data in LUSID.
        /// </summary>
        /// <remarks>
        /// Update or insert one Person Access Metadata entry in a single scope. An item will be updated if it already exists  and inserted if it does not.                The response will return the successfully updated or inserted Person Access Metadata rule or failure message if unsuccessful.                It is important to always check to verify success (or failure).                Multiple rules for a metadataKey can exist with different effective at dates, when resources are accessed the rule that is active for the current time will be fetched.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier.</param>
        /// <param name="idTypeCode">Code of the person identifier.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code.</param>
        /// <param name="metadataKey">Key of the metadata entry to retrieve</param>
        /// <param name="upsertPersonAccessMetadataRequest">The Person Access Metadata entry to upsert</param>
        /// <param name="effectiveAt">The effectiveAt datetime at which to upsert the Access Metadata (optional)</param>
        /// <returns>ResourceListOfAccessMetadataValueOf</returns>
        ResourceListOfAccessMetadataValueOf UpsertPersonAccessMetadata (string idTypeScope, string idTypeCode, string code, string metadataKey, UpsertPersonAccessMetadataRequest upsertPersonAccessMetadataRequest, DateTimeOrCutLabel effectiveAt = null);

        /// <summary>
        /// [EXPERIMENTAL] Upsert a Person Access Metadata entry associated with a specific metadataKey. This creates or updates the data in LUSID.
        /// </summary>
        /// <remarks>
        /// Update or insert one Person Access Metadata entry in a single scope. An item will be updated if it already exists  and inserted if it does not.                The response will return the successfully updated or inserted Person Access Metadata rule or failure message if unsuccessful.                It is important to always check to verify success (or failure).                Multiple rules for a metadataKey can exist with different effective at dates, when resources are accessed the rule that is active for the current time will be fetched.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier.</param>
        /// <param name="idTypeCode">Code of the person identifier.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code.</param>
        /// <param name="metadataKey">Key of the metadata entry to retrieve</param>
        /// <param name="upsertPersonAccessMetadataRequest">The Person Access Metadata entry to upsert</param>
        /// <param name="effectiveAt">The effectiveAt datetime at which to upsert the Access Metadata (optional)</param>
        /// <returns>ApiResponse of ResourceListOfAccessMetadataValueOf</returns>
        ApiResponse<ResourceListOfAccessMetadataValueOf> UpsertPersonAccessMetadataWithHttpInfo (string idTypeScope, string idTypeCode, string code, string metadataKey, UpsertPersonAccessMetadataRequest upsertPersonAccessMetadataRequest, DateTimeOrCutLabel effectiveAt = null);
        #endregion Synchronous Operations
        #region Asynchronous Operations
        /// <summary>
        /// [EXPERIMENTAL] Delete person
        /// </summary>
        /// <remarks>
        /// Delete a person. Deletion will be valid from the person&#39;s creation datetime.  This means that the person will no longer exist at any effective datetime from the asAt datetime of deletion.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">The scope of the person identifier type.</param>
        /// <param name="idTypeCode">The code of the person identifier type.</param>
        /// <param name="code">Code of the person under specified identifier type scope and code. This together with defined              identifier type uniquely identifies the person to delete.</param>
        /// <returns>Task of DeletedEntityResponse</returns>
        System.Threading.Tasks.Task<DeletedEntityResponse> DeletePersonAsync (string idTypeScope, string idTypeCode, string code);

        /// <summary>
        /// [EXPERIMENTAL] Delete person
        /// </summary>
        /// <remarks>
        /// Delete a person. Deletion will be valid from the person&#39;s creation datetime.  This means that the person will no longer exist at any effective datetime from the asAt datetime of deletion.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">The scope of the person identifier type.</param>
        /// <param name="idTypeCode">The code of the person identifier type.</param>
        /// <param name="code">Code of the person under specified identifier type scope and code. This together with defined              identifier type uniquely identifies the person to delete.</param>
        /// <returns>Task of ApiResponse (DeletedEntityResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<DeletedEntityResponse>> DeletePersonAsyncWithHttpInfo (string idTypeScope, string idTypeCode, string code);
        /// <summary>
        /// [EXPERIMENTAL] Delete a Person Access Metadata entry
        /// </summary>
        /// <remarks>
        /// Deletes the Person Access Metadata entry that exactly matches the provided identifier parts.    It is important to always check to verify success (or failure).
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier.</param>
        /// <param name="idTypeCode">Code of the person identifier.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code.</param>
        /// <param name="metadataKey">Key of the metadata entry to retrieve</param>
        /// <param name="effectiveAt">The effective date to delete at, if this is not supplied, it will delete all data found (optional)</param>
        /// <returns>Task of DeletedEntityResponse</returns>
        System.Threading.Tasks.Task<DeletedEntityResponse> DeletePersonAccessMetadataAsync (string idTypeScope, string idTypeCode, string code, string metadataKey, DateTimeOrCutLabel effectiveAt = null);

        /// <summary>
        /// [EXPERIMENTAL] Delete a Person Access Metadata entry
        /// </summary>
        /// <remarks>
        /// Deletes the Person Access Metadata entry that exactly matches the provided identifier parts.    It is important to always check to verify success (or failure).
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier.</param>
        /// <param name="idTypeCode">Code of the person identifier.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code.</param>
        /// <param name="metadataKey">Key of the metadata entry to retrieve</param>
        /// <param name="effectiveAt">The effective date to delete at, if this is not supplied, it will delete all data found (optional)</param>
        /// <returns>Task of ApiResponse (DeletedEntityResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<DeletedEntityResponse>> DeletePersonAccessMetadataAsyncWithHttpInfo (string idTypeScope, string idTypeCode, string code, string metadataKey, DateTimeOrCutLabel effectiveAt = null);
        /// <summary>
        /// [EXPERIMENTAL] Delete Person Identifiers
        /// </summary>
        /// <remarks>
        /// Delete identifiers that belong to the given property keys of the person.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier type.</param>
        /// <param name="idTypeCode">Code of the person identifier type.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code. This together with stated identifier type uniquely              identifies the person.</param>
        /// <param name="propertyKeys">The property keys of the identifiers to delete. These take the format              {domain}/{scope}/{code} e.g. \&quot;Person/CompanyDetails/Role\&quot;. Each property must be from the \&quot;Person\&quot; domain. Identifiers or identifiers not specified in request will not be changed.</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to delete the identifiers. Defaults to the current LUSID system datetime if not specified.              Must not include an effective datetime of identifiers are perpetual. (optional)</param>
        /// <returns>Task of DeletedEntityResponse</returns>
        System.Threading.Tasks.Task<DeletedEntityResponse> DeletePersonIdentifiersAsync (string idTypeScope, string idTypeCode, string code, List<string> propertyKeys, DateTimeOrCutLabel effectiveAt = null);

        /// <summary>
        /// [EXPERIMENTAL] Delete Person Identifiers
        /// </summary>
        /// <remarks>
        /// Delete identifiers that belong to the given property keys of the person.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier type.</param>
        /// <param name="idTypeCode">Code of the person identifier type.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code. This together with stated identifier type uniquely              identifies the person.</param>
        /// <param name="propertyKeys">The property keys of the identifiers to delete. These take the format              {domain}/{scope}/{code} e.g. \&quot;Person/CompanyDetails/Role\&quot;. Each property must be from the \&quot;Person\&quot; domain. Identifiers or identifiers not specified in request will not be changed.</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to delete the identifiers. Defaults to the current LUSID system datetime if not specified.              Must not include an effective datetime of identifiers are perpetual. (optional)</param>
        /// <returns>Task of ApiResponse (DeletedEntityResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<DeletedEntityResponse>> DeletePersonIdentifiersAsyncWithHttpInfo (string idTypeScope, string idTypeCode, string code, List<string> propertyKeys, DateTimeOrCutLabel effectiveAt = null);
        /// <summary>
        /// [EXPERIMENTAL] Delete Person Properties
        /// </summary>
        /// <remarks>
        /// Delete all properties that belong to the given property keys of the person.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier type.</param>
        /// <param name="idTypeCode">Code of the person identifier type.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code. This together with stated identifier type uniquely              identifies the person.</param>
        /// <param name="propertyKeys">The property keys of the person&#39;s properties to delete. These take the format              {domain}/{scope}/{code} e.g. \&quot;Person/CompanyDetails/Role\&quot;. Each property must be from the \&quot;Person\&quot; domain. Properties or identifiers not specified in request will not be changed.</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to delete the properties. Defaults to the current LUSID system datetime if not specified.              Must not include an effective datetime of properties are perpetual. (optional)</param>
        /// <returns>Task of DeletedEntityResponse</returns>
        System.Threading.Tasks.Task<DeletedEntityResponse> DeletePersonPropertiesAsync (string idTypeScope, string idTypeCode, string code, List<string> propertyKeys, DateTimeOrCutLabel effectiveAt = null);

        /// <summary>
        /// [EXPERIMENTAL] Delete Person Properties
        /// </summary>
        /// <remarks>
        /// Delete all properties that belong to the given property keys of the person.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier type.</param>
        /// <param name="idTypeCode">Code of the person identifier type.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code. This together with stated identifier type uniquely              identifies the person.</param>
        /// <param name="propertyKeys">The property keys of the person&#39;s properties to delete. These take the format              {domain}/{scope}/{code} e.g. \&quot;Person/CompanyDetails/Role\&quot;. Each property must be from the \&quot;Person\&quot; domain. Properties or identifiers not specified in request will not be changed.</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to delete the properties. Defaults to the current LUSID system datetime if not specified.              Must not include an effective datetime of properties are perpetual. (optional)</param>
        /// <returns>Task of ApiResponse (DeletedEntityResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<DeletedEntityResponse>> DeletePersonPropertiesAsyncWithHttpInfo (string idTypeScope, string idTypeCode, string code, List<string> propertyKeys, DateTimeOrCutLabel effectiveAt = null);
        /// <summary>
        /// [EXPERIMENTAL] Get Access Metadata rules for a Person
        /// </summary>
        /// <remarks>
        /// Pass the Scope and Code of the Person identifier along with the person code parameter to retrieve the associated Access Metadata
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier.</param>
        /// <param name="idTypeCode">Code of the person identifier.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code.</param>
        /// <param name="effectiveAt">The effectiveAt datetime at which to retrieve the Access Metadata (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the Access Metadata (optional)</param>
        /// <returns>Task of Dictionary&lt;string, List&lt;AccessMetadataValue&gt;&gt;</returns>
        System.Threading.Tasks.Task<Dictionary<string, List<AccessMetadataValue>>> GetAllPersonAccessMetadataAsync (string idTypeScope, string idTypeCode, string code, DateTimeOrCutLabel effectiveAt = null, DateTimeOffset? asAt = null);

        /// <summary>
        /// [EXPERIMENTAL] Get Access Metadata rules for a Person
        /// </summary>
        /// <remarks>
        /// Pass the Scope and Code of the Person identifier along with the person code parameter to retrieve the associated Access Metadata
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier.</param>
        /// <param name="idTypeCode">Code of the person identifier.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code.</param>
        /// <param name="effectiveAt">The effectiveAt datetime at which to retrieve the Access Metadata (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the Access Metadata (optional)</param>
        /// <returns>Task of ApiResponse (Dictionary&lt;string, List&lt;AccessMetadataValue&gt;&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<Dictionary<string, List<AccessMetadataValue>>>> GetAllPersonAccessMetadataAsyncWithHttpInfo (string idTypeScope, string idTypeCode, string code, DateTimeOrCutLabel effectiveAt = null, DateTimeOffset? asAt = null);
        /// <summary>
        /// [EXPERIMENTAL] Get Person
        /// </summary>
        /// <remarks>
        /// Retrieve the definition of a person.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier type.</param>
        /// <param name="idTypeCode">Code of the person identifier type.</param>
        /// <param name="code">Code of the person under specified scope and code. This together with stated identifier type uniquely              identifies the person.</param>
        /// <param name="propertyKeys">A list of property keys from the \&quot;Person\&quot; domain to decorate onto each person.              These take the format {domain}/{scope}/{code} e.g. \&quot;Person/ContactDetails/Address\&quot;. Defaults to include all properties if not specified. (optional)</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to retrieve the person. Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the person. Defaults to return the latest version of the person if not specified. (optional)</param>
        /// <returns>Task of Person</returns>
        System.Threading.Tasks.Task<Person> GetPersonAsync (string idTypeScope, string idTypeCode, string code, List<string> propertyKeys = null, DateTimeOrCutLabel effectiveAt = null, DateTimeOffset? asAt = null);

        /// <summary>
        /// [EXPERIMENTAL] Get Person
        /// </summary>
        /// <remarks>
        /// Retrieve the definition of a person.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier type.</param>
        /// <param name="idTypeCode">Code of the person identifier type.</param>
        /// <param name="code">Code of the person under specified scope and code. This together with stated identifier type uniquely              identifies the person.</param>
        /// <param name="propertyKeys">A list of property keys from the \&quot;Person\&quot; domain to decorate onto each person.              These take the format {domain}/{scope}/{code} e.g. \&quot;Person/ContactDetails/Address\&quot;. Defaults to include all properties if not specified. (optional)</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to retrieve the person. Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the person. Defaults to return the latest version of the person if not specified. (optional)</param>
        /// <returns>Task of ApiResponse (Person)</returns>
        System.Threading.Tasks.Task<ApiResponse<Person>> GetPersonAsyncWithHttpInfo (string idTypeScope, string idTypeCode, string code, List<string> propertyKeys = null, DateTimeOrCutLabel effectiveAt = null, DateTimeOffset? asAt = null);
        /// <summary>
        /// [EXPERIMENTAL] Get an entry identified by a metadataKey in the Access Metadata of a Person
        /// </summary>
        /// <remarks>
        /// Get a specific Person Access Metadata by specifying the corresponding identifier parts and Person code                No matching will be performed through this endpoint. To retrieve an entry, it is necessary to specify, exactly, the identifier of the entry
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier.</param>
        /// <param name="idTypeCode">Code of the person identifier.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code.</param>
        /// <param name="metadataKey">Key of the metadata entry to retrieve</param>
        /// <param name="effectiveAt">The effectiveAt datetime at which to retrieve the Access Metadata (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the Access Metadata (optional)</param>
        /// <returns>Task of ICollection&lt;AccessMetadataValue&gt;</returns>
        System.Threading.Tasks.Task<ICollection<AccessMetadataValue>> GetPersonAccessMetadataByKeyAsync (string idTypeScope, string idTypeCode, string code, string metadataKey, DateTimeOrCutLabel effectiveAt = null, DateTimeOffset? asAt = null);

        /// <summary>
        /// [EXPERIMENTAL] Get an entry identified by a metadataKey in the Access Metadata of a Person
        /// </summary>
        /// <remarks>
        /// Get a specific Person Access Metadata by specifying the corresponding identifier parts and Person code                No matching will be performed through this endpoint. To retrieve an entry, it is necessary to specify, exactly, the identifier of the entry
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier.</param>
        /// <param name="idTypeCode">Code of the person identifier.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code.</param>
        /// <param name="metadataKey">Key of the metadata entry to retrieve</param>
        /// <param name="effectiveAt">The effectiveAt datetime at which to retrieve the Access Metadata (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the Access Metadata (optional)</param>
        /// <returns>Task of ApiResponse (ICollection&lt;AccessMetadataValue&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<ICollection<AccessMetadataValue>>> GetPersonAccessMetadataByKeyAsyncWithHttpInfo (string idTypeScope, string idTypeCode, string code, string metadataKey, DateTimeOrCutLabel effectiveAt = null, DateTimeOffset? asAt = null);
        /// <summary>
        /// [EXPERIMENTAL] Get Person Property Time Series
        /// </summary>
        /// <remarks>
        /// List the complete time series of a person property.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier type.</param>
        /// <param name="idTypeCode">Code of the person identifier type.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code. This together with stated identifier type uniquely identifies the person.</param>
        /// <param name="propertyKey">The property key of the property that will have its history shown. These must be in the format {domain}/{scope}/{code} e.g. \&quot;Person/CompanyDetails/Role\&quot;.              Each property must be from the \&quot;Person\&quot; domain. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to list the person&#39;s property history. Defaults to return the current datetime if not supplied. (optional)</param>
        /// <param name="filter">Expression to filter the result set. Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing properties from a previous call to get property time series.              This value is returned from the previous call. If a pagination token is provided the filter and asAt fields              must not have changed since the original request. (optional)</param>
        /// <param name="limit">When paginating, limit the number of returned results to this many. (optional)</param>
        /// <returns>Task of ResourceListOfPropertyInterval</returns>
        System.Threading.Tasks.Task<ResourceListOfPropertyInterval> GetPersonPropertyTimeSeriesAsync (string idTypeScope, string idTypeCode, string code, string propertyKey = null, DateTimeOffset? asAt = null, string filter = null, string page = null, int? limit = null);

        /// <summary>
        /// [EXPERIMENTAL] Get Person Property Time Series
        /// </summary>
        /// <remarks>
        /// List the complete time series of a person property.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier type.</param>
        /// <param name="idTypeCode">Code of the person identifier type.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code. This together with stated identifier type uniquely identifies the person.</param>
        /// <param name="propertyKey">The property key of the property that will have its history shown. These must be in the format {domain}/{scope}/{code} e.g. \&quot;Person/CompanyDetails/Role\&quot;.              Each property must be from the \&quot;Person\&quot; domain. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to list the person&#39;s property history. Defaults to return the current datetime if not supplied. (optional)</param>
        /// <param name="filter">Expression to filter the result set. Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing properties from a previous call to get property time series.              This value is returned from the previous call. If a pagination token is provided the filter and asAt fields              must not have changed since the original request. (optional)</param>
        /// <param name="limit">When paginating, limit the number of returned results to this many. (optional)</param>
        /// <returns>Task of ApiResponse (ResourceListOfPropertyInterval)</returns>
        System.Threading.Tasks.Task<ApiResponse<ResourceListOfPropertyInterval>> GetPersonPropertyTimeSeriesAsyncWithHttpInfo (string idTypeScope, string idTypeCode, string code, string propertyKey = null, DateTimeOffset? asAt = null, string filter = null, string page = null, int? limit = null);
        /// <summary>
        /// [EXPERIMENTAL] Get Relations for Person
        /// </summary>
        /// <remarks>
        /// Get relations for the specified person.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier type.</param>
        /// <param name="idTypeCode">Code of the person identifier type.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code. This together with stated identifier type uniquely              identifies the person.</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to get relations. Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the person&#39;s relations. Defaults to return the latest LUSID AsAt time if not specified. (optional)</param>
        /// <param name="filter">Expression to filter the relations. Users should provide null or empty string for this field until further notice. (optional)</param>
        /// <param name="identifierTypes">Identifiers types (as property keys) used for referencing Persons or Legal Entities. These take the format              {domain}/{scope}/{code} e.g. \&quot;Person/CompanyDetails/Role\&quot;. They must be from the \&quot;Person\&quot; or \&quot;LegalEntity\&quot; domain.              Only identifier types stated will be used to look up relevant entities in relations. If not applicable, provide an empty array. (optional)</param>
        /// <returns>Task of ResourceListOfRelation</returns>
        System.Threading.Tasks.Task<ResourceListOfRelation> GetPersonRelationsAsync (string idTypeScope, string idTypeCode, string code, DateTimeOrCutLabel effectiveAt = null, DateTimeOffset? asAt = null, string filter = null, List<string> identifierTypes = null);

        /// <summary>
        /// [EXPERIMENTAL] Get Relations for Person
        /// </summary>
        /// <remarks>
        /// Get relations for the specified person.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier type.</param>
        /// <param name="idTypeCode">Code of the person identifier type.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code. This together with stated identifier type uniquely              identifies the person.</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to get relations. Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the person&#39;s relations. Defaults to return the latest LUSID AsAt time if not specified. (optional)</param>
        /// <param name="filter">Expression to filter the relations. Users should provide null or empty string for this field until further notice. (optional)</param>
        /// <param name="identifierTypes">Identifiers types (as property keys) used for referencing Persons or Legal Entities. These take the format              {domain}/{scope}/{code} e.g. \&quot;Person/CompanyDetails/Role\&quot;. They must be from the \&quot;Person\&quot; or \&quot;LegalEntity\&quot; domain.              Only identifier types stated will be used to look up relevant entities in relations. If not applicable, provide an empty array. (optional)</param>
        /// <returns>Task of ApiResponse (ResourceListOfRelation)</returns>
        System.Threading.Tasks.Task<ApiResponse<ResourceListOfRelation>> GetPersonRelationsAsyncWithHttpInfo (string idTypeScope, string idTypeCode, string code, DateTimeOrCutLabel effectiveAt = null, DateTimeOffset? asAt = null, string filter = null, List<string> identifierTypes = null);
        /// <summary>
        /// [EXPERIMENTAL] Get Relationships for Person
        /// </summary>
        /// <remarks>
        /// Get relationships for the specified person.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person&#39;s identifier type.</param>
        /// <param name="idTypeCode">Code of the person&#39;s identifier type.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code. This together with stated identifier type uniquely              identifies the person.</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to get relationships. Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve relationships. Defaults to return the latest LUSID AsAt time if not specified. (optional)</param>
        /// <param name="filter">Expression to filter relationships. Users should provide null or empty string for this field until further notice. (optional)</param>
        /// <param name="identifierTypes">Identifiers types (as property keys) used for referencing Persons or Legal Entities. These take the format              {domain}/{scope}/{code} e.g. \&quot;Person/CompanyDetails/Role\&quot;. They must be from the \&quot;Person\&quot; or \&quot;LegalEntity\&quot; domain.              Only identifier types stated will be used to look up relevant entities in relationships. If not applicable, provide an empty array. (optional)</param>
        /// <returns>Task of ResourceListOfRelationship</returns>
        System.Threading.Tasks.Task<ResourceListOfRelationship> GetPersonRelationshipsAsync (string idTypeScope, string idTypeCode, string code, DateTimeOrCutLabel effectiveAt = null, DateTimeOffset? asAt = null, string filter = null, List<string> identifierTypes = null);

        /// <summary>
        /// [EXPERIMENTAL] Get Relationships for Person
        /// </summary>
        /// <remarks>
        /// Get relationships for the specified person.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person&#39;s identifier type.</param>
        /// <param name="idTypeCode">Code of the person&#39;s identifier type.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code. This together with stated identifier type uniquely              identifies the person.</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to get relationships. Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve relationships. Defaults to return the latest LUSID AsAt time if not specified. (optional)</param>
        /// <param name="filter">Expression to filter relationships. Users should provide null or empty string for this field until further notice. (optional)</param>
        /// <param name="identifierTypes">Identifiers types (as property keys) used for referencing Persons or Legal Entities. These take the format              {domain}/{scope}/{code} e.g. \&quot;Person/CompanyDetails/Role\&quot;. They must be from the \&quot;Person\&quot; or \&quot;LegalEntity\&quot; domain.              Only identifier types stated will be used to look up relevant entities in relationships. If not applicable, provide an empty array. (optional)</param>
        /// <returns>Task of ApiResponse (ResourceListOfRelationship)</returns>
        System.Threading.Tasks.Task<ApiResponse<ResourceListOfRelationship>> GetPersonRelationshipsAsyncWithHttpInfo (string idTypeScope, string idTypeCode, string code, DateTimeOrCutLabel effectiveAt = null, DateTimeOffset? asAt = null, string filter = null, List<string> identifierTypes = null);
        /// <summary>
        /// [EXPERIMENTAL] List Persons
        /// </summary>
        /// <remarks>
        /// List persons which have identifiers of a specific identifier type&#39;s scope and code, and satisfies filter criteria.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier type.</param>
        /// <param name="idTypeCode">Code of the person identifier type.</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to list the people. Defaults to the current LUSID              system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to list the people. Defaults to return the latest version              of each people if not specified. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing portfolios from a previous call to list portfolios. This  value is returned from the previous call. If a pagination token is provided the filter, effectiveAt  and asAt fields must not have changed since the original request. Also, if set, a start value cannot be provided. (optional)</param>
        /// <param name="start">When paginating, skip this number of results. (optional)</param>
        /// <param name="limit">When paginating, limit the number of returned results to this many. Defaults to 65,535 if not specified. (optional)</param>
        /// <param name="filter">Expression to filter the result set.               For example, to filter on the LUPID, use \&quot;lusidPersonId eq &#39;string&#39;\&quot;              Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid. (optional)</param>
        /// <param name="propertyKeys">A list of property keys from the \&quot;Person\&quot; domain to decorate onto each person.              These take the format {domain}/{scope}/{code} e.g. \&quot;Person/ContactDetails/Address\&quot;. (optional)</param>
        /// <returns>Task of PagedResourceListOfPerson</returns>
        System.Threading.Tasks.Task<PagedResourceListOfPerson> ListPersonsAsync (string idTypeScope, string idTypeCode, DateTimeOrCutLabel effectiveAt = null, DateTimeOffset? asAt = null, string page = null, int? start = null, int? limit = null, string filter = null, List<string> propertyKeys = null);

        /// <summary>
        /// [EXPERIMENTAL] List Persons
        /// </summary>
        /// <remarks>
        /// List persons which have identifiers of a specific identifier type&#39;s scope and code, and satisfies filter criteria.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier type.</param>
        /// <param name="idTypeCode">Code of the person identifier type.</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to list the people. Defaults to the current LUSID              system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to list the people. Defaults to return the latest version              of each people if not specified. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing portfolios from a previous call to list portfolios. This  value is returned from the previous call. If a pagination token is provided the filter, effectiveAt  and asAt fields must not have changed since the original request. Also, if set, a start value cannot be provided. (optional)</param>
        /// <param name="start">When paginating, skip this number of results. (optional)</param>
        /// <param name="limit">When paginating, limit the number of returned results to this many. Defaults to 65,535 if not specified. (optional)</param>
        /// <param name="filter">Expression to filter the result set.               For example, to filter on the LUPID, use \&quot;lusidPersonId eq &#39;string&#39;\&quot;              Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid. (optional)</param>
        /// <param name="propertyKeys">A list of property keys from the \&quot;Person\&quot; domain to decorate onto each person.              These take the format {domain}/{scope}/{code} e.g. \&quot;Person/ContactDetails/Address\&quot;. (optional)</param>
        /// <returns>Task of ApiResponse (PagedResourceListOfPerson)</returns>
        System.Threading.Tasks.Task<ApiResponse<PagedResourceListOfPerson>> ListPersonsAsyncWithHttpInfo (string idTypeScope, string idTypeCode, DateTimeOrCutLabel effectiveAt = null, DateTimeOffset? asAt = null, string page = null, int? start = null, int? limit = null, string filter = null, List<string> propertyKeys = null);
        /// <summary>
        /// [EXPERIMENTAL] Set Person Identifiers
        /// </summary>
        /// <remarks>
        /// Set identifiers of the person.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier type.</param>
        /// <param name="idTypeCode">Code of the person identifier type.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code. This together with stated identifier type uniquely              identifies the person.</param>
        /// <param name="setPersonIdentifiersRequest">Request containing identifiers to set for the person. Identifiers not specified in request will not be changed.</param>
        /// <returns>Task of Person</returns>
        System.Threading.Tasks.Task<Person> SetPersonIdentifiersAsync (string idTypeScope, string idTypeCode, string code, SetPersonIdentifiersRequest setPersonIdentifiersRequest);

        /// <summary>
        /// [EXPERIMENTAL] Set Person Identifiers
        /// </summary>
        /// <remarks>
        /// Set identifiers of the person.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier type.</param>
        /// <param name="idTypeCode">Code of the person identifier type.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code. This together with stated identifier type uniquely              identifies the person.</param>
        /// <param name="setPersonIdentifiersRequest">Request containing identifiers to set for the person. Identifiers not specified in request will not be changed.</param>
        /// <returns>Task of ApiResponse (Person)</returns>
        System.Threading.Tasks.Task<ApiResponse<Person>> SetPersonIdentifiersAsyncWithHttpInfo (string idTypeScope, string idTypeCode, string code, SetPersonIdentifiersRequest setPersonIdentifiersRequest);
        /// <summary>
        /// [EXPERIMENTAL] Set Person Properties
        /// </summary>
        /// <remarks>
        /// Set properties of the person.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier type.</param>
        /// <param name="idTypeCode">Code of the person identifier type.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code. This together with stated identifier type uniquely              identifies the person.</param>
        /// <param name="setPersonPropertiesRequest">Request containing properties to set for the person. Properties not specified in request will not be changed.</param>
        /// <returns>Task of Person</returns>
        System.Threading.Tasks.Task<Person> SetPersonPropertiesAsync (string idTypeScope, string idTypeCode, string code, SetPersonPropertiesRequest setPersonPropertiesRequest);

        /// <summary>
        /// [EXPERIMENTAL] Set Person Properties
        /// </summary>
        /// <remarks>
        /// Set properties of the person.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier type.</param>
        /// <param name="idTypeCode">Code of the person identifier type.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code. This together with stated identifier type uniquely              identifies the person.</param>
        /// <param name="setPersonPropertiesRequest">Request containing properties to set for the person. Properties not specified in request will not be changed.</param>
        /// <returns>Task of ApiResponse (Person)</returns>
        System.Threading.Tasks.Task<ApiResponse<Person>> SetPersonPropertiesAsyncWithHttpInfo (string idTypeScope, string idTypeCode, string code, SetPersonPropertiesRequest setPersonPropertiesRequest);
        /// <summary>
        /// [EXPERIMENTAL] Upsert Person
        /// </summary>
        /// <remarks>
        /// Create or update a new person under the specified scope.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="upsertPersonRequest">Request to create or update a person.</param>
        /// <returns>Task of Person</returns>
        System.Threading.Tasks.Task<Person> UpsertPersonAsync (UpsertPersonRequest upsertPersonRequest);

        /// <summary>
        /// [EXPERIMENTAL] Upsert Person
        /// </summary>
        /// <remarks>
        /// Create or update a new person under the specified scope.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="upsertPersonRequest">Request to create or update a person.</param>
        /// <returns>Task of ApiResponse (Person)</returns>
        System.Threading.Tasks.Task<ApiResponse<Person>> UpsertPersonAsyncWithHttpInfo (UpsertPersonRequest upsertPersonRequest);
        /// <summary>
        /// [EXPERIMENTAL] Upsert a Person Access Metadata entry associated with a specific metadataKey. This creates or updates the data in LUSID.
        /// </summary>
        /// <remarks>
        /// Update or insert one Person Access Metadata entry in a single scope. An item will be updated if it already exists  and inserted if it does not.                The response will return the successfully updated or inserted Person Access Metadata rule or failure message if unsuccessful.                It is important to always check to verify success (or failure).                Multiple rules for a metadataKey can exist with different effective at dates, when resources are accessed the rule that is active for the current time will be fetched.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier.</param>
        /// <param name="idTypeCode">Code of the person identifier.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code.</param>
        /// <param name="metadataKey">Key of the metadata entry to retrieve</param>
        /// <param name="upsertPersonAccessMetadataRequest">The Person Access Metadata entry to upsert</param>
        /// <param name="effectiveAt">The effectiveAt datetime at which to upsert the Access Metadata (optional)</param>
        /// <returns>Task of ResourceListOfAccessMetadataValueOf</returns>
        System.Threading.Tasks.Task<ResourceListOfAccessMetadataValueOf> UpsertPersonAccessMetadataAsync (string idTypeScope, string idTypeCode, string code, string metadataKey, UpsertPersonAccessMetadataRequest upsertPersonAccessMetadataRequest, DateTimeOrCutLabel effectiveAt = null);

        /// <summary>
        /// [EXPERIMENTAL] Upsert a Person Access Metadata entry associated with a specific metadataKey. This creates or updates the data in LUSID.
        /// </summary>
        /// <remarks>
        /// Update or insert one Person Access Metadata entry in a single scope. An item will be updated if it already exists  and inserted if it does not.                The response will return the successfully updated or inserted Person Access Metadata rule or failure message if unsuccessful.                It is important to always check to verify success (or failure).                Multiple rules for a metadataKey can exist with different effective at dates, when resources are accessed the rule that is active for the current time will be fetched.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier.</param>
        /// <param name="idTypeCode">Code of the person identifier.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code.</param>
        /// <param name="metadataKey">Key of the metadata entry to retrieve</param>
        /// <param name="upsertPersonAccessMetadataRequest">The Person Access Metadata entry to upsert</param>
        /// <param name="effectiveAt">The effectiveAt datetime at which to upsert the Access Metadata (optional)</param>
        /// <returns>Task of ApiResponse (ResourceListOfAccessMetadataValueOf)</returns>
        System.Threading.Tasks.Task<ApiResponse<ResourceListOfAccessMetadataValueOf>> UpsertPersonAccessMetadataAsyncWithHttpInfo (string idTypeScope, string idTypeCode, string code, string metadataKey, UpsertPersonAccessMetadataRequest upsertPersonAccessMetadataRequest, DateTimeOrCutLabel effectiveAt = null);
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class PersonsApi : IPersonsApi
    {
        private Lusid.Sdk.Client.ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Initializes a new instance of the <see cref="PersonsApi"/> class.
        /// </summary>
        /// <returns></returns>
        public PersonsApi(String basePath)
        {
            this.Configuration = new Lusid.Sdk.Client.Configuration { BasePath = basePath };

            ExceptionFactory = Lusid.Sdk.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="PersonsApi"/> class
        /// </summary>
        /// <returns></returns>
        public PersonsApi()
        {
            this.Configuration = Lusid.Sdk.Client.Configuration.Default;

            ExceptionFactory = Lusid.Sdk.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="PersonsApi"/> class
        /// using Configuration object
        /// </summary>
        /// <param name="configuration">An instance of Configuration</param>
        /// <returns></returns>
        public PersonsApi(Lusid.Sdk.Client.Configuration configuration = null)
        {
            if (configuration == null) // use the default one in Configuration
                this.Configuration = Lusid.Sdk.Client.Configuration.Default;
            else
                this.Configuration = configuration;

            ExceptionFactory = Lusid.Sdk.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public String GetBasePath()
        {
            return this.Configuration.ApiClient.RestClient.BaseUrl.ToString();
        }

        /// <summary>
        /// Sets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        [Obsolete("SetBasePath is deprecated, please do 'Configuration.ApiClient = new ApiClient(\"http://new-path\")' instead.")]
        public void SetBasePath(String basePath)
        {
            // do nothing
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public Lusid.Sdk.Client.Configuration Configuration {get; set;}

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public Lusid.Sdk.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }

        /// <summary>
        /// Gets the default header.
        /// </summary>
        /// <returns>Dictionary of HTTP header</returns>
        [Obsolete("DefaultHeader is deprecated, please use Configuration.DefaultHeader instead.")]
        public IDictionary<String, String> DefaultHeader()
        {
            return new ReadOnlyDictionary<string, string>(this.Configuration.DefaultHeader);
        }

        /// <summary>
        /// Add default header.
        /// </summary>
        /// <param name="key">Header field name.</param>
        /// <param name="value">Header field value.</param>
        /// <returns></returns>
        [Obsolete("AddDefaultHeader is deprecated, please use Configuration.AddDefaultHeader instead.")]
        public void AddDefaultHeader(string key, string value)
        {
            this.Configuration.AddDefaultHeader(key, value);
        }

        /// <summary>
        /// [EXPERIMENTAL] Delete person Delete a person. Deletion will be valid from the person&#39;s creation datetime.  This means that the person will no longer exist at any effective datetime from the asAt datetime of deletion.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">The scope of the person identifier type.</param>
        /// <param name="idTypeCode">The code of the person identifier type.</param>
        /// <param name="code">Code of the person under specified identifier type scope and code. This together with defined              identifier type uniquely identifies the person to delete.</param>
        /// <returns>DeletedEntityResponse</returns>
        public DeletedEntityResponse DeletePerson (string idTypeScope, string idTypeCode, string code)
        {
             ApiResponse<DeletedEntityResponse> localVarResponse = DeletePersonWithHttpInfo(idTypeScope, idTypeCode, code);
             return localVarResponse.Data;
        }

        /// <summary>
        /// [EXPERIMENTAL] Delete person Delete a person. Deletion will be valid from the person&#39;s creation datetime.  This means that the person will no longer exist at any effective datetime from the asAt datetime of deletion.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">The scope of the person identifier type.</param>
        /// <param name="idTypeCode">The code of the person identifier type.</param>
        /// <param name="code">Code of the person under specified identifier type scope and code. This together with defined              identifier type uniquely identifies the person to delete.</param>
        /// <returns>ApiResponse of DeletedEntityResponse</returns>
        public ApiResponse< DeletedEntityResponse > DeletePersonWithHttpInfo (string idTypeScope, string idTypeCode, string code)
        {
            // verify the required parameter 'idTypeScope' is set
            if (idTypeScope == null)
                throw new ApiException(400, "Missing required parameter 'idTypeScope' when calling PersonsApi->DeletePerson");
            // verify the required parameter 'idTypeCode' is set
            if (idTypeCode == null)
                throw new ApiException(400, "Missing required parameter 'idTypeCode' when calling PersonsApi->DeletePerson");
            // verify the required parameter 'code' is set
            if (code == null)
                throw new ApiException(400, "Missing required parameter 'code' when calling PersonsApi->DeletePerson");

            var localVarPath = "./api/persons/{idTypeScope}/{idTypeCode}/{code}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "text/plain",
                "application/json",
                "text/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (idTypeScope != null) localVarPathParams.Add("idTypeScope", this.Configuration.ApiClient.ParameterToString(idTypeScope)); // path parameter
            if (idTypeCode != null) localVarPathParams.Add("idTypeCode", this.Configuration.ApiClient.ParameterToString(idTypeCode)); // path parameter
            if (code != null) localVarPathParams.Add("code", this.Configuration.ApiClient.ParameterToString(code)); // path parameter

            // authentication (oauth2) required
            // oauth required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            //  set the LUSID header
            localVarHeaderParams["X-LUSID-SDK-Language"] = "C#";
            localVarHeaderParams["X-LUSID-SDK-Version"] = "0.11.3417";

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeletePerson", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<DeletedEntityResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => string.Join(",", x.Value)),
                (DeletedEntityResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(DeletedEntityResponse)));
        }

        /// <summary>
        /// [EXPERIMENTAL] Delete person Delete a person. Deletion will be valid from the person&#39;s creation datetime.  This means that the person will no longer exist at any effective datetime from the asAt datetime of deletion.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">The scope of the person identifier type.</param>
        /// <param name="idTypeCode">The code of the person identifier type.</param>
        /// <param name="code">Code of the person under specified identifier type scope and code. This together with defined              identifier type uniquely identifies the person to delete.</param>
        /// <returns>Task of DeletedEntityResponse</returns>
        public async System.Threading.Tasks.Task<DeletedEntityResponse> DeletePersonAsync (string idTypeScope, string idTypeCode, string code)
        {
             ApiResponse<DeletedEntityResponse> localVarResponse = await DeletePersonAsyncWithHttpInfo(idTypeScope, idTypeCode, code);
             return localVarResponse.Data;

        }

        /// <summary>
        /// [EXPERIMENTAL] Delete person Delete a person. Deletion will be valid from the person&#39;s creation datetime.  This means that the person will no longer exist at any effective datetime from the asAt datetime of deletion.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">The scope of the person identifier type.</param>
        /// <param name="idTypeCode">The code of the person identifier type.</param>
        /// <param name="code">Code of the person under specified identifier type scope and code. This together with defined              identifier type uniquely identifies the person to delete.</param>
        /// <returns>Task of ApiResponse (DeletedEntityResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<DeletedEntityResponse>> DeletePersonAsyncWithHttpInfo (string idTypeScope, string idTypeCode, string code)
        {
            // verify the required parameter 'idTypeScope' is set
            if (idTypeScope == null)
                throw new ApiException(400, "Missing required parameter 'idTypeScope' when calling PersonsApi->DeletePerson");
            // verify the required parameter 'idTypeCode' is set
            if (idTypeCode == null)
                throw new ApiException(400, "Missing required parameter 'idTypeCode' when calling PersonsApi->DeletePerson");
            // verify the required parameter 'code' is set
            if (code == null)
                throw new ApiException(400, "Missing required parameter 'code' when calling PersonsApi->DeletePerson");

            var localVarPath = "./api/persons/{idTypeScope}/{idTypeCode}/{code}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "text/plain",
                "application/json",
                "text/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (idTypeScope != null) localVarPathParams.Add("idTypeScope", this.Configuration.ApiClient.ParameterToString(idTypeScope)); // path parameter
            if (idTypeCode != null) localVarPathParams.Add("idTypeCode", this.Configuration.ApiClient.ParameterToString(idTypeCode)); // path parameter
            if (code != null) localVarPathParams.Add("code", this.Configuration.ApiClient.ParameterToString(code)); // path parameter

            // authentication (oauth2) required
            // oauth required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            //  set the LUSID header
            localVarHeaderParams["X-LUSID-Sdk-Language"] = "C#";
            localVarHeaderParams["X-LUSID-Sdk-Version"] = "0.11.3417";

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeletePerson", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<DeletedEntityResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => string.Join(",", x.Value)),
                (DeletedEntityResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(DeletedEntityResponse)));
        }

        /// <summary>
        /// [EXPERIMENTAL] Delete a Person Access Metadata entry Deletes the Person Access Metadata entry that exactly matches the provided identifier parts.    It is important to always check to verify success (or failure).
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier.</param>
        /// <param name="idTypeCode">Code of the person identifier.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code.</param>
        /// <param name="metadataKey">Key of the metadata entry to retrieve</param>
        /// <param name="effectiveAt">The effective date to delete at, if this is not supplied, it will delete all data found (optional)</param>
        /// <returns>DeletedEntityResponse</returns>
        public DeletedEntityResponse DeletePersonAccessMetadata (string idTypeScope, string idTypeCode, string code, string metadataKey, DateTimeOrCutLabel effectiveAt = null)
        {
             ApiResponse<DeletedEntityResponse> localVarResponse = DeletePersonAccessMetadataWithHttpInfo(idTypeScope, idTypeCode, code, metadataKey, effectiveAt);
             return localVarResponse.Data;
        }

        /// <summary>
        /// [EXPERIMENTAL] Delete a Person Access Metadata entry Deletes the Person Access Metadata entry that exactly matches the provided identifier parts.    It is important to always check to verify success (or failure).
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier.</param>
        /// <param name="idTypeCode">Code of the person identifier.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code.</param>
        /// <param name="metadataKey">Key of the metadata entry to retrieve</param>
        /// <param name="effectiveAt">The effective date to delete at, if this is not supplied, it will delete all data found (optional)</param>
        /// <returns>ApiResponse of DeletedEntityResponse</returns>
        public ApiResponse< DeletedEntityResponse > DeletePersonAccessMetadataWithHttpInfo (string idTypeScope, string idTypeCode, string code, string metadataKey, DateTimeOrCutLabel effectiveAt = null)
        {
            // verify the required parameter 'idTypeScope' is set
            if (idTypeScope == null)
                throw new ApiException(400, "Missing required parameter 'idTypeScope' when calling PersonsApi->DeletePersonAccessMetadata");
            // verify the required parameter 'idTypeCode' is set
            if (idTypeCode == null)
                throw new ApiException(400, "Missing required parameter 'idTypeCode' when calling PersonsApi->DeletePersonAccessMetadata");
            // verify the required parameter 'code' is set
            if (code == null)
                throw new ApiException(400, "Missing required parameter 'code' when calling PersonsApi->DeletePersonAccessMetadata");
            // verify the required parameter 'metadataKey' is set
            if (metadataKey == null)
                throw new ApiException(400, "Missing required parameter 'metadataKey' when calling PersonsApi->DeletePersonAccessMetadata");

            var localVarPath = "./api/persons/{idTypeScope}/{idTypeCode}/{code}/metadata/{metadataKey}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "text/plain",
                "application/json",
                "text/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (idTypeScope != null) localVarPathParams.Add("idTypeScope", this.Configuration.ApiClient.ParameterToString(idTypeScope)); // path parameter
            if (idTypeCode != null) localVarPathParams.Add("idTypeCode", this.Configuration.ApiClient.ParameterToString(idTypeCode)); // path parameter
            if (code != null) localVarPathParams.Add("code", this.Configuration.ApiClient.ParameterToString(code)); // path parameter
            if (metadataKey != null) localVarPathParams.Add("metadataKey", this.Configuration.ApiClient.ParameterToString(metadataKey)); // path parameter
            if (effectiveAt != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "effectiveAt", effectiveAt)); // query parameter

            // authentication (oauth2) required
            // oauth required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            //  set the LUSID header
            localVarHeaderParams["X-LUSID-SDK-Language"] = "C#";
            localVarHeaderParams["X-LUSID-SDK-Version"] = "0.11.3417";

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeletePersonAccessMetadata", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<DeletedEntityResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => string.Join(",", x.Value)),
                (DeletedEntityResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(DeletedEntityResponse)));
        }

        /// <summary>
        /// [EXPERIMENTAL] Delete a Person Access Metadata entry Deletes the Person Access Metadata entry that exactly matches the provided identifier parts.    It is important to always check to verify success (or failure).
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier.</param>
        /// <param name="idTypeCode">Code of the person identifier.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code.</param>
        /// <param name="metadataKey">Key of the metadata entry to retrieve</param>
        /// <param name="effectiveAt">The effective date to delete at, if this is not supplied, it will delete all data found (optional)</param>
        /// <returns>Task of DeletedEntityResponse</returns>
        public async System.Threading.Tasks.Task<DeletedEntityResponse> DeletePersonAccessMetadataAsync (string idTypeScope, string idTypeCode, string code, string metadataKey, DateTimeOrCutLabel effectiveAt = null)
        {
             ApiResponse<DeletedEntityResponse> localVarResponse = await DeletePersonAccessMetadataAsyncWithHttpInfo(idTypeScope, idTypeCode, code, metadataKey, effectiveAt);
             return localVarResponse.Data;

        }

        /// <summary>
        /// [EXPERIMENTAL] Delete a Person Access Metadata entry Deletes the Person Access Metadata entry that exactly matches the provided identifier parts.    It is important to always check to verify success (or failure).
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier.</param>
        /// <param name="idTypeCode">Code of the person identifier.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code.</param>
        /// <param name="metadataKey">Key of the metadata entry to retrieve</param>
        /// <param name="effectiveAt">The effective date to delete at, if this is not supplied, it will delete all data found (optional)</param>
        /// <returns>Task of ApiResponse (DeletedEntityResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<DeletedEntityResponse>> DeletePersonAccessMetadataAsyncWithHttpInfo (string idTypeScope, string idTypeCode, string code, string metadataKey, DateTimeOrCutLabel effectiveAt = null)
        {
            // verify the required parameter 'idTypeScope' is set
            if (idTypeScope == null)
                throw new ApiException(400, "Missing required parameter 'idTypeScope' when calling PersonsApi->DeletePersonAccessMetadata");
            // verify the required parameter 'idTypeCode' is set
            if (idTypeCode == null)
                throw new ApiException(400, "Missing required parameter 'idTypeCode' when calling PersonsApi->DeletePersonAccessMetadata");
            // verify the required parameter 'code' is set
            if (code == null)
                throw new ApiException(400, "Missing required parameter 'code' when calling PersonsApi->DeletePersonAccessMetadata");
            // verify the required parameter 'metadataKey' is set
            if (metadataKey == null)
                throw new ApiException(400, "Missing required parameter 'metadataKey' when calling PersonsApi->DeletePersonAccessMetadata");

            var localVarPath = "./api/persons/{idTypeScope}/{idTypeCode}/{code}/metadata/{metadataKey}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "text/plain",
                "application/json",
                "text/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (idTypeScope != null) localVarPathParams.Add("idTypeScope", this.Configuration.ApiClient.ParameterToString(idTypeScope)); // path parameter
            if (idTypeCode != null) localVarPathParams.Add("idTypeCode", this.Configuration.ApiClient.ParameterToString(idTypeCode)); // path parameter
            if (code != null) localVarPathParams.Add("code", this.Configuration.ApiClient.ParameterToString(code)); // path parameter
            if (metadataKey != null) localVarPathParams.Add("metadataKey", this.Configuration.ApiClient.ParameterToString(metadataKey)); // path parameter
            if (effectiveAt != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "effectiveAt", effectiveAt)); // query parameter

            // authentication (oauth2) required
            // oauth required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            //  set the LUSID header
            localVarHeaderParams["X-LUSID-Sdk-Language"] = "C#";
            localVarHeaderParams["X-LUSID-Sdk-Version"] = "0.11.3417";

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeletePersonAccessMetadata", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<DeletedEntityResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => string.Join(",", x.Value)),
                (DeletedEntityResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(DeletedEntityResponse)));
        }

        /// <summary>
        /// [EXPERIMENTAL] Delete Person Identifiers Delete identifiers that belong to the given property keys of the person.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier type.</param>
        /// <param name="idTypeCode">Code of the person identifier type.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code. This together with stated identifier type uniquely              identifies the person.</param>
        /// <param name="propertyKeys">The property keys of the identifiers to delete. These take the format              {domain}/{scope}/{code} e.g. \&quot;Person/CompanyDetails/Role\&quot;. Each property must be from the \&quot;Person\&quot; domain. Identifiers or identifiers not specified in request will not be changed.</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to delete the identifiers. Defaults to the current LUSID system datetime if not specified.              Must not include an effective datetime of identifiers are perpetual. (optional)</param>
        /// <returns>DeletedEntityResponse</returns>
        public DeletedEntityResponse DeletePersonIdentifiers (string idTypeScope, string idTypeCode, string code, List<string> propertyKeys, DateTimeOrCutLabel effectiveAt = null)
        {
             ApiResponse<DeletedEntityResponse> localVarResponse = DeletePersonIdentifiersWithHttpInfo(idTypeScope, idTypeCode, code, propertyKeys, effectiveAt);
             return localVarResponse.Data;
        }

        /// <summary>
        /// [EXPERIMENTAL] Delete Person Identifiers Delete identifiers that belong to the given property keys of the person.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier type.</param>
        /// <param name="idTypeCode">Code of the person identifier type.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code. This together with stated identifier type uniquely              identifies the person.</param>
        /// <param name="propertyKeys">The property keys of the identifiers to delete. These take the format              {domain}/{scope}/{code} e.g. \&quot;Person/CompanyDetails/Role\&quot;. Each property must be from the \&quot;Person\&quot; domain. Identifiers or identifiers not specified in request will not be changed.</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to delete the identifiers. Defaults to the current LUSID system datetime if not specified.              Must not include an effective datetime of identifiers are perpetual. (optional)</param>
        /// <returns>ApiResponse of DeletedEntityResponse</returns>
        public ApiResponse< DeletedEntityResponse > DeletePersonIdentifiersWithHttpInfo (string idTypeScope, string idTypeCode, string code, List<string> propertyKeys, DateTimeOrCutLabel effectiveAt = null)
        {
            // verify the required parameter 'idTypeScope' is set
            if (idTypeScope == null)
                throw new ApiException(400, "Missing required parameter 'idTypeScope' when calling PersonsApi->DeletePersonIdentifiers");
            // verify the required parameter 'idTypeCode' is set
            if (idTypeCode == null)
                throw new ApiException(400, "Missing required parameter 'idTypeCode' when calling PersonsApi->DeletePersonIdentifiers");
            // verify the required parameter 'code' is set
            if (code == null)
                throw new ApiException(400, "Missing required parameter 'code' when calling PersonsApi->DeletePersonIdentifiers");
            // verify the required parameter 'propertyKeys' is set
            if (propertyKeys == null)
                throw new ApiException(400, "Missing required parameter 'propertyKeys' when calling PersonsApi->DeletePersonIdentifiers");

            var localVarPath = "./api/persons/{idTypeScope}/{idTypeCode}/{code}/identifiers";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "text/plain",
                "application/json",
                "text/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (idTypeScope != null) localVarPathParams.Add("idTypeScope", this.Configuration.ApiClient.ParameterToString(idTypeScope)); // path parameter
            if (idTypeCode != null) localVarPathParams.Add("idTypeCode", this.Configuration.ApiClient.ParameterToString(idTypeCode)); // path parameter
            if (code != null) localVarPathParams.Add("code", this.Configuration.ApiClient.ParameterToString(code)); // path parameter
            if (propertyKeys != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "propertyKeys", propertyKeys)); // query parameter
            if (effectiveAt != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "effectiveAt", effectiveAt)); // query parameter

            // authentication (oauth2) required
            // oauth required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            //  set the LUSID header
            localVarHeaderParams["X-LUSID-SDK-Language"] = "C#";
            localVarHeaderParams["X-LUSID-SDK-Version"] = "0.11.3417";

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeletePersonIdentifiers", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<DeletedEntityResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => string.Join(",", x.Value)),
                (DeletedEntityResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(DeletedEntityResponse)));
        }

        /// <summary>
        /// [EXPERIMENTAL] Delete Person Identifiers Delete identifiers that belong to the given property keys of the person.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier type.</param>
        /// <param name="idTypeCode">Code of the person identifier type.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code. This together with stated identifier type uniquely              identifies the person.</param>
        /// <param name="propertyKeys">The property keys of the identifiers to delete. These take the format              {domain}/{scope}/{code} e.g. \&quot;Person/CompanyDetails/Role\&quot;. Each property must be from the \&quot;Person\&quot; domain. Identifiers or identifiers not specified in request will not be changed.</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to delete the identifiers. Defaults to the current LUSID system datetime if not specified.              Must not include an effective datetime of identifiers are perpetual. (optional)</param>
        /// <returns>Task of DeletedEntityResponse</returns>
        public async System.Threading.Tasks.Task<DeletedEntityResponse> DeletePersonIdentifiersAsync (string idTypeScope, string idTypeCode, string code, List<string> propertyKeys, DateTimeOrCutLabel effectiveAt = null)
        {
             ApiResponse<DeletedEntityResponse> localVarResponse = await DeletePersonIdentifiersAsyncWithHttpInfo(idTypeScope, idTypeCode, code, propertyKeys, effectiveAt);
             return localVarResponse.Data;

        }

        /// <summary>
        /// [EXPERIMENTAL] Delete Person Identifiers Delete identifiers that belong to the given property keys of the person.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier type.</param>
        /// <param name="idTypeCode">Code of the person identifier type.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code. This together with stated identifier type uniquely              identifies the person.</param>
        /// <param name="propertyKeys">The property keys of the identifiers to delete. These take the format              {domain}/{scope}/{code} e.g. \&quot;Person/CompanyDetails/Role\&quot;. Each property must be from the \&quot;Person\&quot; domain. Identifiers or identifiers not specified in request will not be changed.</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to delete the identifiers. Defaults to the current LUSID system datetime if not specified.              Must not include an effective datetime of identifiers are perpetual. (optional)</param>
        /// <returns>Task of ApiResponse (DeletedEntityResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<DeletedEntityResponse>> DeletePersonIdentifiersAsyncWithHttpInfo (string idTypeScope, string idTypeCode, string code, List<string> propertyKeys, DateTimeOrCutLabel effectiveAt = null)
        {
            // verify the required parameter 'idTypeScope' is set
            if (idTypeScope == null)
                throw new ApiException(400, "Missing required parameter 'idTypeScope' when calling PersonsApi->DeletePersonIdentifiers");
            // verify the required parameter 'idTypeCode' is set
            if (idTypeCode == null)
                throw new ApiException(400, "Missing required parameter 'idTypeCode' when calling PersonsApi->DeletePersonIdentifiers");
            // verify the required parameter 'code' is set
            if (code == null)
                throw new ApiException(400, "Missing required parameter 'code' when calling PersonsApi->DeletePersonIdentifiers");
            // verify the required parameter 'propertyKeys' is set
            if (propertyKeys == null)
                throw new ApiException(400, "Missing required parameter 'propertyKeys' when calling PersonsApi->DeletePersonIdentifiers");

            var localVarPath = "./api/persons/{idTypeScope}/{idTypeCode}/{code}/identifiers";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "text/plain",
                "application/json",
                "text/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (idTypeScope != null) localVarPathParams.Add("idTypeScope", this.Configuration.ApiClient.ParameterToString(idTypeScope)); // path parameter
            if (idTypeCode != null) localVarPathParams.Add("idTypeCode", this.Configuration.ApiClient.ParameterToString(idTypeCode)); // path parameter
            if (code != null) localVarPathParams.Add("code", this.Configuration.ApiClient.ParameterToString(code)); // path parameter
            if (propertyKeys != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "propertyKeys", propertyKeys)); // query parameter
            if (effectiveAt != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "effectiveAt", effectiveAt)); // query parameter

            // authentication (oauth2) required
            // oauth required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            //  set the LUSID header
            localVarHeaderParams["X-LUSID-Sdk-Language"] = "C#";
            localVarHeaderParams["X-LUSID-Sdk-Version"] = "0.11.3417";

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeletePersonIdentifiers", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<DeletedEntityResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => string.Join(",", x.Value)),
                (DeletedEntityResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(DeletedEntityResponse)));
        }

        /// <summary>
        /// [EXPERIMENTAL] Delete Person Properties Delete all properties that belong to the given property keys of the person.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier type.</param>
        /// <param name="idTypeCode">Code of the person identifier type.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code. This together with stated identifier type uniquely              identifies the person.</param>
        /// <param name="propertyKeys">The property keys of the person&#39;s properties to delete. These take the format              {domain}/{scope}/{code} e.g. \&quot;Person/CompanyDetails/Role\&quot;. Each property must be from the \&quot;Person\&quot; domain. Properties or identifiers not specified in request will not be changed.</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to delete the properties. Defaults to the current LUSID system datetime if not specified.              Must not include an effective datetime of properties are perpetual. (optional)</param>
        /// <returns>DeletedEntityResponse</returns>
        public DeletedEntityResponse DeletePersonProperties (string idTypeScope, string idTypeCode, string code, List<string> propertyKeys, DateTimeOrCutLabel effectiveAt = null)
        {
             ApiResponse<DeletedEntityResponse> localVarResponse = DeletePersonPropertiesWithHttpInfo(idTypeScope, idTypeCode, code, propertyKeys, effectiveAt);
             return localVarResponse.Data;
        }

        /// <summary>
        /// [EXPERIMENTAL] Delete Person Properties Delete all properties that belong to the given property keys of the person.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier type.</param>
        /// <param name="idTypeCode">Code of the person identifier type.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code. This together with stated identifier type uniquely              identifies the person.</param>
        /// <param name="propertyKeys">The property keys of the person&#39;s properties to delete. These take the format              {domain}/{scope}/{code} e.g. \&quot;Person/CompanyDetails/Role\&quot;. Each property must be from the \&quot;Person\&quot; domain. Properties or identifiers not specified in request will not be changed.</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to delete the properties. Defaults to the current LUSID system datetime if not specified.              Must not include an effective datetime of properties are perpetual. (optional)</param>
        /// <returns>ApiResponse of DeletedEntityResponse</returns>
        public ApiResponse< DeletedEntityResponse > DeletePersonPropertiesWithHttpInfo (string idTypeScope, string idTypeCode, string code, List<string> propertyKeys, DateTimeOrCutLabel effectiveAt = null)
        {
            // verify the required parameter 'idTypeScope' is set
            if (idTypeScope == null)
                throw new ApiException(400, "Missing required parameter 'idTypeScope' when calling PersonsApi->DeletePersonProperties");
            // verify the required parameter 'idTypeCode' is set
            if (idTypeCode == null)
                throw new ApiException(400, "Missing required parameter 'idTypeCode' when calling PersonsApi->DeletePersonProperties");
            // verify the required parameter 'code' is set
            if (code == null)
                throw new ApiException(400, "Missing required parameter 'code' when calling PersonsApi->DeletePersonProperties");
            // verify the required parameter 'propertyKeys' is set
            if (propertyKeys == null)
                throw new ApiException(400, "Missing required parameter 'propertyKeys' when calling PersonsApi->DeletePersonProperties");

            var localVarPath = "./api/persons/{idTypeScope}/{idTypeCode}/{code}/properties";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "text/plain",
                "application/json",
                "text/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (idTypeScope != null) localVarPathParams.Add("idTypeScope", this.Configuration.ApiClient.ParameterToString(idTypeScope)); // path parameter
            if (idTypeCode != null) localVarPathParams.Add("idTypeCode", this.Configuration.ApiClient.ParameterToString(idTypeCode)); // path parameter
            if (code != null) localVarPathParams.Add("code", this.Configuration.ApiClient.ParameterToString(code)); // path parameter
            if (propertyKeys != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "propertyKeys", propertyKeys)); // query parameter
            if (effectiveAt != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "effectiveAt", effectiveAt)); // query parameter

            // authentication (oauth2) required
            // oauth required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            //  set the LUSID header
            localVarHeaderParams["X-LUSID-SDK-Language"] = "C#";
            localVarHeaderParams["X-LUSID-SDK-Version"] = "0.11.3417";

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeletePersonProperties", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<DeletedEntityResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => string.Join(",", x.Value)),
                (DeletedEntityResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(DeletedEntityResponse)));
        }

        /// <summary>
        /// [EXPERIMENTAL] Delete Person Properties Delete all properties that belong to the given property keys of the person.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier type.</param>
        /// <param name="idTypeCode">Code of the person identifier type.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code. This together with stated identifier type uniquely              identifies the person.</param>
        /// <param name="propertyKeys">The property keys of the person&#39;s properties to delete. These take the format              {domain}/{scope}/{code} e.g. \&quot;Person/CompanyDetails/Role\&quot;. Each property must be from the \&quot;Person\&quot; domain. Properties or identifiers not specified in request will not be changed.</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to delete the properties. Defaults to the current LUSID system datetime if not specified.              Must not include an effective datetime of properties are perpetual. (optional)</param>
        /// <returns>Task of DeletedEntityResponse</returns>
        public async System.Threading.Tasks.Task<DeletedEntityResponse> DeletePersonPropertiesAsync (string idTypeScope, string idTypeCode, string code, List<string> propertyKeys, DateTimeOrCutLabel effectiveAt = null)
        {
             ApiResponse<DeletedEntityResponse> localVarResponse = await DeletePersonPropertiesAsyncWithHttpInfo(idTypeScope, idTypeCode, code, propertyKeys, effectiveAt);
             return localVarResponse.Data;

        }

        /// <summary>
        /// [EXPERIMENTAL] Delete Person Properties Delete all properties that belong to the given property keys of the person.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier type.</param>
        /// <param name="idTypeCode">Code of the person identifier type.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code. This together with stated identifier type uniquely              identifies the person.</param>
        /// <param name="propertyKeys">The property keys of the person&#39;s properties to delete. These take the format              {domain}/{scope}/{code} e.g. \&quot;Person/CompanyDetails/Role\&quot;. Each property must be from the \&quot;Person\&quot; domain. Properties or identifiers not specified in request will not be changed.</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to delete the properties. Defaults to the current LUSID system datetime if not specified.              Must not include an effective datetime of properties are perpetual. (optional)</param>
        /// <returns>Task of ApiResponse (DeletedEntityResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<DeletedEntityResponse>> DeletePersonPropertiesAsyncWithHttpInfo (string idTypeScope, string idTypeCode, string code, List<string> propertyKeys, DateTimeOrCutLabel effectiveAt = null)
        {
            // verify the required parameter 'idTypeScope' is set
            if (idTypeScope == null)
                throw new ApiException(400, "Missing required parameter 'idTypeScope' when calling PersonsApi->DeletePersonProperties");
            // verify the required parameter 'idTypeCode' is set
            if (idTypeCode == null)
                throw new ApiException(400, "Missing required parameter 'idTypeCode' when calling PersonsApi->DeletePersonProperties");
            // verify the required parameter 'code' is set
            if (code == null)
                throw new ApiException(400, "Missing required parameter 'code' when calling PersonsApi->DeletePersonProperties");
            // verify the required parameter 'propertyKeys' is set
            if (propertyKeys == null)
                throw new ApiException(400, "Missing required parameter 'propertyKeys' when calling PersonsApi->DeletePersonProperties");

            var localVarPath = "./api/persons/{idTypeScope}/{idTypeCode}/{code}/properties";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "text/plain",
                "application/json",
                "text/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (idTypeScope != null) localVarPathParams.Add("idTypeScope", this.Configuration.ApiClient.ParameterToString(idTypeScope)); // path parameter
            if (idTypeCode != null) localVarPathParams.Add("idTypeCode", this.Configuration.ApiClient.ParameterToString(idTypeCode)); // path parameter
            if (code != null) localVarPathParams.Add("code", this.Configuration.ApiClient.ParameterToString(code)); // path parameter
            if (propertyKeys != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "propertyKeys", propertyKeys)); // query parameter
            if (effectiveAt != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "effectiveAt", effectiveAt)); // query parameter

            // authentication (oauth2) required
            // oauth required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            //  set the LUSID header
            localVarHeaderParams["X-LUSID-Sdk-Language"] = "C#";
            localVarHeaderParams["X-LUSID-Sdk-Version"] = "0.11.3417";

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeletePersonProperties", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<DeletedEntityResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => string.Join(",", x.Value)),
                (DeletedEntityResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(DeletedEntityResponse)));
        }

        /// <summary>
        /// [EXPERIMENTAL] Get Access Metadata rules for a Person Pass the Scope and Code of the Person identifier along with the person code parameter to retrieve the associated Access Metadata
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier.</param>
        /// <param name="idTypeCode">Code of the person identifier.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code.</param>
        /// <param name="effectiveAt">The effectiveAt datetime at which to retrieve the Access Metadata (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the Access Metadata (optional)</param>
        /// <returns>Dictionary&lt;string, List&lt;AccessMetadataValue&gt;&gt;</returns>
        public Dictionary<string, List<AccessMetadataValue>> GetAllPersonAccessMetadata (string idTypeScope, string idTypeCode, string code, DateTimeOrCutLabel effectiveAt = null, DateTimeOffset? asAt = null)
        {
             ApiResponse<Dictionary<string, List<AccessMetadataValue>>> localVarResponse = GetAllPersonAccessMetadataWithHttpInfo(idTypeScope, idTypeCode, code, effectiveAt, asAt);
             return localVarResponse.Data;
        }

        /// <summary>
        /// [EXPERIMENTAL] Get Access Metadata rules for a Person Pass the Scope and Code of the Person identifier along with the person code parameter to retrieve the associated Access Metadata
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier.</param>
        /// <param name="idTypeCode">Code of the person identifier.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code.</param>
        /// <param name="effectiveAt">The effectiveAt datetime at which to retrieve the Access Metadata (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the Access Metadata (optional)</param>
        /// <returns>ApiResponse of Dictionary&lt;string, List&lt;AccessMetadataValue&gt;&gt;</returns>
        public ApiResponse< Dictionary<string, List<AccessMetadataValue>> > GetAllPersonAccessMetadataWithHttpInfo (string idTypeScope, string idTypeCode, string code, DateTimeOrCutLabel effectiveAt = null, DateTimeOffset? asAt = null)
        {
            // verify the required parameter 'idTypeScope' is set
            if (idTypeScope == null)
                throw new ApiException(400, "Missing required parameter 'idTypeScope' when calling PersonsApi->GetAllPersonAccessMetadata");
            // verify the required parameter 'idTypeCode' is set
            if (idTypeCode == null)
                throw new ApiException(400, "Missing required parameter 'idTypeCode' when calling PersonsApi->GetAllPersonAccessMetadata");
            // verify the required parameter 'code' is set
            if (code == null)
                throw new ApiException(400, "Missing required parameter 'code' when calling PersonsApi->GetAllPersonAccessMetadata");

            var localVarPath = "./api/persons/{idTypeScope}/{idTypeCode}/{code}/metadata";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "text/plain",
                "application/json",
                "text/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (idTypeScope != null) localVarPathParams.Add("idTypeScope", this.Configuration.ApiClient.ParameterToString(idTypeScope)); // path parameter
            if (idTypeCode != null) localVarPathParams.Add("idTypeCode", this.Configuration.ApiClient.ParameterToString(idTypeCode)); // path parameter
            if (code != null) localVarPathParams.Add("code", this.Configuration.ApiClient.ParameterToString(code)); // path parameter
            if (effectiveAt != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "effectiveAt", effectiveAt)); // query parameter
            if (asAt != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "asAt", asAt)); // query parameter

            // authentication (oauth2) required
            // oauth required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            //  set the LUSID header
            localVarHeaderParams["X-LUSID-SDK-Language"] = "C#";
            localVarHeaderParams["X-LUSID-SDK-Version"] = "0.11.3417";

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetAllPersonAccessMetadata", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Dictionary<string, List<AccessMetadataValue>>>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => string.Join(",", x.Value)),
                (Dictionary<string, List<AccessMetadataValue>>) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(Dictionary<string, List<AccessMetadataValue>>)));
        }

        /// <summary>
        /// [EXPERIMENTAL] Get Access Metadata rules for a Person Pass the Scope and Code of the Person identifier along with the person code parameter to retrieve the associated Access Metadata
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier.</param>
        /// <param name="idTypeCode">Code of the person identifier.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code.</param>
        /// <param name="effectiveAt">The effectiveAt datetime at which to retrieve the Access Metadata (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the Access Metadata (optional)</param>
        /// <returns>Task of Dictionary&lt;string, List&lt;AccessMetadataValue&gt;&gt;</returns>
        public async System.Threading.Tasks.Task<Dictionary<string, List<AccessMetadataValue>>> GetAllPersonAccessMetadataAsync (string idTypeScope, string idTypeCode, string code, DateTimeOrCutLabel effectiveAt = null, DateTimeOffset? asAt = null)
        {
             ApiResponse<Dictionary<string, List<AccessMetadataValue>>> localVarResponse = await GetAllPersonAccessMetadataAsyncWithHttpInfo(idTypeScope, idTypeCode, code, effectiveAt, asAt);
             return localVarResponse.Data;

        }

        /// <summary>
        /// [EXPERIMENTAL] Get Access Metadata rules for a Person Pass the Scope and Code of the Person identifier along with the person code parameter to retrieve the associated Access Metadata
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier.</param>
        /// <param name="idTypeCode">Code of the person identifier.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code.</param>
        /// <param name="effectiveAt">The effectiveAt datetime at which to retrieve the Access Metadata (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the Access Metadata (optional)</param>
        /// <returns>Task of ApiResponse (Dictionary&lt;string, List&lt;AccessMetadataValue&gt;&gt;)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Dictionary<string, List<AccessMetadataValue>>>> GetAllPersonAccessMetadataAsyncWithHttpInfo (string idTypeScope, string idTypeCode, string code, DateTimeOrCutLabel effectiveAt = null, DateTimeOffset? asAt = null)
        {
            // verify the required parameter 'idTypeScope' is set
            if (idTypeScope == null)
                throw new ApiException(400, "Missing required parameter 'idTypeScope' when calling PersonsApi->GetAllPersonAccessMetadata");
            // verify the required parameter 'idTypeCode' is set
            if (idTypeCode == null)
                throw new ApiException(400, "Missing required parameter 'idTypeCode' when calling PersonsApi->GetAllPersonAccessMetadata");
            // verify the required parameter 'code' is set
            if (code == null)
                throw new ApiException(400, "Missing required parameter 'code' when calling PersonsApi->GetAllPersonAccessMetadata");

            var localVarPath = "./api/persons/{idTypeScope}/{idTypeCode}/{code}/metadata";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "text/plain",
                "application/json",
                "text/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (idTypeScope != null) localVarPathParams.Add("idTypeScope", this.Configuration.ApiClient.ParameterToString(idTypeScope)); // path parameter
            if (idTypeCode != null) localVarPathParams.Add("idTypeCode", this.Configuration.ApiClient.ParameterToString(idTypeCode)); // path parameter
            if (code != null) localVarPathParams.Add("code", this.Configuration.ApiClient.ParameterToString(code)); // path parameter
            if (effectiveAt != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "effectiveAt", effectiveAt)); // query parameter
            if (asAt != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "asAt", asAt)); // query parameter

            // authentication (oauth2) required
            // oauth required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            //  set the LUSID header
            localVarHeaderParams["X-LUSID-Sdk-Language"] = "C#";
            localVarHeaderParams["X-LUSID-Sdk-Version"] = "0.11.3417";

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetAllPersonAccessMetadata", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Dictionary<string, List<AccessMetadataValue>>>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => string.Join(",", x.Value)),
                (Dictionary<string, List<AccessMetadataValue>>) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(Dictionary<string, List<AccessMetadataValue>>)));
        }

        /// <summary>
        /// [EXPERIMENTAL] Get Person Retrieve the definition of a person.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier type.</param>
        /// <param name="idTypeCode">Code of the person identifier type.</param>
        /// <param name="code">Code of the person under specified scope and code. This together with stated identifier type uniquely              identifies the person.</param>
        /// <param name="propertyKeys">A list of property keys from the \&quot;Person\&quot; domain to decorate onto each person.              These take the format {domain}/{scope}/{code} e.g. \&quot;Person/ContactDetails/Address\&quot;. Defaults to include all properties if not specified. (optional)</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to retrieve the person. Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the person. Defaults to return the latest version of the person if not specified. (optional)</param>
        /// <returns>Person</returns>
        public Person GetPerson (string idTypeScope, string idTypeCode, string code, List<string> propertyKeys = null, DateTimeOrCutLabel effectiveAt = null, DateTimeOffset? asAt = null)
        {
             ApiResponse<Person> localVarResponse = GetPersonWithHttpInfo(idTypeScope, idTypeCode, code, propertyKeys, effectiveAt, asAt);
             return localVarResponse.Data;
        }

        /// <summary>
        /// [EXPERIMENTAL] Get Person Retrieve the definition of a person.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier type.</param>
        /// <param name="idTypeCode">Code of the person identifier type.</param>
        /// <param name="code">Code of the person under specified scope and code. This together with stated identifier type uniquely              identifies the person.</param>
        /// <param name="propertyKeys">A list of property keys from the \&quot;Person\&quot; domain to decorate onto each person.              These take the format {domain}/{scope}/{code} e.g. \&quot;Person/ContactDetails/Address\&quot;. Defaults to include all properties if not specified. (optional)</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to retrieve the person. Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the person. Defaults to return the latest version of the person if not specified. (optional)</param>
        /// <returns>ApiResponse of Person</returns>
        public ApiResponse< Person > GetPersonWithHttpInfo (string idTypeScope, string idTypeCode, string code, List<string> propertyKeys = null, DateTimeOrCutLabel effectiveAt = null, DateTimeOffset? asAt = null)
        {
            // verify the required parameter 'idTypeScope' is set
            if (idTypeScope == null)
                throw new ApiException(400, "Missing required parameter 'idTypeScope' when calling PersonsApi->GetPerson");
            // verify the required parameter 'idTypeCode' is set
            if (idTypeCode == null)
                throw new ApiException(400, "Missing required parameter 'idTypeCode' when calling PersonsApi->GetPerson");
            // verify the required parameter 'code' is set
            if (code == null)
                throw new ApiException(400, "Missing required parameter 'code' when calling PersonsApi->GetPerson");

            var localVarPath = "./api/persons/{idTypeScope}/{idTypeCode}/{code}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "text/plain",
                "application/json",
                "text/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (idTypeScope != null) localVarPathParams.Add("idTypeScope", this.Configuration.ApiClient.ParameterToString(idTypeScope)); // path parameter
            if (idTypeCode != null) localVarPathParams.Add("idTypeCode", this.Configuration.ApiClient.ParameterToString(idTypeCode)); // path parameter
            if (code != null) localVarPathParams.Add("code", this.Configuration.ApiClient.ParameterToString(code)); // path parameter
            if (propertyKeys != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "propertyKeys", propertyKeys)); // query parameter
            if (effectiveAt != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "effectiveAt", effectiveAt)); // query parameter
            if (asAt != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "asAt", asAt)); // query parameter

            // authentication (oauth2) required
            // oauth required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            //  set the LUSID header
            localVarHeaderParams["X-LUSID-SDK-Language"] = "C#";
            localVarHeaderParams["X-LUSID-SDK-Version"] = "0.11.3417";

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetPerson", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Person>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => string.Join(",", x.Value)),
                (Person) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(Person)));
        }

        /// <summary>
        /// [EXPERIMENTAL] Get Person Retrieve the definition of a person.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier type.</param>
        /// <param name="idTypeCode">Code of the person identifier type.</param>
        /// <param name="code">Code of the person under specified scope and code. This together with stated identifier type uniquely              identifies the person.</param>
        /// <param name="propertyKeys">A list of property keys from the \&quot;Person\&quot; domain to decorate onto each person.              These take the format {domain}/{scope}/{code} e.g. \&quot;Person/ContactDetails/Address\&quot;. Defaults to include all properties if not specified. (optional)</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to retrieve the person. Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the person. Defaults to return the latest version of the person if not specified. (optional)</param>
        /// <returns>Task of Person</returns>
        public async System.Threading.Tasks.Task<Person> GetPersonAsync (string idTypeScope, string idTypeCode, string code, List<string> propertyKeys = null, DateTimeOrCutLabel effectiveAt = null, DateTimeOffset? asAt = null)
        {
             ApiResponse<Person> localVarResponse = await GetPersonAsyncWithHttpInfo(idTypeScope, idTypeCode, code, propertyKeys, effectiveAt, asAt);
             return localVarResponse.Data;

        }

        /// <summary>
        /// [EXPERIMENTAL] Get Person Retrieve the definition of a person.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier type.</param>
        /// <param name="idTypeCode">Code of the person identifier type.</param>
        /// <param name="code">Code of the person under specified scope and code. This together with stated identifier type uniquely              identifies the person.</param>
        /// <param name="propertyKeys">A list of property keys from the \&quot;Person\&quot; domain to decorate onto each person.              These take the format {domain}/{scope}/{code} e.g. \&quot;Person/ContactDetails/Address\&quot;. Defaults to include all properties if not specified. (optional)</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to retrieve the person. Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the person. Defaults to return the latest version of the person if not specified. (optional)</param>
        /// <returns>Task of ApiResponse (Person)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Person>> GetPersonAsyncWithHttpInfo (string idTypeScope, string idTypeCode, string code, List<string> propertyKeys = null, DateTimeOrCutLabel effectiveAt = null, DateTimeOffset? asAt = null)
        {
            // verify the required parameter 'idTypeScope' is set
            if (idTypeScope == null)
                throw new ApiException(400, "Missing required parameter 'idTypeScope' when calling PersonsApi->GetPerson");
            // verify the required parameter 'idTypeCode' is set
            if (idTypeCode == null)
                throw new ApiException(400, "Missing required parameter 'idTypeCode' when calling PersonsApi->GetPerson");
            // verify the required parameter 'code' is set
            if (code == null)
                throw new ApiException(400, "Missing required parameter 'code' when calling PersonsApi->GetPerson");

            var localVarPath = "./api/persons/{idTypeScope}/{idTypeCode}/{code}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "text/plain",
                "application/json",
                "text/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (idTypeScope != null) localVarPathParams.Add("idTypeScope", this.Configuration.ApiClient.ParameterToString(idTypeScope)); // path parameter
            if (idTypeCode != null) localVarPathParams.Add("idTypeCode", this.Configuration.ApiClient.ParameterToString(idTypeCode)); // path parameter
            if (code != null) localVarPathParams.Add("code", this.Configuration.ApiClient.ParameterToString(code)); // path parameter
            if (propertyKeys != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "propertyKeys", propertyKeys)); // query parameter
            if (effectiveAt != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "effectiveAt", effectiveAt)); // query parameter
            if (asAt != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "asAt", asAt)); // query parameter

            // authentication (oauth2) required
            // oauth required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            //  set the LUSID header
            localVarHeaderParams["X-LUSID-Sdk-Language"] = "C#";
            localVarHeaderParams["X-LUSID-Sdk-Version"] = "0.11.3417";

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetPerson", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Person>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => string.Join(",", x.Value)),
                (Person) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(Person)));
        }

        /// <summary>
        /// [EXPERIMENTAL] Get an entry identified by a metadataKey in the Access Metadata of a Person Get a specific Person Access Metadata by specifying the corresponding identifier parts and Person code                No matching will be performed through this endpoint. To retrieve an entry, it is necessary to specify, exactly, the identifier of the entry
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier.</param>
        /// <param name="idTypeCode">Code of the person identifier.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code.</param>
        /// <param name="metadataKey">Key of the metadata entry to retrieve</param>
        /// <param name="effectiveAt">The effectiveAt datetime at which to retrieve the Access Metadata (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the Access Metadata (optional)</param>
        /// <returns>ICollection&lt;AccessMetadataValue&gt;</returns>
        public ICollection<AccessMetadataValue> GetPersonAccessMetadataByKey (string idTypeScope, string idTypeCode, string code, string metadataKey, DateTimeOrCutLabel effectiveAt = null, DateTimeOffset? asAt = null)
        {
             ApiResponse<ICollection<AccessMetadataValue>> localVarResponse = GetPersonAccessMetadataByKeyWithHttpInfo(idTypeScope, idTypeCode, code, metadataKey, effectiveAt, asAt);
             return localVarResponse.Data;
        }

        /// <summary>
        /// [EXPERIMENTAL] Get an entry identified by a metadataKey in the Access Metadata of a Person Get a specific Person Access Metadata by specifying the corresponding identifier parts and Person code                No matching will be performed through this endpoint. To retrieve an entry, it is necessary to specify, exactly, the identifier of the entry
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier.</param>
        /// <param name="idTypeCode">Code of the person identifier.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code.</param>
        /// <param name="metadataKey">Key of the metadata entry to retrieve</param>
        /// <param name="effectiveAt">The effectiveAt datetime at which to retrieve the Access Metadata (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the Access Metadata (optional)</param>
        /// <returns>ApiResponse of ICollection&lt;AccessMetadataValue&gt;</returns>
        public ApiResponse< ICollection<AccessMetadataValue> > GetPersonAccessMetadataByKeyWithHttpInfo (string idTypeScope, string idTypeCode, string code, string metadataKey, DateTimeOrCutLabel effectiveAt = null, DateTimeOffset? asAt = null)
        {
            // verify the required parameter 'idTypeScope' is set
            if (idTypeScope == null)
                throw new ApiException(400, "Missing required parameter 'idTypeScope' when calling PersonsApi->GetPersonAccessMetadataByKey");
            // verify the required parameter 'idTypeCode' is set
            if (idTypeCode == null)
                throw new ApiException(400, "Missing required parameter 'idTypeCode' when calling PersonsApi->GetPersonAccessMetadataByKey");
            // verify the required parameter 'code' is set
            if (code == null)
                throw new ApiException(400, "Missing required parameter 'code' when calling PersonsApi->GetPersonAccessMetadataByKey");
            // verify the required parameter 'metadataKey' is set
            if (metadataKey == null)
                throw new ApiException(400, "Missing required parameter 'metadataKey' when calling PersonsApi->GetPersonAccessMetadataByKey");

            var localVarPath = "./api/persons/{idTypeScope}/{idTypeCode}/{code}/metadata/{metadataKey}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "text/plain",
                "application/json",
                "text/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (idTypeScope != null) localVarPathParams.Add("idTypeScope", this.Configuration.ApiClient.ParameterToString(idTypeScope)); // path parameter
            if (idTypeCode != null) localVarPathParams.Add("idTypeCode", this.Configuration.ApiClient.ParameterToString(idTypeCode)); // path parameter
            if (code != null) localVarPathParams.Add("code", this.Configuration.ApiClient.ParameterToString(code)); // path parameter
            if (metadataKey != null) localVarPathParams.Add("metadataKey", this.Configuration.ApiClient.ParameterToString(metadataKey)); // path parameter
            if (effectiveAt != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "effectiveAt", effectiveAt)); // query parameter
            if (asAt != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "asAt", asAt)); // query parameter

            // authentication (oauth2) required
            // oauth required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            //  set the LUSID header
            localVarHeaderParams["X-LUSID-SDK-Language"] = "C#";
            localVarHeaderParams["X-LUSID-SDK-Version"] = "0.11.3417";

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetPersonAccessMetadataByKey", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<ICollection<AccessMetadataValue>>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => string.Join(",", x.Value)),
                (ICollection<AccessMetadataValue>) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(List<AccessMetadataValue>)));
        }

        /// <summary>
        /// [EXPERIMENTAL] Get an entry identified by a metadataKey in the Access Metadata of a Person Get a specific Person Access Metadata by specifying the corresponding identifier parts and Person code                No matching will be performed through this endpoint. To retrieve an entry, it is necessary to specify, exactly, the identifier of the entry
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier.</param>
        /// <param name="idTypeCode">Code of the person identifier.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code.</param>
        /// <param name="metadataKey">Key of the metadata entry to retrieve</param>
        /// <param name="effectiveAt">The effectiveAt datetime at which to retrieve the Access Metadata (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the Access Metadata (optional)</param>
        /// <returns>Task of ICollection&lt;AccessMetadataValue&gt;</returns>
        public async System.Threading.Tasks.Task<ICollection<AccessMetadataValue>> GetPersonAccessMetadataByKeyAsync (string idTypeScope, string idTypeCode, string code, string metadataKey, DateTimeOrCutLabel effectiveAt = null, DateTimeOffset? asAt = null)
        {
             ApiResponse<ICollection<AccessMetadataValue>> localVarResponse = await GetPersonAccessMetadataByKeyAsyncWithHttpInfo(idTypeScope, idTypeCode, code, metadataKey, effectiveAt, asAt);
             return localVarResponse.Data;

        }

        /// <summary>
        /// [EXPERIMENTAL] Get an entry identified by a metadataKey in the Access Metadata of a Person Get a specific Person Access Metadata by specifying the corresponding identifier parts and Person code                No matching will be performed through this endpoint. To retrieve an entry, it is necessary to specify, exactly, the identifier of the entry
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier.</param>
        /// <param name="idTypeCode">Code of the person identifier.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code.</param>
        /// <param name="metadataKey">Key of the metadata entry to retrieve</param>
        /// <param name="effectiveAt">The effectiveAt datetime at which to retrieve the Access Metadata (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the Access Metadata (optional)</param>
        /// <returns>Task of ApiResponse (ICollection&lt;AccessMetadataValue&gt;)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<ICollection<AccessMetadataValue>>> GetPersonAccessMetadataByKeyAsyncWithHttpInfo (string idTypeScope, string idTypeCode, string code, string metadataKey, DateTimeOrCutLabel effectiveAt = null, DateTimeOffset? asAt = null)
        {
            // verify the required parameter 'idTypeScope' is set
            if (idTypeScope == null)
                throw new ApiException(400, "Missing required parameter 'idTypeScope' when calling PersonsApi->GetPersonAccessMetadataByKey");
            // verify the required parameter 'idTypeCode' is set
            if (idTypeCode == null)
                throw new ApiException(400, "Missing required parameter 'idTypeCode' when calling PersonsApi->GetPersonAccessMetadataByKey");
            // verify the required parameter 'code' is set
            if (code == null)
                throw new ApiException(400, "Missing required parameter 'code' when calling PersonsApi->GetPersonAccessMetadataByKey");
            // verify the required parameter 'metadataKey' is set
            if (metadataKey == null)
                throw new ApiException(400, "Missing required parameter 'metadataKey' when calling PersonsApi->GetPersonAccessMetadataByKey");

            var localVarPath = "./api/persons/{idTypeScope}/{idTypeCode}/{code}/metadata/{metadataKey}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "text/plain",
                "application/json",
                "text/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (idTypeScope != null) localVarPathParams.Add("idTypeScope", this.Configuration.ApiClient.ParameterToString(idTypeScope)); // path parameter
            if (idTypeCode != null) localVarPathParams.Add("idTypeCode", this.Configuration.ApiClient.ParameterToString(idTypeCode)); // path parameter
            if (code != null) localVarPathParams.Add("code", this.Configuration.ApiClient.ParameterToString(code)); // path parameter
            if (metadataKey != null) localVarPathParams.Add("metadataKey", this.Configuration.ApiClient.ParameterToString(metadataKey)); // path parameter
            if (effectiveAt != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "effectiveAt", effectiveAt)); // query parameter
            if (asAt != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "asAt", asAt)); // query parameter

            // authentication (oauth2) required
            // oauth required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            //  set the LUSID header
            localVarHeaderParams["X-LUSID-Sdk-Language"] = "C#";
            localVarHeaderParams["X-LUSID-Sdk-Version"] = "0.11.3417";

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetPersonAccessMetadataByKey", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<ICollection<AccessMetadataValue>>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => string.Join(",", x.Value)),
                (ICollection<AccessMetadataValue>) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(List<AccessMetadataValue>)));
        }

        /// <summary>
        /// [EXPERIMENTAL] Get Person Property Time Series List the complete time series of a person property.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier type.</param>
        /// <param name="idTypeCode">Code of the person identifier type.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code. This together with stated identifier type uniquely identifies the person.</param>
        /// <param name="propertyKey">The property key of the property that will have its history shown. These must be in the format {domain}/{scope}/{code} e.g. \&quot;Person/CompanyDetails/Role\&quot;.              Each property must be from the \&quot;Person\&quot; domain. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to list the person&#39;s property history. Defaults to return the current datetime if not supplied. (optional)</param>
        /// <param name="filter">Expression to filter the result set. Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing properties from a previous call to get property time series.              This value is returned from the previous call. If a pagination token is provided the filter and asAt fields              must not have changed since the original request. (optional)</param>
        /// <param name="limit">When paginating, limit the number of returned results to this many. (optional)</param>
        /// <returns>ResourceListOfPropertyInterval</returns>
        public ResourceListOfPropertyInterval GetPersonPropertyTimeSeries (string idTypeScope, string idTypeCode, string code, string propertyKey = null, DateTimeOffset? asAt = null, string filter = null, string page = null, int? limit = null)
        {
             ApiResponse<ResourceListOfPropertyInterval> localVarResponse = GetPersonPropertyTimeSeriesWithHttpInfo(idTypeScope, idTypeCode, code, propertyKey, asAt, filter, page, limit);
             return localVarResponse.Data;
        }

        /// <summary>
        /// [EXPERIMENTAL] Get Person Property Time Series List the complete time series of a person property.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier type.</param>
        /// <param name="idTypeCode">Code of the person identifier type.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code. This together with stated identifier type uniquely identifies the person.</param>
        /// <param name="propertyKey">The property key of the property that will have its history shown. These must be in the format {domain}/{scope}/{code} e.g. \&quot;Person/CompanyDetails/Role\&quot;.              Each property must be from the \&quot;Person\&quot; domain. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to list the person&#39;s property history. Defaults to return the current datetime if not supplied. (optional)</param>
        /// <param name="filter">Expression to filter the result set. Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing properties from a previous call to get property time series.              This value is returned from the previous call. If a pagination token is provided the filter and asAt fields              must not have changed since the original request. (optional)</param>
        /// <param name="limit">When paginating, limit the number of returned results to this many. (optional)</param>
        /// <returns>ApiResponse of ResourceListOfPropertyInterval</returns>
        public ApiResponse< ResourceListOfPropertyInterval > GetPersonPropertyTimeSeriesWithHttpInfo (string idTypeScope, string idTypeCode, string code, string propertyKey = null, DateTimeOffset? asAt = null, string filter = null, string page = null, int? limit = null)
        {
            // verify the required parameter 'idTypeScope' is set
            if (idTypeScope == null)
                throw new ApiException(400, "Missing required parameter 'idTypeScope' when calling PersonsApi->GetPersonPropertyTimeSeries");
            // verify the required parameter 'idTypeCode' is set
            if (idTypeCode == null)
                throw new ApiException(400, "Missing required parameter 'idTypeCode' when calling PersonsApi->GetPersonPropertyTimeSeries");
            // verify the required parameter 'code' is set
            if (code == null)
                throw new ApiException(400, "Missing required parameter 'code' when calling PersonsApi->GetPersonPropertyTimeSeries");

            var localVarPath = "./api/persons/{idTypeScope}/{idTypeCode}/{code}/properties/time-series";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "text/plain",
                "application/json",
                "text/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (idTypeScope != null) localVarPathParams.Add("idTypeScope", this.Configuration.ApiClient.ParameterToString(idTypeScope)); // path parameter
            if (idTypeCode != null) localVarPathParams.Add("idTypeCode", this.Configuration.ApiClient.ParameterToString(idTypeCode)); // path parameter
            if (code != null) localVarPathParams.Add("code", this.Configuration.ApiClient.ParameterToString(code)); // path parameter
            if (propertyKey != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "propertyKey", propertyKey)); // query parameter
            if (asAt != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "asAt", asAt)); // query parameter
            if (filter != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "filter", filter)); // query parameter
            if (page != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "page", page)); // query parameter
            if (limit != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "limit", limit)); // query parameter

            // authentication (oauth2) required
            // oauth required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            //  set the LUSID header
            localVarHeaderParams["X-LUSID-SDK-Language"] = "C#";
            localVarHeaderParams["X-LUSID-SDK-Version"] = "0.11.3417";

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetPersonPropertyTimeSeries", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<ResourceListOfPropertyInterval>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => string.Join(",", x.Value)),
                (ResourceListOfPropertyInterval) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(ResourceListOfPropertyInterval)));
        }

        /// <summary>
        /// [EXPERIMENTAL] Get Person Property Time Series List the complete time series of a person property.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier type.</param>
        /// <param name="idTypeCode">Code of the person identifier type.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code. This together with stated identifier type uniquely identifies the person.</param>
        /// <param name="propertyKey">The property key of the property that will have its history shown. These must be in the format {domain}/{scope}/{code} e.g. \&quot;Person/CompanyDetails/Role\&quot;.              Each property must be from the \&quot;Person\&quot; domain. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to list the person&#39;s property history. Defaults to return the current datetime if not supplied. (optional)</param>
        /// <param name="filter">Expression to filter the result set. Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing properties from a previous call to get property time series.              This value is returned from the previous call. If a pagination token is provided the filter and asAt fields              must not have changed since the original request. (optional)</param>
        /// <param name="limit">When paginating, limit the number of returned results to this many. (optional)</param>
        /// <returns>Task of ResourceListOfPropertyInterval</returns>
        public async System.Threading.Tasks.Task<ResourceListOfPropertyInterval> GetPersonPropertyTimeSeriesAsync (string idTypeScope, string idTypeCode, string code, string propertyKey = null, DateTimeOffset? asAt = null, string filter = null, string page = null, int? limit = null)
        {
             ApiResponse<ResourceListOfPropertyInterval> localVarResponse = await GetPersonPropertyTimeSeriesAsyncWithHttpInfo(idTypeScope, idTypeCode, code, propertyKey, asAt, filter, page, limit);
             return localVarResponse.Data;

        }

        /// <summary>
        /// [EXPERIMENTAL] Get Person Property Time Series List the complete time series of a person property.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier type.</param>
        /// <param name="idTypeCode">Code of the person identifier type.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code. This together with stated identifier type uniquely identifies the person.</param>
        /// <param name="propertyKey">The property key of the property that will have its history shown. These must be in the format {domain}/{scope}/{code} e.g. \&quot;Person/CompanyDetails/Role\&quot;.              Each property must be from the \&quot;Person\&quot; domain. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to list the person&#39;s property history. Defaults to return the current datetime if not supplied. (optional)</param>
        /// <param name="filter">Expression to filter the result set. Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing properties from a previous call to get property time series.              This value is returned from the previous call. If a pagination token is provided the filter and asAt fields              must not have changed since the original request. (optional)</param>
        /// <param name="limit">When paginating, limit the number of returned results to this many. (optional)</param>
        /// <returns>Task of ApiResponse (ResourceListOfPropertyInterval)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<ResourceListOfPropertyInterval>> GetPersonPropertyTimeSeriesAsyncWithHttpInfo (string idTypeScope, string idTypeCode, string code, string propertyKey = null, DateTimeOffset? asAt = null, string filter = null, string page = null, int? limit = null)
        {
            // verify the required parameter 'idTypeScope' is set
            if (idTypeScope == null)
                throw new ApiException(400, "Missing required parameter 'idTypeScope' when calling PersonsApi->GetPersonPropertyTimeSeries");
            // verify the required parameter 'idTypeCode' is set
            if (idTypeCode == null)
                throw new ApiException(400, "Missing required parameter 'idTypeCode' when calling PersonsApi->GetPersonPropertyTimeSeries");
            // verify the required parameter 'code' is set
            if (code == null)
                throw new ApiException(400, "Missing required parameter 'code' when calling PersonsApi->GetPersonPropertyTimeSeries");

            var localVarPath = "./api/persons/{idTypeScope}/{idTypeCode}/{code}/properties/time-series";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "text/plain",
                "application/json",
                "text/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (idTypeScope != null) localVarPathParams.Add("idTypeScope", this.Configuration.ApiClient.ParameterToString(idTypeScope)); // path parameter
            if (idTypeCode != null) localVarPathParams.Add("idTypeCode", this.Configuration.ApiClient.ParameterToString(idTypeCode)); // path parameter
            if (code != null) localVarPathParams.Add("code", this.Configuration.ApiClient.ParameterToString(code)); // path parameter
            if (propertyKey != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "propertyKey", propertyKey)); // query parameter
            if (asAt != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "asAt", asAt)); // query parameter
            if (filter != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "filter", filter)); // query parameter
            if (page != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "page", page)); // query parameter
            if (limit != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "limit", limit)); // query parameter

            // authentication (oauth2) required
            // oauth required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            //  set the LUSID header
            localVarHeaderParams["X-LUSID-Sdk-Language"] = "C#";
            localVarHeaderParams["X-LUSID-Sdk-Version"] = "0.11.3417";

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetPersonPropertyTimeSeries", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<ResourceListOfPropertyInterval>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => string.Join(",", x.Value)),
                (ResourceListOfPropertyInterval) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(ResourceListOfPropertyInterval)));
        }

        /// <summary>
        /// [EXPERIMENTAL] Get Relations for Person Get relations for the specified person.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier type.</param>
        /// <param name="idTypeCode">Code of the person identifier type.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code. This together with stated identifier type uniquely              identifies the person.</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to get relations. Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the person&#39;s relations. Defaults to return the latest LUSID AsAt time if not specified. (optional)</param>
        /// <param name="filter">Expression to filter the relations. Users should provide null or empty string for this field until further notice. (optional)</param>
        /// <param name="identifierTypes">Identifiers types (as property keys) used for referencing Persons or Legal Entities. These take the format              {domain}/{scope}/{code} e.g. \&quot;Person/CompanyDetails/Role\&quot;. They must be from the \&quot;Person\&quot; or \&quot;LegalEntity\&quot; domain.              Only identifier types stated will be used to look up relevant entities in relations. If not applicable, provide an empty array. (optional)</param>
        /// <returns>ResourceListOfRelation</returns>
        public ResourceListOfRelation GetPersonRelations (string idTypeScope, string idTypeCode, string code, DateTimeOrCutLabel effectiveAt = null, DateTimeOffset? asAt = null, string filter = null, List<string> identifierTypes = null)
        {
             ApiResponse<ResourceListOfRelation> localVarResponse = GetPersonRelationsWithHttpInfo(idTypeScope, idTypeCode, code, effectiveAt, asAt, filter, identifierTypes);
             return localVarResponse.Data;
        }

        /// <summary>
        /// [EXPERIMENTAL] Get Relations for Person Get relations for the specified person.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier type.</param>
        /// <param name="idTypeCode">Code of the person identifier type.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code. This together with stated identifier type uniquely              identifies the person.</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to get relations. Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the person&#39;s relations. Defaults to return the latest LUSID AsAt time if not specified. (optional)</param>
        /// <param name="filter">Expression to filter the relations. Users should provide null or empty string for this field until further notice. (optional)</param>
        /// <param name="identifierTypes">Identifiers types (as property keys) used for referencing Persons or Legal Entities. These take the format              {domain}/{scope}/{code} e.g. \&quot;Person/CompanyDetails/Role\&quot;. They must be from the \&quot;Person\&quot; or \&quot;LegalEntity\&quot; domain.              Only identifier types stated will be used to look up relevant entities in relations. If not applicable, provide an empty array. (optional)</param>
        /// <returns>ApiResponse of ResourceListOfRelation</returns>
        public ApiResponse< ResourceListOfRelation > GetPersonRelationsWithHttpInfo (string idTypeScope, string idTypeCode, string code, DateTimeOrCutLabel effectiveAt = null, DateTimeOffset? asAt = null, string filter = null, List<string> identifierTypes = null)
        {
            // verify the required parameter 'idTypeScope' is set
            if (idTypeScope == null)
                throw new ApiException(400, "Missing required parameter 'idTypeScope' when calling PersonsApi->GetPersonRelations");
            // verify the required parameter 'idTypeCode' is set
            if (idTypeCode == null)
                throw new ApiException(400, "Missing required parameter 'idTypeCode' when calling PersonsApi->GetPersonRelations");
            // verify the required parameter 'code' is set
            if (code == null)
                throw new ApiException(400, "Missing required parameter 'code' when calling PersonsApi->GetPersonRelations");

            var localVarPath = "./api/persons/{idTypeScope}/{idTypeCode}/{code}/relations";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "text/plain",
                "application/json",
                "text/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (idTypeScope != null) localVarPathParams.Add("idTypeScope", this.Configuration.ApiClient.ParameterToString(idTypeScope)); // path parameter
            if (idTypeCode != null) localVarPathParams.Add("idTypeCode", this.Configuration.ApiClient.ParameterToString(idTypeCode)); // path parameter
            if (code != null) localVarPathParams.Add("code", this.Configuration.ApiClient.ParameterToString(code)); // path parameter
            if (effectiveAt != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "effectiveAt", effectiveAt)); // query parameter
            if (asAt != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "asAt", asAt)); // query parameter
            if (filter != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "filter", filter)); // query parameter
            if (identifierTypes != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "identifierTypes", identifierTypes)); // query parameter

            // authentication (oauth2) required
            // oauth required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            //  set the LUSID header
            localVarHeaderParams["X-LUSID-SDK-Language"] = "C#";
            localVarHeaderParams["X-LUSID-SDK-Version"] = "0.11.3417";

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetPersonRelations", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<ResourceListOfRelation>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => string.Join(",", x.Value)),
                (ResourceListOfRelation) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(ResourceListOfRelation)));
        }

        /// <summary>
        /// [EXPERIMENTAL] Get Relations for Person Get relations for the specified person.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier type.</param>
        /// <param name="idTypeCode">Code of the person identifier type.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code. This together with stated identifier type uniquely              identifies the person.</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to get relations. Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the person&#39;s relations. Defaults to return the latest LUSID AsAt time if not specified. (optional)</param>
        /// <param name="filter">Expression to filter the relations. Users should provide null or empty string for this field until further notice. (optional)</param>
        /// <param name="identifierTypes">Identifiers types (as property keys) used for referencing Persons or Legal Entities. These take the format              {domain}/{scope}/{code} e.g. \&quot;Person/CompanyDetails/Role\&quot;. They must be from the \&quot;Person\&quot; or \&quot;LegalEntity\&quot; domain.              Only identifier types stated will be used to look up relevant entities in relations. If not applicable, provide an empty array. (optional)</param>
        /// <returns>Task of ResourceListOfRelation</returns>
        public async System.Threading.Tasks.Task<ResourceListOfRelation> GetPersonRelationsAsync (string idTypeScope, string idTypeCode, string code, DateTimeOrCutLabel effectiveAt = null, DateTimeOffset? asAt = null, string filter = null, List<string> identifierTypes = null)
        {
             ApiResponse<ResourceListOfRelation> localVarResponse = await GetPersonRelationsAsyncWithHttpInfo(idTypeScope, idTypeCode, code, effectiveAt, asAt, filter, identifierTypes);
             return localVarResponse.Data;

        }

        /// <summary>
        /// [EXPERIMENTAL] Get Relations for Person Get relations for the specified person.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier type.</param>
        /// <param name="idTypeCode">Code of the person identifier type.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code. This together with stated identifier type uniquely              identifies the person.</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to get relations. Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the person&#39;s relations. Defaults to return the latest LUSID AsAt time if not specified. (optional)</param>
        /// <param name="filter">Expression to filter the relations. Users should provide null or empty string for this field until further notice. (optional)</param>
        /// <param name="identifierTypes">Identifiers types (as property keys) used for referencing Persons or Legal Entities. These take the format              {domain}/{scope}/{code} e.g. \&quot;Person/CompanyDetails/Role\&quot;. They must be from the \&quot;Person\&quot; or \&quot;LegalEntity\&quot; domain.              Only identifier types stated will be used to look up relevant entities in relations. If not applicable, provide an empty array. (optional)</param>
        /// <returns>Task of ApiResponse (ResourceListOfRelation)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<ResourceListOfRelation>> GetPersonRelationsAsyncWithHttpInfo (string idTypeScope, string idTypeCode, string code, DateTimeOrCutLabel effectiveAt = null, DateTimeOffset? asAt = null, string filter = null, List<string> identifierTypes = null)
        {
            // verify the required parameter 'idTypeScope' is set
            if (idTypeScope == null)
                throw new ApiException(400, "Missing required parameter 'idTypeScope' when calling PersonsApi->GetPersonRelations");
            // verify the required parameter 'idTypeCode' is set
            if (idTypeCode == null)
                throw new ApiException(400, "Missing required parameter 'idTypeCode' when calling PersonsApi->GetPersonRelations");
            // verify the required parameter 'code' is set
            if (code == null)
                throw new ApiException(400, "Missing required parameter 'code' when calling PersonsApi->GetPersonRelations");

            var localVarPath = "./api/persons/{idTypeScope}/{idTypeCode}/{code}/relations";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "text/plain",
                "application/json",
                "text/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (idTypeScope != null) localVarPathParams.Add("idTypeScope", this.Configuration.ApiClient.ParameterToString(idTypeScope)); // path parameter
            if (idTypeCode != null) localVarPathParams.Add("idTypeCode", this.Configuration.ApiClient.ParameterToString(idTypeCode)); // path parameter
            if (code != null) localVarPathParams.Add("code", this.Configuration.ApiClient.ParameterToString(code)); // path parameter
            if (effectiveAt != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "effectiveAt", effectiveAt)); // query parameter
            if (asAt != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "asAt", asAt)); // query parameter
            if (filter != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "filter", filter)); // query parameter
            if (identifierTypes != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "identifierTypes", identifierTypes)); // query parameter

            // authentication (oauth2) required
            // oauth required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            //  set the LUSID header
            localVarHeaderParams["X-LUSID-Sdk-Language"] = "C#";
            localVarHeaderParams["X-LUSID-Sdk-Version"] = "0.11.3417";

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetPersonRelations", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<ResourceListOfRelation>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => string.Join(",", x.Value)),
                (ResourceListOfRelation) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(ResourceListOfRelation)));
        }

        /// <summary>
        /// [EXPERIMENTAL] Get Relationships for Person Get relationships for the specified person.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person&#39;s identifier type.</param>
        /// <param name="idTypeCode">Code of the person&#39;s identifier type.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code. This together with stated identifier type uniquely              identifies the person.</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to get relationships. Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve relationships. Defaults to return the latest LUSID AsAt time if not specified. (optional)</param>
        /// <param name="filter">Expression to filter relationships. Users should provide null or empty string for this field until further notice. (optional)</param>
        /// <param name="identifierTypes">Identifiers types (as property keys) used for referencing Persons or Legal Entities. These take the format              {domain}/{scope}/{code} e.g. \&quot;Person/CompanyDetails/Role\&quot;. They must be from the \&quot;Person\&quot; or \&quot;LegalEntity\&quot; domain.              Only identifier types stated will be used to look up relevant entities in relationships. If not applicable, provide an empty array. (optional)</param>
        /// <returns>ResourceListOfRelationship</returns>
        public ResourceListOfRelationship GetPersonRelationships (string idTypeScope, string idTypeCode, string code, DateTimeOrCutLabel effectiveAt = null, DateTimeOffset? asAt = null, string filter = null, List<string> identifierTypes = null)
        {
             ApiResponse<ResourceListOfRelationship> localVarResponse = GetPersonRelationshipsWithHttpInfo(idTypeScope, idTypeCode, code, effectiveAt, asAt, filter, identifierTypes);
             return localVarResponse.Data;
        }

        /// <summary>
        /// [EXPERIMENTAL] Get Relationships for Person Get relationships for the specified person.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person&#39;s identifier type.</param>
        /// <param name="idTypeCode">Code of the person&#39;s identifier type.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code. This together with stated identifier type uniquely              identifies the person.</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to get relationships. Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve relationships. Defaults to return the latest LUSID AsAt time if not specified. (optional)</param>
        /// <param name="filter">Expression to filter relationships. Users should provide null or empty string for this field until further notice. (optional)</param>
        /// <param name="identifierTypes">Identifiers types (as property keys) used for referencing Persons or Legal Entities. These take the format              {domain}/{scope}/{code} e.g. \&quot;Person/CompanyDetails/Role\&quot;. They must be from the \&quot;Person\&quot; or \&quot;LegalEntity\&quot; domain.              Only identifier types stated will be used to look up relevant entities in relationships. If not applicable, provide an empty array. (optional)</param>
        /// <returns>ApiResponse of ResourceListOfRelationship</returns>
        public ApiResponse< ResourceListOfRelationship > GetPersonRelationshipsWithHttpInfo (string idTypeScope, string idTypeCode, string code, DateTimeOrCutLabel effectiveAt = null, DateTimeOffset? asAt = null, string filter = null, List<string> identifierTypes = null)
        {
            // verify the required parameter 'idTypeScope' is set
            if (idTypeScope == null)
                throw new ApiException(400, "Missing required parameter 'idTypeScope' when calling PersonsApi->GetPersonRelationships");
            // verify the required parameter 'idTypeCode' is set
            if (idTypeCode == null)
                throw new ApiException(400, "Missing required parameter 'idTypeCode' when calling PersonsApi->GetPersonRelationships");
            // verify the required parameter 'code' is set
            if (code == null)
                throw new ApiException(400, "Missing required parameter 'code' when calling PersonsApi->GetPersonRelationships");

            var localVarPath = "./api/persons/{idTypeScope}/{idTypeCode}/{code}/relationships";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "text/plain",
                "application/json",
                "text/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (idTypeScope != null) localVarPathParams.Add("idTypeScope", this.Configuration.ApiClient.ParameterToString(idTypeScope)); // path parameter
            if (idTypeCode != null) localVarPathParams.Add("idTypeCode", this.Configuration.ApiClient.ParameterToString(idTypeCode)); // path parameter
            if (code != null) localVarPathParams.Add("code", this.Configuration.ApiClient.ParameterToString(code)); // path parameter
            if (effectiveAt != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "effectiveAt", effectiveAt)); // query parameter
            if (asAt != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "asAt", asAt)); // query parameter
            if (filter != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "filter", filter)); // query parameter
            if (identifierTypes != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "identifierTypes", identifierTypes)); // query parameter

            // authentication (oauth2) required
            // oauth required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            //  set the LUSID header
            localVarHeaderParams["X-LUSID-SDK-Language"] = "C#";
            localVarHeaderParams["X-LUSID-SDK-Version"] = "0.11.3417";

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetPersonRelationships", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<ResourceListOfRelationship>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => string.Join(",", x.Value)),
                (ResourceListOfRelationship) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(ResourceListOfRelationship)));
        }

        /// <summary>
        /// [EXPERIMENTAL] Get Relationships for Person Get relationships for the specified person.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person&#39;s identifier type.</param>
        /// <param name="idTypeCode">Code of the person&#39;s identifier type.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code. This together with stated identifier type uniquely              identifies the person.</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to get relationships. Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve relationships. Defaults to return the latest LUSID AsAt time if not specified. (optional)</param>
        /// <param name="filter">Expression to filter relationships. Users should provide null or empty string for this field until further notice. (optional)</param>
        /// <param name="identifierTypes">Identifiers types (as property keys) used for referencing Persons or Legal Entities. These take the format              {domain}/{scope}/{code} e.g. \&quot;Person/CompanyDetails/Role\&quot;. They must be from the \&quot;Person\&quot; or \&quot;LegalEntity\&quot; domain.              Only identifier types stated will be used to look up relevant entities in relationships. If not applicable, provide an empty array. (optional)</param>
        /// <returns>Task of ResourceListOfRelationship</returns>
        public async System.Threading.Tasks.Task<ResourceListOfRelationship> GetPersonRelationshipsAsync (string idTypeScope, string idTypeCode, string code, DateTimeOrCutLabel effectiveAt = null, DateTimeOffset? asAt = null, string filter = null, List<string> identifierTypes = null)
        {
             ApiResponse<ResourceListOfRelationship> localVarResponse = await GetPersonRelationshipsAsyncWithHttpInfo(idTypeScope, idTypeCode, code, effectiveAt, asAt, filter, identifierTypes);
             return localVarResponse.Data;

        }

        /// <summary>
        /// [EXPERIMENTAL] Get Relationships for Person Get relationships for the specified person.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person&#39;s identifier type.</param>
        /// <param name="idTypeCode">Code of the person&#39;s identifier type.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code. This together with stated identifier type uniquely              identifies the person.</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to get relationships. Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve relationships. Defaults to return the latest LUSID AsAt time if not specified. (optional)</param>
        /// <param name="filter">Expression to filter relationships. Users should provide null or empty string for this field until further notice. (optional)</param>
        /// <param name="identifierTypes">Identifiers types (as property keys) used for referencing Persons or Legal Entities. These take the format              {domain}/{scope}/{code} e.g. \&quot;Person/CompanyDetails/Role\&quot;. They must be from the \&quot;Person\&quot; or \&quot;LegalEntity\&quot; domain.              Only identifier types stated will be used to look up relevant entities in relationships. If not applicable, provide an empty array. (optional)</param>
        /// <returns>Task of ApiResponse (ResourceListOfRelationship)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<ResourceListOfRelationship>> GetPersonRelationshipsAsyncWithHttpInfo (string idTypeScope, string idTypeCode, string code, DateTimeOrCutLabel effectiveAt = null, DateTimeOffset? asAt = null, string filter = null, List<string> identifierTypes = null)
        {
            // verify the required parameter 'idTypeScope' is set
            if (idTypeScope == null)
                throw new ApiException(400, "Missing required parameter 'idTypeScope' when calling PersonsApi->GetPersonRelationships");
            // verify the required parameter 'idTypeCode' is set
            if (idTypeCode == null)
                throw new ApiException(400, "Missing required parameter 'idTypeCode' when calling PersonsApi->GetPersonRelationships");
            // verify the required parameter 'code' is set
            if (code == null)
                throw new ApiException(400, "Missing required parameter 'code' when calling PersonsApi->GetPersonRelationships");

            var localVarPath = "./api/persons/{idTypeScope}/{idTypeCode}/{code}/relationships";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "text/plain",
                "application/json",
                "text/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (idTypeScope != null) localVarPathParams.Add("idTypeScope", this.Configuration.ApiClient.ParameterToString(idTypeScope)); // path parameter
            if (idTypeCode != null) localVarPathParams.Add("idTypeCode", this.Configuration.ApiClient.ParameterToString(idTypeCode)); // path parameter
            if (code != null) localVarPathParams.Add("code", this.Configuration.ApiClient.ParameterToString(code)); // path parameter
            if (effectiveAt != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "effectiveAt", effectiveAt)); // query parameter
            if (asAt != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "asAt", asAt)); // query parameter
            if (filter != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "filter", filter)); // query parameter
            if (identifierTypes != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "identifierTypes", identifierTypes)); // query parameter

            // authentication (oauth2) required
            // oauth required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            //  set the LUSID header
            localVarHeaderParams["X-LUSID-Sdk-Language"] = "C#";
            localVarHeaderParams["X-LUSID-Sdk-Version"] = "0.11.3417";

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetPersonRelationships", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<ResourceListOfRelationship>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => string.Join(",", x.Value)),
                (ResourceListOfRelationship) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(ResourceListOfRelationship)));
        }

        /// <summary>
        /// [EXPERIMENTAL] List Persons List persons which have identifiers of a specific identifier type&#39;s scope and code, and satisfies filter criteria.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier type.</param>
        /// <param name="idTypeCode">Code of the person identifier type.</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to list the people. Defaults to the current LUSID              system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to list the people. Defaults to return the latest version              of each people if not specified. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing portfolios from a previous call to list portfolios. This  value is returned from the previous call. If a pagination token is provided the filter, effectiveAt  and asAt fields must not have changed since the original request. Also, if set, a start value cannot be provided. (optional)</param>
        /// <param name="start">When paginating, skip this number of results. (optional)</param>
        /// <param name="limit">When paginating, limit the number of returned results to this many. Defaults to 65,535 if not specified. (optional)</param>
        /// <param name="filter">Expression to filter the result set.               For example, to filter on the LUPID, use \&quot;lusidPersonId eq &#39;string&#39;\&quot;              Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid. (optional)</param>
        /// <param name="propertyKeys">A list of property keys from the \&quot;Person\&quot; domain to decorate onto each person.              These take the format {domain}/{scope}/{code} e.g. \&quot;Person/ContactDetails/Address\&quot;. (optional)</param>
        /// <returns>PagedResourceListOfPerson</returns>
        public PagedResourceListOfPerson ListPersons (string idTypeScope, string idTypeCode, DateTimeOrCutLabel effectiveAt = null, DateTimeOffset? asAt = null, string page = null, int? start = null, int? limit = null, string filter = null, List<string> propertyKeys = null)
        {
             ApiResponse<PagedResourceListOfPerson> localVarResponse = ListPersonsWithHttpInfo(idTypeScope, idTypeCode, effectiveAt, asAt, page, start, limit, filter, propertyKeys);
             return localVarResponse.Data;
        }

        /// <summary>
        /// [EXPERIMENTAL] List Persons List persons which have identifiers of a specific identifier type&#39;s scope and code, and satisfies filter criteria.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier type.</param>
        /// <param name="idTypeCode">Code of the person identifier type.</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to list the people. Defaults to the current LUSID              system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to list the people. Defaults to return the latest version              of each people if not specified. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing portfolios from a previous call to list portfolios. This  value is returned from the previous call. If a pagination token is provided the filter, effectiveAt  and asAt fields must not have changed since the original request. Also, if set, a start value cannot be provided. (optional)</param>
        /// <param name="start">When paginating, skip this number of results. (optional)</param>
        /// <param name="limit">When paginating, limit the number of returned results to this many. Defaults to 65,535 if not specified. (optional)</param>
        /// <param name="filter">Expression to filter the result set.               For example, to filter on the LUPID, use \&quot;lusidPersonId eq &#39;string&#39;\&quot;              Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid. (optional)</param>
        /// <param name="propertyKeys">A list of property keys from the \&quot;Person\&quot; domain to decorate onto each person.              These take the format {domain}/{scope}/{code} e.g. \&quot;Person/ContactDetails/Address\&quot;. (optional)</param>
        /// <returns>ApiResponse of PagedResourceListOfPerson</returns>
        public ApiResponse< PagedResourceListOfPerson > ListPersonsWithHttpInfo (string idTypeScope, string idTypeCode, DateTimeOrCutLabel effectiveAt = null, DateTimeOffset? asAt = null, string page = null, int? start = null, int? limit = null, string filter = null, List<string> propertyKeys = null)
        {
            // verify the required parameter 'idTypeScope' is set
            if (idTypeScope == null)
                throw new ApiException(400, "Missing required parameter 'idTypeScope' when calling PersonsApi->ListPersons");
            // verify the required parameter 'idTypeCode' is set
            if (idTypeCode == null)
                throw new ApiException(400, "Missing required parameter 'idTypeCode' when calling PersonsApi->ListPersons");

            var localVarPath = "./api/persons/{idTypeScope}/{idTypeCode}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "text/plain",
                "application/json",
                "text/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (idTypeScope != null) localVarPathParams.Add("idTypeScope", this.Configuration.ApiClient.ParameterToString(idTypeScope)); // path parameter
            if (idTypeCode != null) localVarPathParams.Add("idTypeCode", this.Configuration.ApiClient.ParameterToString(idTypeCode)); // path parameter
            if (effectiveAt != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "effectiveAt", effectiveAt)); // query parameter
            if (asAt != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "asAt", asAt)); // query parameter
            if (page != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "page", page)); // query parameter
            if (start != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "start", start)); // query parameter
            if (limit != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "limit", limit)); // query parameter
            if (filter != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "filter", filter)); // query parameter
            if (propertyKeys != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "propertyKeys", propertyKeys)); // query parameter

            // authentication (oauth2) required
            // oauth required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            //  set the LUSID header
            localVarHeaderParams["X-LUSID-SDK-Language"] = "C#";
            localVarHeaderParams["X-LUSID-SDK-Version"] = "0.11.3417";

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ListPersons", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<PagedResourceListOfPerson>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => string.Join(",", x.Value)),
                (PagedResourceListOfPerson) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(PagedResourceListOfPerson)));
        }

        /// <summary>
        /// [EXPERIMENTAL] List Persons List persons which have identifiers of a specific identifier type&#39;s scope and code, and satisfies filter criteria.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier type.</param>
        /// <param name="idTypeCode">Code of the person identifier type.</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to list the people. Defaults to the current LUSID              system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to list the people. Defaults to return the latest version              of each people if not specified. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing portfolios from a previous call to list portfolios. This  value is returned from the previous call. If a pagination token is provided the filter, effectiveAt  and asAt fields must not have changed since the original request. Also, if set, a start value cannot be provided. (optional)</param>
        /// <param name="start">When paginating, skip this number of results. (optional)</param>
        /// <param name="limit">When paginating, limit the number of returned results to this many. Defaults to 65,535 if not specified. (optional)</param>
        /// <param name="filter">Expression to filter the result set.               For example, to filter on the LUPID, use \&quot;lusidPersonId eq &#39;string&#39;\&quot;              Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid. (optional)</param>
        /// <param name="propertyKeys">A list of property keys from the \&quot;Person\&quot; domain to decorate onto each person.              These take the format {domain}/{scope}/{code} e.g. \&quot;Person/ContactDetails/Address\&quot;. (optional)</param>
        /// <returns>Task of PagedResourceListOfPerson</returns>
        public async System.Threading.Tasks.Task<PagedResourceListOfPerson> ListPersonsAsync (string idTypeScope, string idTypeCode, DateTimeOrCutLabel effectiveAt = null, DateTimeOffset? asAt = null, string page = null, int? start = null, int? limit = null, string filter = null, List<string> propertyKeys = null)
        {
             ApiResponse<PagedResourceListOfPerson> localVarResponse = await ListPersonsAsyncWithHttpInfo(idTypeScope, idTypeCode, effectiveAt, asAt, page, start, limit, filter, propertyKeys);
             return localVarResponse.Data;

        }

        /// <summary>
        /// [EXPERIMENTAL] List Persons List persons which have identifiers of a specific identifier type&#39;s scope and code, and satisfies filter criteria.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier type.</param>
        /// <param name="idTypeCode">Code of the person identifier type.</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to list the people. Defaults to the current LUSID              system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to list the people. Defaults to return the latest version              of each people if not specified. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing portfolios from a previous call to list portfolios. This  value is returned from the previous call. If a pagination token is provided the filter, effectiveAt  and asAt fields must not have changed since the original request. Also, if set, a start value cannot be provided. (optional)</param>
        /// <param name="start">When paginating, skip this number of results. (optional)</param>
        /// <param name="limit">When paginating, limit the number of returned results to this many. Defaults to 65,535 if not specified. (optional)</param>
        /// <param name="filter">Expression to filter the result set.               For example, to filter on the LUPID, use \&quot;lusidPersonId eq &#39;string&#39;\&quot;              Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid. (optional)</param>
        /// <param name="propertyKeys">A list of property keys from the \&quot;Person\&quot; domain to decorate onto each person.              These take the format {domain}/{scope}/{code} e.g. \&quot;Person/ContactDetails/Address\&quot;. (optional)</param>
        /// <returns>Task of ApiResponse (PagedResourceListOfPerson)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<PagedResourceListOfPerson>> ListPersonsAsyncWithHttpInfo (string idTypeScope, string idTypeCode, DateTimeOrCutLabel effectiveAt = null, DateTimeOffset? asAt = null, string page = null, int? start = null, int? limit = null, string filter = null, List<string> propertyKeys = null)
        {
            // verify the required parameter 'idTypeScope' is set
            if (idTypeScope == null)
                throw new ApiException(400, "Missing required parameter 'idTypeScope' when calling PersonsApi->ListPersons");
            // verify the required parameter 'idTypeCode' is set
            if (idTypeCode == null)
                throw new ApiException(400, "Missing required parameter 'idTypeCode' when calling PersonsApi->ListPersons");

            var localVarPath = "./api/persons/{idTypeScope}/{idTypeCode}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "text/plain",
                "application/json",
                "text/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (idTypeScope != null) localVarPathParams.Add("idTypeScope", this.Configuration.ApiClient.ParameterToString(idTypeScope)); // path parameter
            if (idTypeCode != null) localVarPathParams.Add("idTypeCode", this.Configuration.ApiClient.ParameterToString(idTypeCode)); // path parameter
            if (effectiveAt != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "effectiveAt", effectiveAt)); // query parameter
            if (asAt != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "asAt", asAt)); // query parameter
            if (page != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "page", page)); // query parameter
            if (start != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "start", start)); // query parameter
            if (limit != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "limit", limit)); // query parameter
            if (filter != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "filter", filter)); // query parameter
            if (propertyKeys != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "propertyKeys", propertyKeys)); // query parameter

            // authentication (oauth2) required
            // oauth required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            //  set the LUSID header
            localVarHeaderParams["X-LUSID-Sdk-Language"] = "C#";
            localVarHeaderParams["X-LUSID-Sdk-Version"] = "0.11.3417";

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ListPersons", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<PagedResourceListOfPerson>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => string.Join(",", x.Value)),
                (PagedResourceListOfPerson) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(PagedResourceListOfPerson)));
        }

        /// <summary>
        /// [EXPERIMENTAL] Set Person Identifiers Set identifiers of the person.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier type.</param>
        /// <param name="idTypeCode">Code of the person identifier type.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code. This together with stated identifier type uniquely              identifies the person.</param>
        /// <param name="setPersonIdentifiersRequest">Request containing identifiers to set for the person. Identifiers not specified in request will not be changed.</param>
        /// <returns>Person</returns>
        public Person SetPersonIdentifiers (string idTypeScope, string idTypeCode, string code, SetPersonIdentifiersRequest setPersonIdentifiersRequest)
        {
             ApiResponse<Person> localVarResponse = SetPersonIdentifiersWithHttpInfo(idTypeScope, idTypeCode, code, setPersonIdentifiersRequest);
             return localVarResponse.Data;
        }

        /// <summary>
        /// [EXPERIMENTAL] Set Person Identifiers Set identifiers of the person.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier type.</param>
        /// <param name="idTypeCode">Code of the person identifier type.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code. This together with stated identifier type uniquely              identifies the person.</param>
        /// <param name="setPersonIdentifiersRequest">Request containing identifiers to set for the person. Identifiers not specified in request will not be changed.</param>
        /// <returns>ApiResponse of Person</returns>
        public ApiResponse< Person > SetPersonIdentifiersWithHttpInfo (string idTypeScope, string idTypeCode, string code, SetPersonIdentifiersRequest setPersonIdentifiersRequest)
        {
            // verify the required parameter 'idTypeScope' is set
            if (idTypeScope == null)
                throw new ApiException(400, "Missing required parameter 'idTypeScope' when calling PersonsApi->SetPersonIdentifiers");
            // verify the required parameter 'idTypeCode' is set
            if (idTypeCode == null)
                throw new ApiException(400, "Missing required parameter 'idTypeCode' when calling PersonsApi->SetPersonIdentifiers");
            // verify the required parameter 'code' is set
            if (code == null)
                throw new ApiException(400, "Missing required parameter 'code' when calling PersonsApi->SetPersonIdentifiers");
            // verify the required parameter 'setPersonIdentifiersRequest' is set
            if (setPersonIdentifiersRequest == null)
                throw new ApiException(400, "Missing required parameter 'setPersonIdentifiersRequest' when calling PersonsApi->SetPersonIdentifiers");

            var localVarPath = "./api/persons/{idTypeScope}/{idTypeCode}/{code}/identifiers";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json-patch+json", 
                "application/json", 
                "text/json", 
                "application/_*+json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "text/plain",
                "application/json",
                "text/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (idTypeScope != null) localVarPathParams.Add("idTypeScope", this.Configuration.ApiClient.ParameterToString(idTypeScope)); // path parameter
            if (idTypeCode != null) localVarPathParams.Add("idTypeCode", this.Configuration.ApiClient.ParameterToString(idTypeCode)); // path parameter
            if (code != null) localVarPathParams.Add("code", this.Configuration.ApiClient.ParameterToString(code)); // path parameter
            if (setPersonIdentifiersRequest != null && setPersonIdentifiersRequest.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(setPersonIdentifiersRequest); // http body (model) parameter
            }
            else
            {
                localVarPostBody = setPersonIdentifiersRequest; // byte array
            }

            // authentication (oauth2) required
            // oauth required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            //  set the LUSID header
            localVarHeaderParams["X-LUSID-SDK-Language"] = "C#";
            localVarHeaderParams["X-LUSID-SDK-Version"] = "0.11.3417";

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("SetPersonIdentifiers", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Person>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => string.Join(",", x.Value)),
                (Person) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(Person)));
        }

        /// <summary>
        /// [EXPERIMENTAL] Set Person Identifiers Set identifiers of the person.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier type.</param>
        /// <param name="idTypeCode">Code of the person identifier type.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code. This together with stated identifier type uniquely              identifies the person.</param>
        /// <param name="setPersonIdentifiersRequest">Request containing identifiers to set for the person. Identifiers not specified in request will not be changed.</param>
        /// <returns>Task of Person</returns>
        public async System.Threading.Tasks.Task<Person> SetPersonIdentifiersAsync (string idTypeScope, string idTypeCode, string code, SetPersonIdentifiersRequest setPersonIdentifiersRequest)
        {
             ApiResponse<Person> localVarResponse = await SetPersonIdentifiersAsyncWithHttpInfo(idTypeScope, idTypeCode, code, setPersonIdentifiersRequest);
             return localVarResponse.Data;

        }

        /// <summary>
        /// [EXPERIMENTAL] Set Person Identifiers Set identifiers of the person.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier type.</param>
        /// <param name="idTypeCode">Code of the person identifier type.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code. This together with stated identifier type uniquely              identifies the person.</param>
        /// <param name="setPersonIdentifiersRequest">Request containing identifiers to set for the person. Identifiers not specified in request will not be changed.</param>
        /// <returns>Task of ApiResponse (Person)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Person>> SetPersonIdentifiersAsyncWithHttpInfo (string idTypeScope, string idTypeCode, string code, SetPersonIdentifiersRequest setPersonIdentifiersRequest)
        {
            // verify the required parameter 'idTypeScope' is set
            if (idTypeScope == null)
                throw new ApiException(400, "Missing required parameter 'idTypeScope' when calling PersonsApi->SetPersonIdentifiers");
            // verify the required parameter 'idTypeCode' is set
            if (idTypeCode == null)
                throw new ApiException(400, "Missing required parameter 'idTypeCode' when calling PersonsApi->SetPersonIdentifiers");
            // verify the required parameter 'code' is set
            if (code == null)
                throw new ApiException(400, "Missing required parameter 'code' when calling PersonsApi->SetPersonIdentifiers");
            // verify the required parameter 'setPersonIdentifiersRequest' is set
            if (setPersonIdentifiersRequest == null)
                throw new ApiException(400, "Missing required parameter 'setPersonIdentifiersRequest' when calling PersonsApi->SetPersonIdentifiers");

            var localVarPath = "./api/persons/{idTypeScope}/{idTypeCode}/{code}/identifiers";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json-patch+json", 
                "application/json", 
                "text/json", 
                "application/_*+json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "text/plain",
                "application/json",
                "text/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (idTypeScope != null) localVarPathParams.Add("idTypeScope", this.Configuration.ApiClient.ParameterToString(idTypeScope)); // path parameter
            if (idTypeCode != null) localVarPathParams.Add("idTypeCode", this.Configuration.ApiClient.ParameterToString(idTypeCode)); // path parameter
            if (code != null) localVarPathParams.Add("code", this.Configuration.ApiClient.ParameterToString(code)); // path parameter
            if (setPersonIdentifiersRequest != null && setPersonIdentifiersRequest.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(setPersonIdentifiersRequest); // http body (model) parameter
            }
            else
            {
                localVarPostBody = setPersonIdentifiersRequest; // byte array
            }

            // authentication (oauth2) required
            // oauth required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            //  set the LUSID header
            localVarHeaderParams["X-LUSID-Sdk-Language"] = "C#";
            localVarHeaderParams["X-LUSID-Sdk-Version"] = "0.11.3417";

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("SetPersonIdentifiers", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Person>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => string.Join(",", x.Value)),
                (Person) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(Person)));
        }

        /// <summary>
        /// [EXPERIMENTAL] Set Person Properties Set properties of the person.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier type.</param>
        /// <param name="idTypeCode">Code of the person identifier type.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code. This together with stated identifier type uniquely              identifies the person.</param>
        /// <param name="setPersonPropertiesRequest">Request containing properties to set for the person. Properties not specified in request will not be changed.</param>
        /// <returns>Person</returns>
        public Person SetPersonProperties (string idTypeScope, string idTypeCode, string code, SetPersonPropertiesRequest setPersonPropertiesRequest)
        {
             ApiResponse<Person> localVarResponse = SetPersonPropertiesWithHttpInfo(idTypeScope, idTypeCode, code, setPersonPropertiesRequest);
             return localVarResponse.Data;
        }

        /// <summary>
        /// [EXPERIMENTAL] Set Person Properties Set properties of the person.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier type.</param>
        /// <param name="idTypeCode">Code of the person identifier type.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code. This together with stated identifier type uniquely              identifies the person.</param>
        /// <param name="setPersonPropertiesRequest">Request containing properties to set for the person. Properties not specified in request will not be changed.</param>
        /// <returns>ApiResponse of Person</returns>
        public ApiResponse< Person > SetPersonPropertiesWithHttpInfo (string idTypeScope, string idTypeCode, string code, SetPersonPropertiesRequest setPersonPropertiesRequest)
        {
            // verify the required parameter 'idTypeScope' is set
            if (idTypeScope == null)
                throw new ApiException(400, "Missing required parameter 'idTypeScope' when calling PersonsApi->SetPersonProperties");
            // verify the required parameter 'idTypeCode' is set
            if (idTypeCode == null)
                throw new ApiException(400, "Missing required parameter 'idTypeCode' when calling PersonsApi->SetPersonProperties");
            // verify the required parameter 'code' is set
            if (code == null)
                throw new ApiException(400, "Missing required parameter 'code' when calling PersonsApi->SetPersonProperties");
            // verify the required parameter 'setPersonPropertiesRequest' is set
            if (setPersonPropertiesRequest == null)
                throw new ApiException(400, "Missing required parameter 'setPersonPropertiesRequest' when calling PersonsApi->SetPersonProperties");

            var localVarPath = "./api/persons/{idTypeScope}/{idTypeCode}/{code}/properties";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json-patch+json", 
                "application/json", 
                "text/json", 
                "application/_*+json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "text/plain",
                "application/json",
                "text/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (idTypeScope != null) localVarPathParams.Add("idTypeScope", this.Configuration.ApiClient.ParameterToString(idTypeScope)); // path parameter
            if (idTypeCode != null) localVarPathParams.Add("idTypeCode", this.Configuration.ApiClient.ParameterToString(idTypeCode)); // path parameter
            if (code != null) localVarPathParams.Add("code", this.Configuration.ApiClient.ParameterToString(code)); // path parameter
            if (setPersonPropertiesRequest != null && setPersonPropertiesRequest.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(setPersonPropertiesRequest); // http body (model) parameter
            }
            else
            {
                localVarPostBody = setPersonPropertiesRequest; // byte array
            }

            // authentication (oauth2) required
            // oauth required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            //  set the LUSID header
            localVarHeaderParams["X-LUSID-SDK-Language"] = "C#";
            localVarHeaderParams["X-LUSID-SDK-Version"] = "0.11.3417";

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("SetPersonProperties", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Person>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => string.Join(",", x.Value)),
                (Person) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(Person)));
        }

        /// <summary>
        /// [EXPERIMENTAL] Set Person Properties Set properties of the person.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier type.</param>
        /// <param name="idTypeCode">Code of the person identifier type.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code. This together with stated identifier type uniquely              identifies the person.</param>
        /// <param name="setPersonPropertiesRequest">Request containing properties to set for the person. Properties not specified in request will not be changed.</param>
        /// <returns>Task of Person</returns>
        public async System.Threading.Tasks.Task<Person> SetPersonPropertiesAsync (string idTypeScope, string idTypeCode, string code, SetPersonPropertiesRequest setPersonPropertiesRequest)
        {
             ApiResponse<Person> localVarResponse = await SetPersonPropertiesAsyncWithHttpInfo(idTypeScope, idTypeCode, code, setPersonPropertiesRequest);
             return localVarResponse.Data;

        }

        /// <summary>
        /// [EXPERIMENTAL] Set Person Properties Set properties of the person.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier type.</param>
        /// <param name="idTypeCode">Code of the person identifier type.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code. This together with stated identifier type uniquely              identifies the person.</param>
        /// <param name="setPersonPropertiesRequest">Request containing properties to set for the person. Properties not specified in request will not be changed.</param>
        /// <returns>Task of ApiResponse (Person)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Person>> SetPersonPropertiesAsyncWithHttpInfo (string idTypeScope, string idTypeCode, string code, SetPersonPropertiesRequest setPersonPropertiesRequest)
        {
            // verify the required parameter 'idTypeScope' is set
            if (idTypeScope == null)
                throw new ApiException(400, "Missing required parameter 'idTypeScope' when calling PersonsApi->SetPersonProperties");
            // verify the required parameter 'idTypeCode' is set
            if (idTypeCode == null)
                throw new ApiException(400, "Missing required parameter 'idTypeCode' when calling PersonsApi->SetPersonProperties");
            // verify the required parameter 'code' is set
            if (code == null)
                throw new ApiException(400, "Missing required parameter 'code' when calling PersonsApi->SetPersonProperties");
            // verify the required parameter 'setPersonPropertiesRequest' is set
            if (setPersonPropertiesRequest == null)
                throw new ApiException(400, "Missing required parameter 'setPersonPropertiesRequest' when calling PersonsApi->SetPersonProperties");

            var localVarPath = "./api/persons/{idTypeScope}/{idTypeCode}/{code}/properties";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json-patch+json", 
                "application/json", 
                "text/json", 
                "application/_*+json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "text/plain",
                "application/json",
                "text/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (idTypeScope != null) localVarPathParams.Add("idTypeScope", this.Configuration.ApiClient.ParameterToString(idTypeScope)); // path parameter
            if (idTypeCode != null) localVarPathParams.Add("idTypeCode", this.Configuration.ApiClient.ParameterToString(idTypeCode)); // path parameter
            if (code != null) localVarPathParams.Add("code", this.Configuration.ApiClient.ParameterToString(code)); // path parameter
            if (setPersonPropertiesRequest != null && setPersonPropertiesRequest.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(setPersonPropertiesRequest); // http body (model) parameter
            }
            else
            {
                localVarPostBody = setPersonPropertiesRequest; // byte array
            }

            // authentication (oauth2) required
            // oauth required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            //  set the LUSID header
            localVarHeaderParams["X-LUSID-Sdk-Language"] = "C#";
            localVarHeaderParams["X-LUSID-Sdk-Version"] = "0.11.3417";

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("SetPersonProperties", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Person>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => string.Join(",", x.Value)),
                (Person) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(Person)));
        }

        /// <summary>
        /// [EXPERIMENTAL] Upsert Person Create or update a new person under the specified scope.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="upsertPersonRequest">Request to create or update a person.</param>
        /// <returns>Person</returns>
        public Person UpsertPerson (UpsertPersonRequest upsertPersonRequest)
        {
             ApiResponse<Person> localVarResponse = UpsertPersonWithHttpInfo(upsertPersonRequest);
             return localVarResponse.Data;
        }

        /// <summary>
        /// [EXPERIMENTAL] Upsert Person Create or update a new person under the specified scope.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="upsertPersonRequest">Request to create or update a person.</param>
        /// <returns>ApiResponse of Person</returns>
        public ApiResponse< Person > UpsertPersonWithHttpInfo (UpsertPersonRequest upsertPersonRequest)
        {
            // verify the required parameter 'upsertPersonRequest' is set
            if (upsertPersonRequest == null)
                throw new ApiException(400, "Missing required parameter 'upsertPersonRequest' when calling PersonsApi->UpsertPerson");

            var localVarPath = "./api/persons";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json-patch+json", 
                "application/json", 
                "text/json", 
                "application/_*+json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "text/plain",
                "application/json",
                "text/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (upsertPersonRequest != null && upsertPersonRequest.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(upsertPersonRequest); // http body (model) parameter
            }
            else
            {
                localVarPostBody = upsertPersonRequest; // byte array
            }

            // authentication (oauth2) required
            // oauth required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            //  set the LUSID header
            localVarHeaderParams["X-LUSID-SDK-Language"] = "C#";
            localVarHeaderParams["X-LUSID-SDK-Version"] = "0.11.3417";

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpsertPerson", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Person>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => string.Join(",", x.Value)),
                (Person) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(Person)));
        }

        /// <summary>
        /// [EXPERIMENTAL] Upsert Person Create or update a new person under the specified scope.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="upsertPersonRequest">Request to create or update a person.</param>
        /// <returns>Task of Person</returns>
        public async System.Threading.Tasks.Task<Person> UpsertPersonAsync (UpsertPersonRequest upsertPersonRequest)
        {
             ApiResponse<Person> localVarResponse = await UpsertPersonAsyncWithHttpInfo(upsertPersonRequest);
             return localVarResponse.Data;

        }

        /// <summary>
        /// [EXPERIMENTAL] Upsert Person Create or update a new person under the specified scope.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="upsertPersonRequest">Request to create or update a person.</param>
        /// <returns>Task of ApiResponse (Person)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Person>> UpsertPersonAsyncWithHttpInfo (UpsertPersonRequest upsertPersonRequest)
        {
            // verify the required parameter 'upsertPersonRequest' is set
            if (upsertPersonRequest == null)
                throw new ApiException(400, "Missing required parameter 'upsertPersonRequest' when calling PersonsApi->UpsertPerson");

            var localVarPath = "./api/persons";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json-patch+json", 
                "application/json", 
                "text/json", 
                "application/_*+json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "text/plain",
                "application/json",
                "text/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (upsertPersonRequest != null && upsertPersonRequest.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(upsertPersonRequest); // http body (model) parameter
            }
            else
            {
                localVarPostBody = upsertPersonRequest; // byte array
            }

            // authentication (oauth2) required
            // oauth required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            //  set the LUSID header
            localVarHeaderParams["X-LUSID-Sdk-Language"] = "C#";
            localVarHeaderParams["X-LUSID-Sdk-Version"] = "0.11.3417";

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpsertPerson", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Person>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => string.Join(",", x.Value)),
                (Person) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(Person)));
        }

        /// <summary>
        /// [EXPERIMENTAL] Upsert a Person Access Metadata entry associated with a specific metadataKey. This creates or updates the data in LUSID. Update or insert one Person Access Metadata entry in a single scope. An item will be updated if it already exists  and inserted if it does not.                The response will return the successfully updated or inserted Person Access Metadata rule or failure message if unsuccessful.                It is important to always check to verify success (or failure).                Multiple rules for a metadataKey can exist with different effective at dates, when resources are accessed the rule that is active for the current time will be fetched.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier.</param>
        /// <param name="idTypeCode">Code of the person identifier.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code.</param>
        /// <param name="metadataKey">Key of the metadata entry to retrieve</param>
        /// <param name="upsertPersonAccessMetadataRequest">The Person Access Metadata entry to upsert</param>
        /// <param name="effectiveAt">The effectiveAt datetime at which to upsert the Access Metadata (optional)</param>
        /// <returns>ResourceListOfAccessMetadataValueOf</returns>
        public ResourceListOfAccessMetadataValueOf UpsertPersonAccessMetadata (string idTypeScope, string idTypeCode, string code, string metadataKey, UpsertPersonAccessMetadataRequest upsertPersonAccessMetadataRequest, DateTimeOrCutLabel effectiveAt = null)
        {
             ApiResponse<ResourceListOfAccessMetadataValueOf> localVarResponse = UpsertPersonAccessMetadataWithHttpInfo(idTypeScope, idTypeCode, code, metadataKey, upsertPersonAccessMetadataRequest, effectiveAt);
             return localVarResponse.Data;
        }

        /// <summary>
        /// [EXPERIMENTAL] Upsert a Person Access Metadata entry associated with a specific metadataKey. This creates or updates the data in LUSID. Update or insert one Person Access Metadata entry in a single scope. An item will be updated if it already exists  and inserted if it does not.                The response will return the successfully updated or inserted Person Access Metadata rule or failure message if unsuccessful.                It is important to always check to verify success (or failure).                Multiple rules for a metadataKey can exist with different effective at dates, when resources are accessed the rule that is active for the current time will be fetched.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier.</param>
        /// <param name="idTypeCode">Code of the person identifier.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code.</param>
        /// <param name="metadataKey">Key of the metadata entry to retrieve</param>
        /// <param name="upsertPersonAccessMetadataRequest">The Person Access Metadata entry to upsert</param>
        /// <param name="effectiveAt">The effectiveAt datetime at which to upsert the Access Metadata (optional)</param>
        /// <returns>ApiResponse of ResourceListOfAccessMetadataValueOf</returns>
        public ApiResponse< ResourceListOfAccessMetadataValueOf > UpsertPersonAccessMetadataWithHttpInfo (string idTypeScope, string idTypeCode, string code, string metadataKey, UpsertPersonAccessMetadataRequest upsertPersonAccessMetadataRequest, DateTimeOrCutLabel effectiveAt = null)
        {
            // verify the required parameter 'idTypeScope' is set
            if (idTypeScope == null)
                throw new ApiException(400, "Missing required parameter 'idTypeScope' when calling PersonsApi->UpsertPersonAccessMetadata");
            // verify the required parameter 'idTypeCode' is set
            if (idTypeCode == null)
                throw new ApiException(400, "Missing required parameter 'idTypeCode' when calling PersonsApi->UpsertPersonAccessMetadata");
            // verify the required parameter 'code' is set
            if (code == null)
                throw new ApiException(400, "Missing required parameter 'code' when calling PersonsApi->UpsertPersonAccessMetadata");
            // verify the required parameter 'metadataKey' is set
            if (metadataKey == null)
                throw new ApiException(400, "Missing required parameter 'metadataKey' when calling PersonsApi->UpsertPersonAccessMetadata");
            // verify the required parameter 'upsertPersonAccessMetadataRequest' is set
            if (upsertPersonAccessMetadataRequest == null)
                throw new ApiException(400, "Missing required parameter 'upsertPersonAccessMetadataRequest' when calling PersonsApi->UpsertPersonAccessMetadata");

            var localVarPath = "./api/persons/{idTypeScope}/{idTypeCode}/{code}/metadata/{metadataKey}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json-patch+json", 
                "application/json", 
                "text/json", 
                "application/_*+json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "text/plain",
                "application/json",
                "text/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (idTypeScope != null) localVarPathParams.Add("idTypeScope", this.Configuration.ApiClient.ParameterToString(idTypeScope)); // path parameter
            if (idTypeCode != null) localVarPathParams.Add("idTypeCode", this.Configuration.ApiClient.ParameterToString(idTypeCode)); // path parameter
            if (code != null) localVarPathParams.Add("code", this.Configuration.ApiClient.ParameterToString(code)); // path parameter
            if (metadataKey != null) localVarPathParams.Add("metadataKey", this.Configuration.ApiClient.ParameterToString(metadataKey)); // path parameter
            if (effectiveAt != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "effectiveAt", effectiveAt)); // query parameter
            if (upsertPersonAccessMetadataRequest != null && upsertPersonAccessMetadataRequest.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(upsertPersonAccessMetadataRequest); // http body (model) parameter
            }
            else
            {
                localVarPostBody = upsertPersonAccessMetadataRequest; // byte array
            }

            // authentication (oauth2) required
            // oauth required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            //  set the LUSID header
            localVarHeaderParams["X-LUSID-SDK-Language"] = "C#";
            localVarHeaderParams["X-LUSID-SDK-Version"] = "0.11.3417";

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpsertPersonAccessMetadata", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<ResourceListOfAccessMetadataValueOf>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => string.Join(",", x.Value)),
                (ResourceListOfAccessMetadataValueOf) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(ResourceListOfAccessMetadataValueOf)));
        }

        /// <summary>
        /// [EXPERIMENTAL] Upsert a Person Access Metadata entry associated with a specific metadataKey. This creates or updates the data in LUSID. Update or insert one Person Access Metadata entry in a single scope. An item will be updated if it already exists  and inserted if it does not.                The response will return the successfully updated or inserted Person Access Metadata rule or failure message if unsuccessful.                It is important to always check to verify success (or failure).                Multiple rules for a metadataKey can exist with different effective at dates, when resources are accessed the rule that is active for the current time will be fetched.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier.</param>
        /// <param name="idTypeCode">Code of the person identifier.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code.</param>
        /// <param name="metadataKey">Key of the metadata entry to retrieve</param>
        /// <param name="upsertPersonAccessMetadataRequest">The Person Access Metadata entry to upsert</param>
        /// <param name="effectiveAt">The effectiveAt datetime at which to upsert the Access Metadata (optional)</param>
        /// <returns>Task of ResourceListOfAccessMetadataValueOf</returns>
        public async System.Threading.Tasks.Task<ResourceListOfAccessMetadataValueOf> UpsertPersonAccessMetadataAsync (string idTypeScope, string idTypeCode, string code, string metadataKey, UpsertPersonAccessMetadataRequest upsertPersonAccessMetadataRequest, DateTimeOrCutLabel effectiveAt = null)
        {
             ApiResponse<ResourceListOfAccessMetadataValueOf> localVarResponse = await UpsertPersonAccessMetadataAsyncWithHttpInfo(idTypeScope, idTypeCode, code, metadataKey, upsertPersonAccessMetadataRequest, effectiveAt);
             return localVarResponse.Data;

        }

        /// <summary>
        /// [EXPERIMENTAL] Upsert a Person Access Metadata entry associated with a specific metadataKey. This creates or updates the data in LUSID. Update or insert one Person Access Metadata entry in a single scope. An item will be updated if it already exists  and inserted if it does not.                The response will return the successfully updated or inserted Person Access Metadata rule or failure message if unsuccessful.                It is important to always check to verify success (or failure).                Multiple rules for a metadataKey can exist with different effective at dates, when resources are accessed the rule that is active for the current time will be fetched.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="idTypeScope">Scope of the person identifier.</param>
        /// <param name="idTypeCode">Code of the person identifier.</param>
        /// <param name="code">Code of the person under specified identifier type&#39;s scope and code.</param>
        /// <param name="metadataKey">Key of the metadata entry to retrieve</param>
        /// <param name="upsertPersonAccessMetadataRequest">The Person Access Metadata entry to upsert</param>
        /// <param name="effectiveAt">The effectiveAt datetime at which to upsert the Access Metadata (optional)</param>
        /// <returns>Task of ApiResponse (ResourceListOfAccessMetadataValueOf)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<ResourceListOfAccessMetadataValueOf>> UpsertPersonAccessMetadataAsyncWithHttpInfo (string idTypeScope, string idTypeCode, string code, string metadataKey, UpsertPersonAccessMetadataRequest upsertPersonAccessMetadataRequest, DateTimeOrCutLabel effectiveAt = null)
        {
            // verify the required parameter 'idTypeScope' is set
            if (idTypeScope == null)
                throw new ApiException(400, "Missing required parameter 'idTypeScope' when calling PersonsApi->UpsertPersonAccessMetadata");
            // verify the required parameter 'idTypeCode' is set
            if (idTypeCode == null)
                throw new ApiException(400, "Missing required parameter 'idTypeCode' when calling PersonsApi->UpsertPersonAccessMetadata");
            // verify the required parameter 'code' is set
            if (code == null)
                throw new ApiException(400, "Missing required parameter 'code' when calling PersonsApi->UpsertPersonAccessMetadata");
            // verify the required parameter 'metadataKey' is set
            if (metadataKey == null)
                throw new ApiException(400, "Missing required parameter 'metadataKey' when calling PersonsApi->UpsertPersonAccessMetadata");
            // verify the required parameter 'upsertPersonAccessMetadataRequest' is set
            if (upsertPersonAccessMetadataRequest == null)
                throw new ApiException(400, "Missing required parameter 'upsertPersonAccessMetadataRequest' when calling PersonsApi->UpsertPersonAccessMetadata");

            var localVarPath = "./api/persons/{idTypeScope}/{idTypeCode}/{code}/metadata/{metadataKey}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json-patch+json", 
                "application/json", 
                "text/json", 
                "application/_*+json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "text/plain",
                "application/json",
                "text/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (idTypeScope != null) localVarPathParams.Add("idTypeScope", this.Configuration.ApiClient.ParameterToString(idTypeScope)); // path parameter
            if (idTypeCode != null) localVarPathParams.Add("idTypeCode", this.Configuration.ApiClient.ParameterToString(idTypeCode)); // path parameter
            if (code != null) localVarPathParams.Add("code", this.Configuration.ApiClient.ParameterToString(code)); // path parameter
            if (metadataKey != null) localVarPathParams.Add("metadataKey", this.Configuration.ApiClient.ParameterToString(metadataKey)); // path parameter
            if (effectiveAt != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "effectiveAt", effectiveAt)); // query parameter
            if (upsertPersonAccessMetadataRequest != null && upsertPersonAccessMetadataRequest.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(upsertPersonAccessMetadataRequest); // http body (model) parameter
            }
            else
            {
                localVarPostBody = upsertPersonAccessMetadataRequest; // byte array
            }

            // authentication (oauth2) required
            // oauth required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            //  set the LUSID header
            localVarHeaderParams["X-LUSID-Sdk-Language"] = "C#";
            localVarHeaderParams["X-LUSID-Sdk-Version"] = "0.11.3417";

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpsertPersonAccessMetadata", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<ResourceListOfAccessMetadataValueOf>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => string.Join(",", x.Value)),
                (ResourceListOfAccessMetadataValueOf) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(ResourceListOfAccessMetadataValueOf)));
        }

    }
}