/* 
 * LUSID API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.10.1388
 * Contact: info@finbourne.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using RestSharp.Portable;
using Lusid.Sdk.Client;
using Lusid.Sdk.Model;

namespace Lusid.Sdk.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IQuotesApi : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// [EXPERIMENTAL] Delete a Quote Access Metadata Rule
        /// </summary>
        /// <remarks>
        /// Delete the Quote Access Metadata Rule that exactly matches the provided identifier parts
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the Quote Access Metadata Rule to retrieve.</param>
        /// <param name="provider">The Provider of the rule (optional)</param>
        /// <param name="priceSource">The PriceSource of the rule (optional)</param>
        /// <param name="instrumentIdType">The InstrumentIdType of the rule (optional)</param>
        /// <param name="instrumentId">The InstrumentId of the rule (optional)</param>
        /// <param name="quoteType">The QuoteType of the rule (optional)</param>
        /// <param name="field">The Field of the rule (optional)</param>
        /// <param name="effectiveAt">The effective date to delete at, if this is not supplied, it will delete all data found (optional)</param>
        /// <returns>QuoteAccessMetadataRule</returns>
        QuoteAccessMetadataRule DeleteQuoteAcccesMetadataRule (string scope, string provider = null, string priceSource = null, string instrumentIdType = null, string instrumentId = null, string quoteType = null, string field = null, DateTimeOrCutLabel effectiveAt = null);

        /// <summary>
        /// [EXPERIMENTAL] Delete a Quote Access Metadata Rule
        /// </summary>
        /// <remarks>
        /// Delete the Quote Access Metadata Rule that exactly matches the provided identifier parts
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the Quote Access Metadata Rule to retrieve.</param>
        /// <param name="provider">The Provider of the rule (optional)</param>
        /// <param name="priceSource">The PriceSource of the rule (optional)</param>
        /// <param name="instrumentIdType">The InstrumentIdType of the rule (optional)</param>
        /// <param name="instrumentId">The InstrumentId of the rule (optional)</param>
        /// <param name="quoteType">The QuoteType of the rule (optional)</param>
        /// <param name="field">The Field of the rule (optional)</param>
        /// <param name="effectiveAt">The effective date to delete at, if this is not supplied, it will delete all data found (optional)</param>
        /// <returns>ApiResponse of QuoteAccessMetadataRule</returns>
        ApiResponse<QuoteAccessMetadataRule> DeleteQuoteAcccesMetadataRuleWithHttpInfo (string scope, string provider = null, string priceSource = null, string instrumentIdType = null, string instrumentId = null, string quoteType = null, string field = null, DateTimeOrCutLabel effectiveAt = null);
        /// <summary>
        /// [BETA] Delete quotes
        /// </summary>
        /// <remarks>
        /// Delete one or more specified quotes from a single scope. A quote is identified by its unique id which includes information about  the type of quote as well as the exact effective datetime (to the microsecond) from which it became valid.                In the request each quote must be keyed by a unique correlation id. This id is ephemeral and is not stored by LUSID.  It serves only as a way to easily identify each quote in the response.                The response will return both the collection of successfully deleted quotes, as well as those that failed.  For the failures a reason will be provided explaining why the quote could not be deleted.                It is important to always check the failed set for any unsuccessful results.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the quotes to delete.</param>
        /// <param name="quotes">The quotes to delete keyed by a unique correlation id. (optional)</param>
        /// <returns>AnnulQuotesResponse</returns>
        AnnulQuotesResponse DeleteQuotes (string scope, Dictionary<string, QuoteId> quotes = null);

        /// <summary>
        /// [BETA] Delete quotes
        /// </summary>
        /// <remarks>
        /// Delete one or more specified quotes from a single scope. A quote is identified by its unique id which includes information about  the type of quote as well as the exact effective datetime (to the microsecond) from which it became valid.                In the request each quote must be keyed by a unique correlation id. This id is ephemeral and is not stored by LUSID.  It serves only as a way to easily identify each quote in the response.                The response will return both the collection of successfully deleted quotes, as well as those that failed.  For the failures a reason will be provided explaining why the quote could not be deleted.                It is important to always check the failed set for any unsuccessful results.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the quotes to delete.</param>
        /// <param name="quotes">The quotes to delete keyed by a unique correlation id. (optional)</param>
        /// <returns>ApiResponse of AnnulQuotesResponse</returns>
        ApiResponse<AnnulQuotesResponse> DeleteQuotesWithHttpInfo (string scope, Dictionary<string, QuoteId> quotes = null);
        /// <summary>
        /// [BETA] Get quotes
        /// </summary>
        /// <remarks>
        /// Get one or more quotes from a single scope.                Each quote can be identified by its time invariant quote series id.                For each quote series id LUSID will return the most recent quote with respect to the provided (or default) effective datetime.                 An optional maximum age range window can be specified which defines how far back to look back for a quote from the specified effective datetime.  LUSID will return the most recent quote within this window.                In the request each quote series id must be keyed by a unique correlation id. This id is ephemeral and is not stored by LUSID.  It serves only as a way to easily identify each quote in the response.                The response will return three collections. One, the successfully retrieved quotes. Two, those that had a  valid quote series id but could not be found. Three, those that failed because LUSID could not construct a valid quote series id from the request.    For the quotes that failed or could not be found a reason will be provided explaining why the quote could not be retrieved.                It is important to always check the failed and not found sets for any unsuccessful results.  The maximum number of quotes that this method can get per request is 2,000.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the quotes to retrieve.</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to retrieve the quotes. Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the quotes. Defaults to return the latest version of each quote if not specified. (optional)</param>
        /// <param name="maxAge">The duration of the look back window in an ISO8601 time interval format e.g. P1Y2M3DT4H30M (1 year, 2 months, 3 days, 4 hours and 30 minutes).               This is subtracted from the provided effectiveAt datetime or cut label to generate a effective datetime window inside which a quote must exist to be retrieved. (optional)</param>
        /// <param name="quoteIds">The time invariant quote series ids of the quotes to retrieve. These need to be               keyed by a unique correlation id allowing the retrieved quote to be identified in the response. (optional)</param>
        /// <returns>GetQuotesResponse</returns>
        GetQuotesResponse GetQuotes (string scope, DateTimeOrCutLabel effectiveAt = null, DateTimeOffset? asAt = null, string maxAge = null, Dictionary<string, QuoteSeriesId> quoteIds = null);

        /// <summary>
        /// [BETA] Get quotes
        /// </summary>
        /// <remarks>
        /// Get one or more quotes from a single scope.                Each quote can be identified by its time invariant quote series id.                For each quote series id LUSID will return the most recent quote with respect to the provided (or default) effective datetime.                 An optional maximum age range window can be specified which defines how far back to look back for a quote from the specified effective datetime.  LUSID will return the most recent quote within this window.                In the request each quote series id must be keyed by a unique correlation id. This id is ephemeral and is not stored by LUSID.  It serves only as a way to easily identify each quote in the response.                The response will return three collections. One, the successfully retrieved quotes. Two, those that had a  valid quote series id but could not be found. Three, those that failed because LUSID could not construct a valid quote series id from the request.    For the quotes that failed or could not be found a reason will be provided explaining why the quote could not be retrieved.                It is important to always check the failed and not found sets for any unsuccessful results.  The maximum number of quotes that this method can get per request is 2,000.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the quotes to retrieve.</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to retrieve the quotes. Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the quotes. Defaults to return the latest version of each quote if not specified. (optional)</param>
        /// <param name="maxAge">The duration of the look back window in an ISO8601 time interval format e.g. P1Y2M3DT4H30M (1 year, 2 months, 3 days, 4 hours and 30 minutes).               This is subtracted from the provided effectiveAt datetime or cut label to generate a effective datetime window inside which a quote must exist to be retrieved. (optional)</param>
        /// <param name="quoteIds">The time invariant quote series ids of the quotes to retrieve. These need to be               keyed by a unique correlation id allowing the retrieved quote to be identified in the response. (optional)</param>
        /// <returns>ApiResponse of GetQuotesResponse</returns>
        ApiResponse<GetQuotesResponse> GetQuotesWithHttpInfo (string scope, DateTimeOrCutLabel effectiveAt = null, DateTimeOffset? asAt = null, string maxAge = null, Dictionary<string, QuoteSeriesId> quoteIds = null);
        /// <summary>
        /// [EXPERIMENTAL] Get a quote access metadata rule
        /// </summary>
        /// <remarks>
        /// Get a specific quote access metadata rule by specifying the corresponding identifier parts                No matching will be performed through this endpoint. To retrieve a rule, it is necessary to specify, exactly, the identifier of the rule
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the Quote Access Metadata Rule to retrieve.</param>
        /// <param name="provider">The Provider of the rule (optional)</param>
        /// <param name="priceSource">The PriceSource of the rule (optional)</param>
        /// <param name="instrumentIdType">The InstrumentIdType of the rule (optional)</param>
        /// <param name="instrumentId">The InstrumentId of the rule (optional)</param>
        /// <param name="quoteType">The QuoteType of the rule (optional)</param>
        /// <param name="field">The Field of the rule (optional)</param>
        /// <param name="effectiveAt">The effective date of the rule (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the access metadata rule. Defaults to return the latest version if not specified. (optional)</param>
        /// <returns>QuoteAccessMetadataRule</returns>
        QuoteAccessMetadataRule GetQuotesAccessMetadataRule (string scope, string provider = null, string priceSource = null, string instrumentIdType = null, string instrumentId = null, string quoteType = null, string field = null, DateTimeOrCutLabel effectiveAt = null, DateTimeOffset? asAt = null);

        /// <summary>
        /// [EXPERIMENTAL] Get a quote access metadata rule
        /// </summary>
        /// <remarks>
        /// Get a specific quote access metadata rule by specifying the corresponding identifier parts                No matching will be performed through this endpoint. To retrieve a rule, it is necessary to specify, exactly, the identifier of the rule
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the Quote Access Metadata Rule to retrieve.</param>
        /// <param name="provider">The Provider of the rule (optional)</param>
        /// <param name="priceSource">The PriceSource of the rule (optional)</param>
        /// <param name="instrumentIdType">The InstrumentIdType of the rule (optional)</param>
        /// <param name="instrumentId">The InstrumentId of the rule (optional)</param>
        /// <param name="quoteType">The QuoteType of the rule (optional)</param>
        /// <param name="field">The Field of the rule (optional)</param>
        /// <param name="effectiveAt">The effective date of the rule (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the access metadata rule. Defaults to return the latest version if not specified. (optional)</param>
        /// <returns>ApiResponse of QuoteAccessMetadataRule</returns>
        ApiResponse<QuoteAccessMetadataRule> GetQuotesAccessMetadataRuleWithHttpInfo (string scope, string provider = null, string priceSource = null, string instrumentIdType = null, string instrumentId = null, string quoteType = null, string field = null, DateTimeOrCutLabel effectiveAt = null, DateTimeOffset? asAt = null);
        /// <summary>
        /// [BETA] List quotes
        /// </summary>
        /// <remarks>
        /// List all the quotes from a single scope at the specified date/time
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the quotes to list.</param>
        /// <param name="asAt">The asAt datetime at which to list the quotes. Defaults to latest if not specified. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing quotes from a previous call to list quotes.              This value is returned from the previous call. If a pagination token is provided the sortBy, filter, effectiveAt, and asAt fields              must not have changed since the original request. Also, if set, a start value cannot be provided. (optional)</param>
        /// <param name="start">When paginating, skip this number of results. (optional)</param>
        /// <param name="limit">When paginating, limit the number of returned results to this many. (optional)</param>
        /// <param name="filter">Expression to filter the result set.              For example, to filter on the Provider, use \&quot;quoteId.quoteSeriesId.provider eq &#39;string&#39;\&quot;              Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid. (optional)</param>
        /// <returns>ResourceListOfQuote</returns>
        ResourceListOfQuote ListQuotes (string scope, DateTimeOffset? asAt = null, string page = null, int? start = null, int? limit = null, string filter = null);

        /// <summary>
        /// [BETA] List quotes
        /// </summary>
        /// <remarks>
        /// List all the quotes from a single scope at the specified date/time
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the quotes to list.</param>
        /// <param name="asAt">The asAt datetime at which to list the quotes. Defaults to latest if not specified. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing quotes from a previous call to list quotes.              This value is returned from the previous call. If a pagination token is provided the sortBy, filter, effectiveAt, and asAt fields              must not have changed since the original request. Also, if set, a start value cannot be provided. (optional)</param>
        /// <param name="start">When paginating, skip this number of results. (optional)</param>
        /// <param name="limit">When paginating, limit the number of returned results to this many. (optional)</param>
        /// <param name="filter">Expression to filter the result set.              For example, to filter on the Provider, use \&quot;quoteId.quoteSeriesId.provider eq &#39;string&#39;\&quot;              Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid. (optional)</param>
        /// <returns>ApiResponse of ResourceListOfQuote</returns>
        ApiResponse<ResourceListOfQuote> ListQuotesWithHttpInfo (string scope, DateTimeOffset? asAt = null, string page = null, int? start = null, int? limit = null, string filter = null);
        /// <summary>
        /// [EXPERIMENTAL] List all quote access metadata rules in a scope
        /// </summary>
        /// <remarks>
        /// Get all the quote access metadata rules in the specified scope
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the Quote Access Metadata Rule to retrieve.</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the access metadata rule. Defaults to return the latest version if not specified. (optional)</param>
        /// <returns>ResourceListOfQuoteAccessMetadataRule</returns>
        ResourceListOfQuoteAccessMetadataRule ListQuotesAccessMetadataRules (string scope, DateTimeOffset? asAt = null);

        /// <summary>
        /// [EXPERIMENTAL] List all quote access metadata rules in a scope
        /// </summary>
        /// <remarks>
        /// Get all the quote access metadata rules in the specified scope
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the Quote Access Metadata Rule to retrieve.</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the access metadata rule. Defaults to return the latest version if not specified. (optional)</param>
        /// <returns>ApiResponse of ResourceListOfQuoteAccessMetadataRule</returns>
        ApiResponse<ResourceListOfQuoteAccessMetadataRule> ListQuotesAccessMetadataRulesWithHttpInfo (string scope, DateTimeOffset? asAt = null);
        /// <summary>
        /// [EXPERIMENTAL] Upsert a Quote Access Metadata Rule. This creates or updates the data in LUSID.
        /// </summary>
        /// <remarks>
        /// Update or insert one Quote Access Metadata Rule in a single scope. An item will be updated if it already exists  and inserted if it does not.    The response will return the successfully updated or inserted Quote Access Metadata Rule or failure message if unsuccessful    It is important to always check to verify success (or failure).                Multiple rules for a key can exists with different effective at dates, when resources are accessed the rule that is active for the current time will be fetched
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope to use when updating or inserting the Quote Access Metadata Rule.</param>
        /// <param name="request">The Quote Access Metadata Rule to update or insert</param>
        /// <param name="effectiveAt">The date this rule will effective from (optional)</param>
        /// <returns>QuoteAccessMetadataRule</returns>
        QuoteAccessMetadataRule UpsertQuoteAccessMetadataRule (string scope, UpsertQuoteAccessMetadataRuleRequest request, DateTimeOrCutLabel effectiveAt = null);

        /// <summary>
        /// [EXPERIMENTAL] Upsert a Quote Access Metadata Rule. This creates or updates the data in LUSID.
        /// </summary>
        /// <remarks>
        /// Update or insert one Quote Access Metadata Rule in a single scope. An item will be updated if it already exists  and inserted if it does not.    The response will return the successfully updated or inserted Quote Access Metadata Rule or failure message if unsuccessful    It is important to always check to verify success (or failure).                Multiple rules for a key can exists with different effective at dates, when resources are accessed the rule that is active for the current time will be fetched
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope to use when updating or inserting the Quote Access Metadata Rule.</param>
        /// <param name="request">The Quote Access Metadata Rule to update or insert</param>
        /// <param name="effectiveAt">The date this rule will effective from (optional)</param>
        /// <returns>ApiResponse of QuoteAccessMetadataRule</returns>
        ApiResponse<QuoteAccessMetadataRule> UpsertQuoteAccessMetadataRuleWithHttpInfo (string scope, UpsertQuoteAccessMetadataRuleRequest request, DateTimeOrCutLabel effectiveAt = null);
        /// <summary>
        /// [BETA] Upsert quotes
        /// </summary>
        /// <remarks>
        /// Update or insert one or more quotes in a single scope. A quote will be updated if it already exists  and inserted if it does not.                In the request each quote must be keyed by a unique correlation id. This id is ephemeral and is not stored by LUSID.  It serves only as a way to easily identify each quote in the response.                The response will return both the collection of successfully updated or inserted quotes, as well as those that failed.  For the failures a reason will be provided explaining why the quote could not be updated or inserted.                It is important to always check the failed set for any unsuccessful results.  The maximum number of quotes that this method can upsert per request is 2,000.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope to use when updating or inserting the quotes.</param>
        /// <param name="quotes">The quotes to update or insert keyed by a unique correlation id. (optional)</param>
        /// <returns>UpsertQuotesResponse</returns>
        UpsertQuotesResponse UpsertQuotes (string scope, Dictionary<string, UpsertQuoteRequest> quotes = null);

        /// <summary>
        /// [BETA] Upsert quotes
        /// </summary>
        /// <remarks>
        /// Update or insert one or more quotes in a single scope. A quote will be updated if it already exists  and inserted if it does not.                In the request each quote must be keyed by a unique correlation id. This id is ephemeral and is not stored by LUSID.  It serves only as a way to easily identify each quote in the response.                The response will return both the collection of successfully updated or inserted quotes, as well as those that failed.  For the failures a reason will be provided explaining why the quote could not be updated or inserted.                It is important to always check the failed set for any unsuccessful results.  The maximum number of quotes that this method can upsert per request is 2,000.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope to use when updating or inserting the quotes.</param>
        /// <param name="quotes">The quotes to update or insert keyed by a unique correlation id. (optional)</param>
        /// <returns>ApiResponse of UpsertQuotesResponse</returns>
        ApiResponse<UpsertQuotesResponse> UpsertQuotesWithHttpInfo (string scope, Dictionary<string, UpsertQuoteRequest> quotes = null);
        #endregion Synchronous Operations
        #region Asynchronous Operations
        /// <summary>
        /// [EXPERIMENTAL] Delete a Quote Access Metadata Rule
        /// </summary>
        /// <remarks>
        /// Delete the Quote Access Metadata Rule that exactly matches the provided identifier parts
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the Quote Access Metadata Rule to retrieve.</param>
        /// <param name="provider">The Provider of the rule (optional)</param>
        /// <param name="priceSource">The PriceSource of the rule (optional)</param>
        /// <param name="instrumentIdType">The InstrumentIdType of the rule (optional)</param>
        /// <param name="instrumentId">The InstrumentId of the rule (optional)</param>
        /// <param name="quoteType">The QuoteType of the rule (optional)</param>
        /// <param name="field">The Field of the rule (optional)</param>
        /// <param name="effectiveAt">The effective date to delete at, if this is not supplied, it will delete all data found (optional)</param>
        /// <returns>Task of QuoteAccessMetadataRule</returns>
        System.Threading.Tasks.Task<QuoteAccessMetadataRule> DeleteQuoteAcccesMetadataRuleAsync (string scope, string provider = null, string priceSource = null, string instrumentIdType = null, string instrumentId = null, string quoteType = null, string field = null, DateTimeOrCutLabel effectiveAt = null);

        /// <summary>
        /// [EXPERIMENTAL] Delete a Quote Access Metadata Rule
        /// </summary>
        /// <remarks>
        /// Delete the Quote Access Metadata Rule that exactly matches the provided identifier parts
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the Quote Access Metadata Rule to retrieve.</param>
        /// <param name="provider">The Provider of the rule (optional)</param>
        /// <param name="priceSource">The PriceSource of the rule (optional)</param>
        /// <param name="instrumentIdType">The InstrumentIdType of the rule (optional)</param>
        /// <param name="instrumentId">The InstrumentId of the rule (optional)</param>
        /// <param name="quoteType">The QuoteType of the rule (optional)</param>
        /// <param name="field">The Field of the rule (optional)</param>
        /// <param name="effectiveAt">The effective date to delete at, if this is not supplied, it will delete all data found (optional)</param>
        /// <returns>Task of ApiResponse (QuoteAccessMetadataRule)</returns>
        System.Threading.Tasks.Task<ApiResponse<QuoteAccessMetadataRule>> DeleteQuoteAcccesMetadataRuleAsyncWithHttpInfo (string scope, string provider = null, string priceSource = null, string instrumentIdType = null, string instrumentId = null, string quoteType = null, string field = null, DateTimeOrCutLabel effectiveAt = null);
        /// <summary>
        /// [BETA] Delete quotes
        /// </summary>
        /// <remarks>
        /// Delete one or more specified quotes from a single scope. A quote is identified by its unique id which includes information about  the type of quote as well as the exact effective datetime (to the microsecond) from which it became valid.                In the request each quote must be keyed by a unique correlation id. This id is ephemeral and is not stored by LUSID.  It serves only as a way to easily identify each quote in the response.                The response will return both the collection of successfully deleted quotes, as well as those that failed.  For the failures a reason will be provided explaining why the quote could not be deleted.                It is important to always check the failed set for any unsuccessful results.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the quotes to delete.</param>
        /// <param name="quotes">The quotes to delete keyed by a unique correlation id. (optional)</param>
        /// <returns>Task of AnnulQuotesResponse</returns>
        System.Threading.Tasks.Task<AnnulQuotesResponse> DeleteQuotesAsync (string scope, Dictionary<string, QuoteId> quotes = null);

        /// <summary>
        /// [BETA] Delete quotes
        /// </summary>
        /// <remarks>
        /// Delete one or more specified quotes from a single scope. A quote is identified by its unique id which includes information about  the type of quote as well as the exact effective datetime (to the microsecond) from which it became valid.                In the request each quote must be keyed by a unique correlation id. This id is ephemeral and is not stored by LUSID.  It serves only as a way to easily identify each quote in the response.                The response will return both the collection of successfully deleted quotes, as well as those that failed.  For the failures a reason will be provided explaining why the quote could not be deleted.                It is important to always check the failed set for any unsuccessful results.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the quotes to delete.</param>
        /// <param name="quotes">The quotes to delete keyed by a unique correlation id. (optional)</param>
        /// <returns>Task of ApiResponse (AnnulQuotesResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<AnnulQuotesResponse>> DeleteQuotesAsyncWithHttpInfo (string scope, Dictionary<string, QuoteId> quotes = null);
        /// <summary>
        /// [BETA] Get quotes
        /// </summary>
        /// <remarks>
        /// Get one or more quotes from a single scope.                Each quote can be identified by its time invariant quote series id.                For each quote series id LUSID will return the most recent quote with respect to the provided (or default) effective datetime.                 An optional maximum age range window can be specified which defines how far back to look back for a quote from the specified effective datetime.  LUSID will return the most recent quote within this window.                In the request each quote series id must be keyed by a unique correlation id. This id is ephemeral and is not stored by LUSID.  It serves only as a way to easily identify each quote in the response.                The response will return three collections. One, the successfully retrieved quotes. Two, those that had a  valid quote series id but could not be found. Three, those that failed because LUSID could not construct a valid quote series id from the request.    For the quotes that failed or could not be found a reason will be provided explaining why the quote could not be retrieved.                It is important to always check the failed and not found sets for any unsuccessful results.  The maximum number of quotes that this method can get per request is 2,000.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the quotes to retrieve.</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to retrieve the quotes. Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the quotes. Defaults to return the latest version of each quote if not specified. (optional)</param>
        /// <param name="maxAge">The duration of the look back window in an ISO8601 time interval format e.g. P1Y2M3DT4H30M (1 year, 2 months, 3 days, 4 hours and 30 minutes).               This is subtracted from the provided effectiveAt datetime or cut label to generate a effective datetime window inside which a quote must exist to be retrieved. (optional)</param>
        /// <param name="quoteIds">The time invariant quote series ids of the quotes to retrieve. These need to be               keyed by a unique correlation id allowing the retrieved quote to be identified in the response. (optional)</param>
        /// <returns>Task of GetQuotesResponse</returns>
        System.Threading.Tasks.Task<GetQuotesResponse> GetQuotesAsync (string scope, DateTimeOrCutLabel effectiveAt = null, DateTimeOffset? asAt = null, string maxAge = null, Dictionary<string, QuoteSeriesId> quoteIds = null);

        /// <summary>
        /// [BETA] Get quotes
        /// </summary>
        /// <remarks>
        /// Get one or more quotes from a single scope.                Each quote can be identified by its time invariant quote series id.                For each quote series id LUSID will return the most recent quote with respect to the provided (or default) effective datetime.                 An optional maximum age range window can be specified which defines how far back to look back for a quote from the specified effective datetime.  LUSID will return the most recent quote within this window.                In the request each quote series id must be keyed by a unique correlation id. This id is ephemeral and is not stored by LUSID.  It serves only as a way to easily identify each quote in the response.                The response will return three collections. One, the successfully retrieved quotes. Two, those that had a  valid quote series id but could not be found. Three, those that failed because LUSID could not construct a valid quote series id from the request.    For the quotes that failed or could not be found a reason will be provided explaining why the quote could not be retrieved.                It is important to always check the failed and not found sets for any unsuccessful results.  The maximum number of quotes that this method can get per request is 2,000.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the quotes to retrieve.</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to retrieve the quotes. Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the quotes. Defaults to return the latest version of each quote if not specified. (optional)</param>
        /// <param name="maxAge">The duration of the look back window in an ISO8601 time interval format e.g. P1Y2M3DT4H30M (1 year, 2 months, 3 days, 4 hours and 30 minutes).               This is subtracted from the provided effectiveAt datetime or cut label to generate a effective datetime window inside which a quote must exist to be retrieved. (optional)</param>
        /// <param name="quoteIds">The time invariant quote series ids of the quotes to retrieve. These need to be               keyed by a unique correlation id allowing the retrieved quote to be identified in the response. (optional)</param>
        /// <returns>Task of ApiResponse (GetQuotesResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<GetQuotesResponse>> GetQuotesAsyncWithHttpInfo (string scope, DateTimeOrCutLabel effectiveAt = null, DateTimeOffset? asAt = null, string maxAge = null, Dictionary<string, QuoteSeriesId> quoteIds = null);
        /// <summary>
        /// [EXPERIMENTAL] Get a quote access metadata rule
        /// </summary>
        /// <remarks>
        /// Get a specific quote access metadata rule by specifying the corresponding identifier parts                No matching will be performed through this endpoint. To retrieve a rule, it is necessary to specify, exactly, the identifier of the rule
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the Quote Access Metadata Rule to retrieve.</param>
        /// <param name="provider">The Provider of the rule (optional)</param>
        /// <param name="priceSource">The PriceSource of the rule (optional)</param>
        /// <param name="instrumentIdType">The InstrumentIdType of the rule (optional)</param>
        /// <param name="instrumentId">The InstrumentId of the rule (optional)</param>
        /// <param name="quoteType">The QuoteType of the rule (optional)</param>
        /// <param name="field">The Field of the rule (optional)</param>
        /// <param name="effectiveAt">The effective date of the rule (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the access metadata rule. Defaults to return the latest version if not specified. (optional)</param>
        /// <returns>Task of QuoteAccessMetadataRule</returns>
        System.Threading.Tasks.Task<QuoteAccessMetadataRule> GetQuotesAccessMetadataRuleAsync (string scope, string provider = null, string priceSource = null, string instrumentIdType = null, string instrumentId = null, string quoteType = null, string field = null, DateTimeOrCutLabel effectiveAt = null, DateTimeOffset? asAt = null);

        /// <summary>
        /// [EXPERIMENTAL] Get a quote access metadata rule
        /// </summary>
        /// <remarks>
        /// Get a specific quote access metadata rule by specifying the corresponding identifier parts                No matching will be performed through this endpoint. To retrieve a rule, it is necessary to specify, exactly, the identifier of the rule
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the Quote Access Metadata Rule to retrieve.</param>
        /// <param name="provider">The Provider of the rule (optional)</param>
        /// <param name="priceSource">The PriceSource of the rule (optional)</param>
        /// <param name="instrumentIdType">The InstrumentIdType of the rule (optional)</param>
        /// <param name="instrumentId">The InstrumentId of the rule (optional)</param>
        /// <param name="quoteType">The QuoteType of the rule (optional)</param>
        /// <param name="field">The Field of the rule (optional)</param>
        /// <param name="effectiveAt">The effective date of the rule (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the access metadata rule. Defaults to return the latest version if not specified. (optional)</param>
        /// <returns>Task of ApiResponse (QuoteAccessMetadataRule)</returns>
        System.Threading.Tasks.Task<ApiResponse<QuoteAccessMetadataRule>> GetQuotesAccessMetadataRuleAsyncWithHttpInfo (string scope, string provider = null, string priceSource = null, string instrumentIdType = null, string instrumentId = null, string quoteType = null, string field = null, DateTimeOrCutLabel effectiveAt = null, DateTimeOffset? asAt = null);
        /// <summary>
        /// [BETA] List quotes
        /// </summary>
        /// <remarks>
        /// List all the quotes from a single scope at the specified date/time
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the quotes to list.</param>
        /// <param name="asAt">The asAt datetime at which to list the quotes. Defaults to latest if not specified. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing quotes from a previous call to list quotes.              This value is returned from the previous call. If a pagination token is provided the sortBy, filter, effectiveAt, and asAt fields              must not have changed since the original request. Also, if set, a start value cannot be provided. (optional)</param>
        /// <param name="start">When paginating, skip this number of results. (optional)</param>
        /// <param name="limit">When paginating, limit the number of returned results to this many. (optional)</param>
        /// <param name="filter">Expression to filter the result set.              For example, to filter on the Provider, use \&quot;quoteId.quoteSeriesId.provider eq &#39;string&#39;\&quot;              Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid. (optional)</param>
        /// <returns>Task of ResourceListOfQuote</returns>
        System.Threading.Tasks.Task<ResourceListOfQuote> ListQuotesAsync (string scope, DateTimeOffset? asAt = null, string page = null, int? start = null, int? limit = null, string filter = null);

        /// <summary>
        /// [BETA] List quotes
        /// </summary>
        /// <remarks>
        /// List all the quotes from a single scope at the specified date/time
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the quotes to list.</param>
        /// <param name="asAt">The asAt datetime at which to list the quotes. Defaults to latest if not specified. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing quotes from a previous call to list quotes.              This value is returned from the previous call. If a pagination token is provided the sortBy, filter, effectiveAt, and asAt fields              must not have changed since the original request. Also, if set, a start value cannot be provided. (optional)</param>
        /// <param name="start">When paginating, skip this number of results. (optional)</param>
        /// <param name="limit">When paginating, limit the number of returned results to this many. (optional)</param>
        /// <param name="filter">Expression to filter the result set.              For example, to filter on the Provider, use \&quot;quoteId.quoteSeriesId.provider eq &#39;string&#39;\&quot;              Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid. (optional)</param>
        /// <returns>Task of ApiResponse (ResourceListOfQuote)</returns>
        System.Threading.Tasks.Task<ApiResponse<ResourceListOfQuote>> ListQuotesAsyncWithHttpInfo (string scope, DateTimeOffset? asAt = null, string page = null, int? start = null, int? limit = null, string filter = null);
        /// <summary>
        /// [EXPERIMENTAL] List all quote access metadata rules in a scope
        /// </summary>
        /// <remarks>
        /// Get all the quote access metadata rules in the specified scope
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the Quote Access Metadata Rule to retrieve.</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the access metadata rule. Defaults to return the latest version if not specified. (optional)</param>
        /// <returns>Task of ResourceListOfQuoteAccessMetadataRule</returns>
        System.Threading.Tasks.Task<ResourceListOfQuoteAccessMetadataRule> ListQuotesAccessMetadataRulesAsync (string scope, DateTimeOffset? asAt = null);

        /// <summary>
        /// [EXPERIMENTAL] List all quote access metadata rules in a scope
        /// </summary>
        /// <remarks>
        /// Get all the quote access metadata rules in the specified scope
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the Quote Access Metadata Rule to retrieve.</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the access metadata rule. Defaults to return the latest version if not specified. (optional)</param>
        /// <returns>Task of ApiResponse (ResourceListOfQuoteAccessMetadataRule)</returns>
        System.Threading.Tasks.Task<ApiResponse<ResourceListOfQuoteAccessMetadataRule>> ListQuotesAccessMetadataRulesAsyncWithHttpInfo (string scope, DateTimeOffset? asAt = null);
        /// <summary>
        /// [EXPERIMENTAL] Upsert a Quote Access Metadata Rule. This creates or updates the data in LUSID.
        /// </summary>
        /// <remarks>
        /// Update or insert one Quote Access Metadata Rule in a single scope. An item will be updated if it already exists  and inserted if it does not.    The response will return the successfully updated or inserted Quote Access Metadata Rule or failure message if unsuccessful    It is important to always check to verify success (or failure).                Multiple rules for a key can exists with different effective at dates, when resources are accessed the rule that is active for the current time will be fetched
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope to use when updating or inserting the Quote Access Metadata Rule.</param>
        /// <param name="request">The Quote Access Metadata Rule to update or insert</param>
        /// <param name="effectiveAt">The date this rule will effective from (optional)</param>
        /// <returns>Task of QuoteAccessMetadataRule</returns>
        System.Threading.Tasks.Task<QuoteAccessMetadataRule> UpsertQuoteAccessMetadataRuleAsync (string scope, UpsertQuoteAccessMetadataRuleRequest request, DateTimeOrCutLabel effectiveAt = null);

        /// <summary>
        /// [EXPERIMENTAL] Upsert a Quote Access Metadata Rule. This creates or updates the data in LUSID.
        /// </summary>
        /// <remarks>
        /// Update or insert one Quote Access Metadata Rule in a single scope. An item will be updated if it already exists  and inserted if it does not.    The response will return the successfully updated or inserted Quote Access Metadata Rule or failure message if unsuccessful    It is important to always check to verify success (or failure).                Multiple rules for a key can exists with different effective at dates, when resources are accessed the rule that is active for the current time will be fetched
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope to use when updating or inserting the Quote Access Metadata Rule.</param>
        /// <param name="request">The Quote Access Metadata Rule to update or insert</param>
        /// <param name="effectiveAt">The date this rule will effective from (optional)</param>
        /// <returns>Task of ApiResponse (QuoteAccessMetadataRule)</returns>
        System.Threading.Tasks.Task<ApiResponse<QuoteAccessMetadataRule>> UpsertQuoteAccessMetadataRuleAsyncWithHttpInfo (string scope, UpsertQuoteAccessMetadataRuleRequest request, DateTimeOrCutLabel effectiveAt = null);
        /// <summary>
        /// [BETA] Upsert quotes
        /// </summary>
        /// <remarks>
        /// Update or insert one or more quotes in a single scope. A quote will be updated if it already exists  and inserted if it does not.                In the request each quote must be keyed by a unique correlation id. This id is ephemeral and is not stored by LUSID.  It serves only as a way to easily identify each quote in the response.                The response will return both the collection of successfully updated or inserted quotes, as well as those that failed.  For the failures a reason will be provided explaining why the quote could not be updated or inserted.                It is important to always check the failed set for any unsuccessful results.  The maximum number of quotes that this method can upsert per request is 2,000.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope to use when updating or inserting the quotes.</param>
        /// <param name="quotes">The quotes to update or insert keyed by a unique correlation id. (optional)</param>
        /// <returns>Task of UpsertQuotesResponse</returns>
        System.Threading.Tasks.Task<UpsertQuotesResponse> UpsertQuotesAsync (string scope, Dictionary<string, UpsertQuoteRequest> quotes = null);

        /// <summary>
        /// [BETA] Upsert quotes
        /// </summary>
        /// <remarks>
        /// Update or insert one or more quotes in a single scope. A quote will be updated if it already exists  and inserted if it does not.                In the request each quote must be keyed by a unique correlation id. This id is ephemeral and is not stored by LUSID.  It serves only as a way to easily identify each quote in the response.                The response will return both the collection of successfully updated or inserted quotes, as well as those that failed.  For the failures a reason will be provided explaining why the quote could not be updated or inserted.                It is important to always check the failed set for any unsuccessful results.  The maximum number of quotes that this method can upsert per request is 2,000.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope to use when updating or inserting the quotes.</param>
        /// <param name="quotes">The quotes to update or insert keyed by a unique correlation id. (optional)</param>
        /// <returns>Task of ApiResponse (UpsertQuotesResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<UpsertQuotesResponse>> UpsertQuotesAsyncWithHttpInfo (string scope, Dictionary<string, UpsertQuoteRequest> quotes = null);
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class QuotesApi : IQuotesApi
    {
        private Lusid.Sdk.Client.ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Initializes a new instance of the <see cref="QuotesApi"/> class.
        /// </summary>
        /// <returns></returns>
        public QuotesApi(String basePath)
        {
            this.Configuration = new Lusid.Sdk.Client.Configuration { BasePath = basePath };

            ExceptionFactory = Lusid.Sdk.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="QuotesApi"/> class
        /// </summary>
        /// <returns></returns>
        public QuotesApi()
        {
            this.Configuration = Lusid.Sdk.Client.Configuration.Default;

            ExceptionFactory = Lusid.Sdk.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="QuotesApi"/> class
        /// using Configuration object
        /// </summary>
        /// <param name="configuration">An instance of Configuration</param>
        /// <returns></returns>
        public QuotesApi(Lusid.Sdk.Client.Configuration configuration = null)
        {
            if (configuration == null) // use the default one in Configuration
                this.Configuration = Lusid.Sdk.Client.Configuration.Default;
            else
                this.Configuration = configuration;

            ExceptionFactory = Lusid.Sdk.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public String GetBasePath()
        {
            return this.Configuration.ApiClient.RestClient.BaseUrl.ToString();
        }

        /// <summary>
        /// Sets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        [Obsolete("SetBasePath is deprecated, please do 'Configuration.ApiClient = new ApiClient(\"http://new-path\")' instead.")]
        public void SetBasePath(String basePath)
        {
            // do nothing
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public Lusid.Sdk.Client.Configuration Configuration {get; set;}

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public Lusid.Sdk.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }

        /// <summary>
        /// Gets the default header.
        /// </summary>
        /// <returns>Dictionary of HTTP header</returns>
        [Obsolete("DefaultHeader is deprecated, please use Configuration.DefaultHeader instead.")]
        public IDictionary<String, String> DefaultHeader()
        {
            return new ReadOnlyDictionary<string, string>(this.Configuration.DefaultHeader);
        }

        /// <summary>
        /// Add default header.
        /// </summary>
        /// <param name="key">Header field name.</param>
        /// <param name="value">Header field value.</param>
        /// <returns></returns>
        [Obsolete("AddDefaultHeader is deprecated, please use Configuration.AddDefaultHeader instead.")]
        public void AddDefaultHeader(string key, string value)
        {
            this.Configuration.AddDefaultHeader(key, value);
        }

        /// <summary>
        /// [EXPERIMENTAL] Delete a Quote Access Metadata Rule Delete the Quote Access Metadata Rule that exactly matches the provided identifier parts
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the Quote Access Metadata Rule to retrieve.</param>
        /// <param name="provider">The Provider of the rule (optional)</param>
        /// <param name="priceSource">The PriceSource of the rule (optional)</param>
        /// <param name="instrumentIdType">The InstrumentIdType of the rule (optional)</param>
        /// <param name="instrumentId">The InstrumentId of the rule (optional)</param>
        /// <param name="quoteType">The QuoteType of the rule (optional)</param>
        /// <param name="field">The Field of the rule (optional)</param>
        /// <param name="effectiveAt">The effective date to delete at, if this is not supplied, it will delete all data found (optional)</param>
        /// <returns>QuoteAccessMetadataRule</returns>
        public QuoteAccessMetadataRule DeleteQuoteAcccesMetadataRule (string scope, string provider = null, string priceSource = null, string instrumentIdType = null, string instrumentId = null, string quoteType = null, string field = null, DateTimeOrCutLabel effectiveAt = null)
        {
             ApiResponse<QuoteAccessMetadataRule> localVarResponse = DeleteQuoteAcccesMetadataRuleWithHttpInfo(scope, provider, priceSource, instrumentIdType, instrumentId, quoteType, field, effectiveAt);
             return localVarResponse.Data;
        }

        /// <summary>
        /// [EXPERIMENTAL] Delete a Quote Access Metadata Rule Delete the Quote Access Metadata Rule that exactly matches the provided identifier parts
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the Quote Access Metadata Rule to retrieve.</param>
        /// <param name="provider">The Provider of the rule (optional)</param>
        /// <param name="priceSource">The PriceSource of the rule (optional)</param>
        /// <param name="instrumentIdType">The InstrumentIdType of the rule (optional)</param>
        /// <param name="instrumentId">The InstrumentId of the rule (optional)</param>
        /// <param name="quoteType">The QuoteType of the rule (optional)</param>
        /// <param name="field">The Field of the rule (optional)</param>
        /// <param name="effectiveAt">The effective date to delete at, if this is not supplied, it will delete all data found (optional)</param>
        /// <returns>ApiResponse of QuoteAccessMetadataRule</returns>
        public ApiResponse< QuoteAccessMetadataRule > DeleteQuoteAcccesMetadataRuleWithHttpInfo (string scope, string provider = null, string priceSource = null, string instrumentIdType = null, string instrumentId = null, string quoteType = null, string field = null, DateTimeOrCutLabel effectiveAt = null)
        {
            // verify the required parameter 'scope' is set
            if (scope == null)
                throw new ApiException(400, "Missing required parameter 'scope' when calling QuotesApi->DeleteQuoteAcccesMetadataRule");

            var localVarPath = "./api/metadata/quotes/rules/{scope}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "text/plain",
                "application/json",
                "text/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (scope != null) localVarPathParams.Add("scope", this.Configuration.ApiClient.ParameterToString(scope)); // path parameter
            if (provider != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "provider", provider)); // query parameter
            if (priceSource != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "priceSource", priceSource)); // query parameter
            if (instrumentIdType != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "instrumentIdType", instrumentIdType)); // query parameter
            if (instrumentId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "instrumentId", instrumentId)); // query parameter
            if (quoteType != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "quoteType", quoteType)); // query parameter
            if (field != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "field", field)); // query parameter
            if (effectiveAt != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "effectiveAt", effectiveAt)); // query parameter

            // authentication (oauth2) required
            // oauth required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteQuoteAcccesMetadataRule", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<QuoteAccessMetadataRule>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => string.Join(",", x.Value)),
                (QuoteAccessMetadataRule) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(QuoteAccessMetadataRule)));
        }

        /// <summary>
        /// [EXPERIMENTAL] Delete a Quote Access Metadata Rule Delete the Quote Access Metadata Rule that exactly matches the provided identifier parts
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the Quote Access Metadata Rule to retrieve.</param>
        /// <param name="provider">The Provider of the rule (optional)</param>
        /// <param name="priceSource">The PriceSource of the rule (optional)</param>
        /// <param name="instrumentIdType">The InstrumentIdType of the rule (optional)</param>
        /// <param name="instrumentId">The InstrumentId of the rule (optional)</param>
        /// <param name="quoteType">The QuoteType of the rule (optional)</param>
        /// <param name="field">The Field of the rule (optional)</param>
        /// <param name="effectiveAt">The effective date to delete at, if this is not supplied, it will delete all data found (optional)</param>
        /// <returns>Task of QuoteAccessMetadataRule</returns>
        public async System.Threading.Tasks.Task<QuoteAccessMetadataRule> DeleteQuoteAcccesMetadataRuleAsync (string scope, string provider = null, string priceSource = null, string instrumentIdType = null, string instrumentId = null, string quoteType = null, string field = null, DateTimeOrCutLabel effectiveAt = null)
        {
             ApiResponse<QuoteAccessMetadataRule> localVarResponse = await DeleteQuoteAcccesMetadataRuleAsyncWithHttpInfo(scope, provider, priceSource, instrumentIdType, instrumentId, quoteType, field, effectiveAt);
             return localVarResponse.Data;

        }

        /// <summary>
        /// [EXPERIMENTAL] Delete a Quote Access Metadata Rule Delete the Quote Access Metadata Rule that exactly matches the provided identifier parts
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the Quote Access Metadata Rule to retrieve.</param>
        /// <param name="provider">The Provider of the rule (optional)</param>
        /// <param name="priceSource">The PriceSource of the rule (optional)</param>
        /// <param name="instrumentIdType">The InstrumentIdType of the rule (optional)</param>
        /// <param name="instrumentId">The InstrumentId of the rule (optional)</param>
        /// <param name="quoteType">The QuoteType of the rule (optional)</param>
        /// <param name="field">The Field of the rule (optional)</param>
        /// <param name="effectiveAt">The effective date to delete at, if this is not supplied, it will delete all data found (optional)</param>
        /// <returns>Task of ApiResponse (QuoteAccessMetadataRule)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<QuoteAccessMetadataRule>> DeleteQuoteAcccesMetadataRuleAsyncWithHttpInfo (string scope, string provider = null, string priceSource = null, string instrumentIdType = null, string instrumentId = null, string quoteType = null, string field = null, DateTimeOrCutLabel effectiveAt = null)
        {
            // verify the required parameter 'scope' is set
            if (scope == null)
                throw new ApiException(400, "Missing required parameter 'scope' when calling QuotesApi->DeleteQuoteAcccesMetadataRule");

            var localVarPath = "./api/metadata/quotes/rules/{scope}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "text/plain",
                "application/json",
                "text/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (scope != null) localVarPathParams.Add("scope", this.Configuration.ApiClient.ParameterToString(scope)); // path parameter
            if (provider != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "provider", provider)); // query parameter
            if (priceSource != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "priceSource", priceSource)); // query parameter
            if (instrumentIdType != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "instrumentIdType", instrumentIdType)); // query parameter
            if (instrumentId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "instrumentId", instrumentId)); // query parameter
            if (quoteType != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "quoteType", quoteType)); // query parameter
            if (field != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "field", field)); // query parameter
            if (effectiveAt != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "effectiveAt", effectiveAt)); // query parameter

            // authentication (oauth2) required
            // oauth required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteQuoteAcccesMetadataRule", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<QuoteAccessMetadataRule>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => string.Join(",", x.Value)),
                (QuoteAccessMetadataRule) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(QuoteAccessMetadataRule)));
        }

        /// <summary>
        /// [BETA] Delete quotes Delete one or more specified quotes from a single scope. A quote is identified by its unique id which includes information about  the type of quote as well as the exact effective datetime (to the microsecond) from which it became valid.                In the request each quote must be keyed by a unique correlation id. This id is ephemeral and is not stored by LUSID.  It serves only as a way to easily identify each quote in the response.                The response will return both the collection of successfully deleted quotes, as well as those that failed.  For the failures a reason will be provided explaining why the quote could not be deleted.                It is important to always check the failed set for any unsuccessful results.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the quotes to delete.</param>
        /// <param name="quotes">The quotes to delete keyed by a unique correlation id. (optional)</param>
        /// <returns>AnnulQuotesResponse</returns>
        public AnnulQuotesResponse DeleteQuotes (string scope, Dictionary<string, QuoteId> quotes = null)
        {
             ApiResponse<AnnulQuotesResponse> localVarResponse = DeleteQuotesWithHttpInfo(scope, quotes);
             return localVarResponse.Data;
        }

        /// <summary>
        /// [BETA] Delete quotes Delete one or more specified quotes from a single scope. A quote is identified by its unique id which includes information about  the type of quote as well as the exact effective datetime (to the microsecond) from which it became valid.                In the request each quote must be keyed by a unique correlation id. This id is ephemeral and is not stored by LUSID.  It serves only as a way to easily identify each quote in the response.                The response will return both the collection of successfully deleted quotes, as well as those that failed.  For the failures a reason will be provided explaining why the quote could not be deleted.                It is important to always check the failed set for any unsuccessful results.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the quotes to delete.</param>
        /// <param name="quotes">The quotes to delete keyed by a unique correlation id. (optional)</param>
        /// <returns>ApiResponse of AnnulQuotesResponse</returns>
        public ApiResponse< AnnulQuotesResponse > DeleteQuotesWithHttpInfo (string scope, Dictionary<string, QuoteId> quotes = null)
        {
            // verify the required parameter 'scope' is set
            if (scope == null)
                throw new ApiException(400, "Missing required parameter 'scope' when calling QuotesApi->DeleteQuotes");

            var localVarPath = "./api/quotes/{scope}/$delete";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "text/plain",
                "application/json",
                "text/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (scope != null) localVarPathParams.Add("scope", this.Configuration.ApiClient.ParameterToString(scope)); // path parameter
            if (quotes != null && quotes.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(quotes); // http body (model) parameter
            }
            else
            {
                localVarPostBody = quotes; // byte array
            }

            // authentication (oauth2) required
            // oauth required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteQuotes", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<AnnulQuotesResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => string.Join(",", x.Value)),
                (AnnulQuotesResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(AnnulQuotesResponse)));
        }

        /// <summary>
        /// [BETA] Delete quotes Delete one or more specified quotes from a single scope. A quote is identified by its unique id which includes information about  the type of quote as well as the exact effective datetime (to the microsecond) from which it became valid.                In the request each quote must be keyed by a unique correlation id. This id is ephemeral and is not stored by LUSID.  It serves only as a way to easily identify each quote in the response.                The response will return both the collection of successfully deleted quotes, as well as those that failed.  For the failures a reason will be provided explaining why the quote could not be deleted.                It is important to always check the failed set for any unsuccessful results.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the quotes to delete.</param>
        /// <param name="quotes">The quotes to delete keyed by a unique correlation id. (optional)</param>
        /// <returns>Task of AnnulQuotesResponse</returns>
        public async System.Threading.Tasks.Task<AnnulQuotesResponse> DeleteQuotesAsync (string scope, Dictionary<string, QuoteId> quotes = null)
        {
             ApiResponse<AnnulQuotesResponse> localVarResponse = await DeleteQuotesAsyncWithHttpInfo(scope, quotes);
             return localVarResponse.Data;

        }

        /// <summary>
        /// [BETA] Delete quotes Delete one or more specified quotes from a single scope. A quote is identified by its unique id which includes information about  the type of quote as well as the exact effective datetime (to the microsecond) from which it became valid.                In the request each quote must be keyed by a unique correlation id. This id is ephemeral and is not stored by LUSID.  It serves only as a way to easily identify each quote in the response.                The response will return both the collection of successfully deleted quotes, as well as those that failed.  For the failures a reason will be provided explaining why the quote could not be deleted.                It is important to always check the failed set for any unsuccessful results.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the quotes to delete.</param>
        /// <param name="quotes">The quotes to delete keyed by a unique correlation id. (optional)</param>
        /// <returns>Task of ApiResponse (AnnulQuotesResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<AnnulQuotesResponse>> DeleteQuotesAsyncWithHttpInfo (string scope, Dictionary<string, QuoteId> quotes = null)
        {
            // verify the required parameter 'scope' is set
            if (scope == null)
                throw new ApiException(400, "Missing required parameter 'scope' when calling QuotesApi->DeleteQuotes");

            var localVarPath = "./api/quotes/{scope}/$delete";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "text/plain",
                "application/json",
                "text/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (scope != null) localVarPathParams.Add("scope", this.Configuration.ApiClient.ParameterToString(scope)); // path parameter
            if (quotes != null && quotes.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(quotes); // http body (model) parameter
            }
            else
            {
                localVarPostBody = quotes; // byte array
            }

            // authentication (oauth2) required
            // oauth required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteQuotes", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<AnnulQuotesResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => string.Join(",", x.Value)),
                (AnnulQuotesResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(AnnulQuotesResponse)));
        }

        /// <summary>
        /// [BETA] Get quotes Get one or more quotes from a single scope.                Each quote can be identified by its time invariant quote series id.                For each quote series id LUSID will return the most recent quote with respect to the provided (or default) effective datetime.                 An optional maximum age range window can be specified which defines how far back to look back for a quote from the specified effective datetime.  LUSID will return the most recent quote within this window.                In the request each quote series id must be keyed by a unique correlation id. This id is ephemeral and is not stored by LUSID.  It serves only as a way to easily identify each quote in the response.                The response will return three collections. One, the successfully retrieved quotes. Two, those that had a  valid quote series id but could not be found. Three, those that failed because LUSID could not construct a valid quote series id from the request.    For the quotes that failed or could not be found a reason will be provided explaining why the quote could not be retrieved.                It is important to always check the failed and not found sets for any unsuccessful results.  The maximum number of quotes that this method can get per request is 2,000.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the quotes to retrieve.</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to retrieve the quotes. Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the quotes. Defaults to return the latest version of each quote if not specified. (optional)</param>
        /// <param name="maxAge">The duration of the look back window in an ISO8601 time interval format e.g. P1Y2M3DT4H30M (1 year, 2 months, 3 days, 4 hours and 30 minutes).               This is subtracted from the provided effectiveAt datetime or cut label to generate a effective datetime window inside which a quote must exist to be retrieved. (optional)</param>
        /// <param name="quoteIds">The time invariant quote series ids of the quotes to retrieve. These need to be               keyed by a unique correlation id allowing the retrieved quote to be identified in the response. (optional)</param>
        /// <returns>GetQuotesResponse</returns>
        public GetQuotesResponse GetQuotes (string scope, DateTimeOrCutLabel effectiveAt = null, DateTimeOffset? asAt = null, string maxAge = null, Dictionary<string, QuoteSeriesId> quoteIds = null)
        {
             ApiResponse<GetQuotesResponse> localVarResponse = GetQuotesWithHttpInfo(scope, effectiveAt, asAt, maxAge, quoteIds);
             return localVarResponse.Data;
        }

        /// <summary>
        /// [BETA] Get quotes Get one or more quotes from a single scope.                Each quote can be identified by its time invariant quote series id.                For each quote series id LUSID will return the most recent quote with respect to the provided (or default) effective datetime.                 An optional maximum age range window can be specified which defines how far back to look back for a quote from the specified effective datetime.  LUSID will return the most recent quote within this window.                In the request each quote series id must be keyed by a unique correlation id. This id is ephemeral and is not stored by LUSID.  It serves only as a way to easily identify each quote in the response.                The response will return three collections. One, the successfully retrieved quotes. Two, those that had a  valid quote series id but could not be found. Three, those that failed because LUSID could not construct a valid quote series id from the request.    For the quotes that failed or could not be found a reason will be provided explaining why the quote could not be retrieved.                It is important to always check the failed and not found sets for any unsuccessful results.  The maximum number of quotes that this method can get per request is 2,000.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the quotes to retrieve.</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to retrieve the quotes. Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the quotes. Defaults to return the latest version of each quote if not specified. (optional)</param>
        /// <param name="maxAge">The duration of the look back window in an ISO8601 time interval format e.g. P1Y2M3DT4H30M (1 year, 2 months, 3 days, 4 hours and 30 minutes).               This is subtracted from the provided effectiveAt datetime or cut label to generate a effective datetime window inside which a quote must exist to be retrieved. (optional)</param>
        /// <param name="quoteIds">The time invariant quote series ids of the quotes to retrieve. These need to be               keyed by a unique correlation id allowing the retrieved quote to be identified in the response. (optional)</param>
        /// <returns>ApiResponse of GetQuotesResponse</returns>
        public ApiResponse< GetQuotesResponse > GetQuotesWithHttpInfo (string scope, DateTimeOrCutLabel effectiveAt = null, DateTimeOffset? asAt = null, string maxAge = null, Dictionary<string, QuoteSeriesId> quoteIds = null)
        {
            // verify the required parameter 'scope' is set
            if (scope == null)
                throw new ApiException(400, "Missing required parameter 'scope' when calling QuotesApi->GetQuotes");

            var localVarPath = "./api/quotes/{scope}/$get";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "text/plain",
                "application/json",
                "text/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (scope != null) localVarPathParams.Add("scope", this.Configuration.ApiClient.ParameterToString(scope)); // path parameter
            if (effectiveAt != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "effectiveAt", effectiveAt)); // query parameter
            if (asAt != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "asAt", asAt)); // query parameter
            if (maxAge != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "maxAge", maxAge)); // query parameter
            if (quoteIds != null && quoteIds.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(quoteIds); // http body (model) parameter
            }
            else
            {
                localVarPostBody = quoteIds; // byte array
            }

            // authentication (oauth2) required
            // oauth required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetQuotes", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<GetQuotesResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => string.Join(",", x.Value)),
                (GetQuotesResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(GetQuotesResponse)));
        }

        /// <summary>
        /// [BETA] Get quotes Get one or more quotes from a single scope.                Each quote can be identified by its time invariant quote series id.                For each quote series id LUSID will return the most recent quote with respect to the provided (or default) effective datetime.                 An optional maximum age range window can be specified which defines how far back to look back for a quote from the specified effective datetime.  LUSID will return the most recent quote within this window.                In the request each quote series id must be keyed by a unique correlation id. This id is ephemeral and is not stored by LUSID.  It serves only as a way to easily identify each quote in the response.                The response will return three collections. One, the successfully retrieved quotes. Two, those that had a  valid quote series id but could not be found. Three, those that failed because LUSID could not construct a valid quote series id from the request.    For the quotes that failed or could not be found a reason will be provided explaining why the quote could not be retrieved.                It is important to always check the failed and not found sets for any unsuccessful results.  The maximum number of quotes that this method can get per request is 2,000.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the quotes to retrieve.</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to retrieve the quotes. Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the quotes. Defaults to return the latest version of each quote if not specified. (optional)</param>
        /// <param name="maxAge">The duration of the look back window in an ISO8601 time interval format e.g. P1Y2M3DT4H30M (1 year, 2 months, 3 days, 4 hours and 30 minutes).               This is subtracted from the provided effectiveAt datetime or cut label to generate a effective datetime window inside which a quote must exist to be retrieved. (optional)</param>
        /// <param name="quoteIds">The time invariant quote series ids of the quotes to retrieve. These need to be               keyed by a unique correlation id allowing the retrieved quote to be identified in the response. (optional)</param>
        /// <returns>Task of GetQuotesResponse</returns>
        public async System.Threading.Tasks.Task<GetQuotesResponse> GetQuotesAsync (string scope, DateTimeOrCutLabel effectiveAt = null, DateTimeOffset? asAt = null, string maxAge = null, Dictionary<string, QuoteSeriesId> quoteIds = null)
        {
             ApiResponse<GetQuotesResponse> localVarResponse = await GetQuotesAsyncWithHttpInfo(scope, effectiveAt, asAt, maxAge, quoteIds);
             return localVarResponse.Data;

        }

        /// <summary>
        /// [BETA] Get quotes Get one or more quotes from a single scope.                Each quote can be identified by its time invariant quote series id.                For each quote series id LUSID will return the most recent quote with respect to the provided (or default) effective datetime.                 An optional maximum age range window can be specified which defines how far back to look back for a quote from the specified effective datetime.  LUSID will return the most recent quote within this window.                In the request each quote series id must be keyed by a unique correlation id. This id is ephemeral and is not stored by LUSID.  It serves only as a way to easily identify each quote in the response.                The response will return three collections. One, the successfully retrieved quotes. Two, those that had a  valid quote series id but could not be found. Three, those that failed because LUSID could not construct a valid quote series id from the request.    For the quotes that failed or could not be found a reason will be provided explaining why the quote could not be retrieved.                It is important to always check the failed and not found sets for any unsuccessful results.  The maximum number of quotes that this method can get per request is 2,000.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the quotes to retrieve.</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to retrieve the quotes. Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the quotes. Defaults to return the latest version of each quote if not specified. (optional)</param>
        /// <param name="maxAge">The duration of the look back window in an ISO8601 time interval format e.g. P1Y2M3DT4H30M (1 year, 2 months, 3 days, 4 hours and 30 minutes).               This is subtracted from the provided effectiveAt datetime or cut label to generate a effective datetime window inside which a quote must exist to be retrieved. (optional)</param>
        /// <param name="quoteIds">The time invariant quote series ids of the quotes to retrieve. These need to be               keyed by a unique correlation id allowing the retrieved quote to be identified in the response. (optional)</param>
        /// <returns>Task of ApiResponse (GetQuotesResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<GetQuotesResponse>> GetQuotesAsyncWithHttpInfo (string scope, DateTimeOrCutLabel effectiveAt = null, DateTimeOffset? asAt = null, string maxAge = null, Dictionary<string, QuoteSeriesId> quoteIds = null)
        {
            // verify the required parameter 'scope' is set
            if (scope == null)
                throw new ApiException(400, "Missing required parameter 'scope' when calling QuotesApi->GetQuotes");

            var localVarPath = "./api/quotes/{scope}/$get";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "text/plain",
                "application/json",
                "text/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (scope != null) localVarPathParams.Add("scope", this.Configuration.ApiClient.ParameterToString(scope)); // path parameter
            if (effectiveAt != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "effectiveAt", effectiveAt)); // query parameter
            if (asAt != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "asAt", asAt)); // query parameter
            if (maxAge != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "maxAge", maxAge)); // query parameter
            if (quoteIds != null && quoteIds.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(quoteIds); // http body (model) parameter
            }
            else
            {
                localVarPostBody = quoteIds; // byte array
            }

            // authentication (oauth2) required
            // oauth required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetQuotes", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<GetQuotesResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => string.Join(",", x.Value)),
                (GetQuotesResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(GetQuotesResponse)));
        }

        /// <summary>
        /// [EXPERIMENTAL] Get a quote access metadata rule Get a specific quote access metadata rule by specifying the corresponding identifier parts                No matching will be performed through this endpoint. To retrieve a rule, it is necessary to specify, exactly, the identifier of the rule
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the Quote Access Metadata Rule to retrieve.</param>
        /// <param name="provider">The Provider of the rule (optional)</param>
        /// <param name="priceSource">The PriceSource of the rule (optional)</param>
        /// <param name="instrumentIdType">The InstrumentIdType of the rule (optional)</param>
        /// <param name="instrumentId">The InstrumentId of the rule (optional)</param>
        /// <param name="quoteType">The QuoteType of the rule (optional)</param>
        /// <param name="field">The Field of the rule (optional)</param>
        /// <param name="effectiveAt">The effective date of the rule (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the access metadata rule. Defaults to return the latest version if not specified. (optional)</param>
        /// <returns>QuoteAccessMetadataRule</returns>
        public QuoteAccessMetadataRule GetQuotesAccessMetadataRule (string scope, string provider = null, string priceSource = null, string instrumentIdType = null, string instrumentId = null, string quoteType = null, string field = null, DateTimeOrCutLabel effectiveAt = null, DateTimeOffset? asAt = null)
        {
             ApiResponse<QuoteAccessMetadataRule> localVarResponse = GetQuotesAccessMetadataRuleWithHttpInfo(scope, provider, priceSource, instrumentIdType, instrumentId, quoteType, field, effectiveAt, asAt);
             return localVarResponse.Data;
        }

        /// <summary>
        /// [EXPERIMENTAL] Get a quote access metadata rule Get a specific quote access metadata rule by specifying the corresponding identifier parts                No matching will be performed through this endpoint. To retrieve a rule, it is necessary to specify, exactly, the identifier of the rule
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the Quote Access Metadata Rule to retrieve.</param>
        /// <param name="provider">The Provider of the rule (optional)</param>
        /// <param name="priceSource">The PriceSource of the rule (optional)</param>
        /// <param name="instrumentIdType">The InstrumentIdType of the rule (optional)</param>
        /// <param name="instrumentId">The InstrumentId of the rule (optional)</param>
        /// <param name="quoteType">The QuoteType of the rule (optional)</param>
        /// <param name="field">The Field of the rule (optional)</param>
        /// <param name="effectiveAt">The effective date of the rule (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the access metadata rule. Defaults to return the latest version if not specified. (optional)</param>
        /// <returns>ApiResponse of QuoteAccessMetadataRule</returns>
        public ApiResponse< QuoteAccessMetadataRule > GetQuotesAccessMetadataRuleWithHttpInfo (string scope, string provider = null, string priceSource = null, string instrumentIdType = null, string instrumentId = null, string quoteType = null, string field = null, DateTimeOrCutLabel effectiveAt = null, DateTimeOffset? asAt = null)
        {
            // verify the required parameter 'scope' is set
            if (scope == null)
                throw new ApiException(400, "Missing required parameter 'scope' when calling QuotesApi->GetQuotesAccessMetadataRule");

            var localVarPath = "./api/metadata/quotes/rules";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "text/plain",
                "application/json",
                "text/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (scope != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "scope", scope)); // query parameter
            if (provider != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "provider", provider)); // query parameter
            if (priceSource != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "priceSource", priceSource)); // query parameter
            if (instrumentIdType != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "instrumentIdType", instrumentIdType)); // query parameter
            if (instrumentId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "instrumentId", instrumentId)); // query parameter
            if (quoteType != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "quoteType", quoteType)); // query parameter
            if (field != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "field", field)); // query parameter
            if (effectiveAt != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "effectiveAt", effectiveAt)); // query parameter
            if (asAt != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "asAt", asAt)); // query parameter

            // authentication (oauth2) required
            // oauth required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetQuotesAccessMetadataRule", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<QuoteAccessMetadataRule>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => string.Join(",", x.Value)),
                (QuoteAccessMetadataRule) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(QuoteAccessMetadataRule)));
        }

        /// <summary>
        /// [EXPERIMENTAL] Get a quote access metadata rule Get a specific quote access metadata rule by specifying the corresponding identifier parts                No matching will be performed through this endpoint. To retrieve a rule, it is necessary to specify, exactly, the identifier of the rule
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the Quote Access Metadata Rule to retrieve.</param>
        /// <param name="provider">The Provider of the rule (optional)</param>
        /// <param name="priceSource">The PriceSource of the rule (optional)</param>
        /// <param name="instrumentIdType">The InstrumentIdType of the rule (optional)</param>
        /// <param name="instrumentId">The InstrumentId of the rule (optional)</param>
        /// <param name="quoteType">The QuoteType of the rule (optional)</param>
        /// <param name="field">The Field of the rule (optional)</param>
        /// <param name="effectiveAt">The effective date of the rule (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the access metadata rule. Defaults to return the latest version if not specified. (optional)</param>
        /// <returns>Task of QuoteAccessMetadataRule</returns>
        public async System.Threading.Tasks.Task<QuoteAccessMetadataRule> GetQuotesAccessMetadataRuleAsync (string scope, string provider = null, string priceSource = null, string instrumentIdType = null, string instrumentId = null, string quoteType = null, string field = null, DateTimeOrCutLabel effectiveAt = null, DateTimeOffset? asAt = null)
        {
             ApiResponse<QuoteAccessMetadataRule> localVarResponse = await GetQuotesAccessMetadataRuleAsyncWithHttpInfo(scope, provider, priceSource, instrumentIdType, instrumentId, quoteType, field, effectiveAt, asAt);
             return localVarResponse.Data;

        }

        /// <summary>
        /// [EXPERIMENTAL] Get a quote access metadata rule Get a specific quote access metadata rule by specifying the corresponding identifier parts                No matching will be performed through this endpoint. To retrieve a rule, it is necessary to specify, exactly, the identifier of the rule
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the Quote Access Metadata Rule to retrieve.</param>
        /// <param name="provider">The Provider of the rule (optional)</param>
        /// <param name="priceSource">The PriceSource of the rule (optional)</param>
        /// <param name="instrumentIdType">The InstrumentIdType of the rule (optional)</param>
        /// <param name="instrumentId">The InstrumentId of the rule (optional)</param>
        /// <param name="quoteType">The QuoteType of the rule (optional)</param>
        /// <param name="field">The Field of the rule (optional)</param>
        /// <param name="effectiveAt">The effective date of the rule (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the access metadata rule. Defaults to return the latest version if not specified. (optional)</param>
        /// <returns>Task of ApiResponse (QuoteAccessMetadataRule)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<QuoteAccessMetadataRule>> GetQuotesAccessMetadataRuleAsyncWithHttpInfo (string scope, string provider = null, string priceSource = null, string instrumentIdType = null, string instrumentId = null, string quoteType = null, string field = null, DateTimeOrCutLabel effectiveAt = null, DateTimeOffset? asAt = null)
        {
            // verify the required parameter 'scope' is set
            if (scope == null)
                throw new ApiException(400, "Missing required parameter 'scope' when calling QuotesApi->GetQuotesAccessMetadataRule");

            var localVarPath = "./api/metadata/quotes/rules";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "text/plain",
                "application/json",
                "text/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (scope != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "scope", scope)); // query parameter
            if (provider != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "provider", provider)); // query parameter
            if (priceSource != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "priceSource", priceSource)); // query parameter
            if (instrumentIdType != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "instrumentIdType", instrumentIdType)); // query parameter
            if (instrumentId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "instrumentId", instrumentId)); // query parameter
            if (quoteType != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "quoteType", quoteType)); // query parameter
            if (field != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "field", field)); // query parameter
            if (effectiveAt != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "effectiveAt", effectiveAt)); // query parameter
            if (asAt != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "asAt", asAt)); // query parameter

            // authentication (oauth2) required
            // oauth required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetQuotesAccessMetadataRule", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<QuoteAccessMetadataRule>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => string.Join(",", x.Value)),
                (QuoteAccessMetadataRule) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(QuoteAccessMetadataRule)));
        }

        /// <summary>
        /// [BETA] List quotes List all the quotes from a single scope at the specified date/time
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the quotes to list.</param>
        /// <param name="asAt">The asAt datetime at which to list the quotes. Defaults to latest if not specified. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing quotes from a previous call to list quotes.              This value is returned from the previous call. If a pagination token is provided the sortBy, filter, effectiveAt, and asAt fields              must not have changed since the original request. Also, if set, a start value cannot be provided. (optional)</param>
        /// <param name="start">When paginating, skip this number of results. (optional)</param>
        /// <param name="limit">When paginating, limit the number of returned results to this many. (optional)</param>
        /// <param name="filter">Expression to filter the result set.              For example, to filter on the Provider, use \&quot;quoteId.quoteSeriesId.provider eq &#39;string&#39;\&quot;              Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid. (optional)</param>
        /// <returns>ResourceListOfQuote</returns>
        public ResourceListOfQuote ListQuotes (string scope, DateTimeOffset? asAt = null, string page = null, int? start = null, int? limit = null, string filter = null)
        {
             ApiResponse<ResourceListOfQuote> localVarResponse = ListQuotesWithHttpInfo(scope, asAt, page, start, limit, filter);
             return localVarResponse.Data;
        }

        /// <summary>
        /// [BETA] List quotes List all the quotes from a single scope at the specified date/time
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the quotes to list.</param>
        /// <param name="asAt">The asAt datetime at which to list the quotes. Defaults to latest if not specified. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing quotes from a previous call to list quotes.              This value is returned from the previous call. If a pagination token is provided the sortBy, filter, effectiveAt, and asAt fields              must not have changed since the original request. Also, if set, a start value cannot be provided. (optional)</param>
        /// <param name="start">When paginating, skip this number of results. (optional)</param>
        /// <param name="limit">When paginating, limit the number of returned results to this many. (optional)</param>
        /// <param name="filter">Expression to filter the result set.              For example, to filter on the Provider, use \&quot;quoteId.quoteSeriesId.provider eq &#39;string&#39;\&quot;              Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid. (optional)</param>
        /// <returns>ApiResponse of ResourceListOfQuote</returns>
        public ApiResponse< ResourceListOfQuote > ListQuotesWithHttpInfo (string scope, DateTimeOffset? asAt = null, string page = null, int? start = null, int? limit = null, string filter = null)
        {
            // verify the required parameter 'scope' is set
            if (scope == null)
                throw new ApiException(400, "Missing required parameter 'scope' when calling QuotesApi->ListQuotes");

            var localVarPath = "./api/quotes/{scope}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "text/plain",
                "application/json",
                "text/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (scope != null) localVarPathParams.Add("scope", this.Configuration.ApiClient.ParameterToString(scope)); // path parameter
            if (asAt != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "asAt", asAt)); // query parameter
            if (page != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "page", page)); // query parameter
            if (start != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "start", start)); // query parameter
            if (limit != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "limit", limit)); // query parameter
            if (filter != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "filter", filter)); // query parameter

            // authentication (oauth2) required
            // oauth required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ListQuotes", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<ResourceListOfQuote>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => string.Join(",", x.Value)),
                (ResourceListOfQuote) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(ResourceListOfQuote)));
        }

        /// <summary>
        /// [BETA] List quotes List all the quotes from a single scope at the specified date/time
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the quotes to list.</param>
        /// <param name="asAt">The asAt datetime at which to list the quotes. Defaults to latest if not specified. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing quotes from a previous call to list quotes.              This value is returned from the previous call. If a pagination token is provided the sortBy, filter, effectiveAt, and asAt fields              must not have changed since the original request. Also, if set, a start value cannot be provided. (optional)</param>
        /// <param name="start">When paginating, skip this number of results. (optional)</param>
        /// <param name="limit">When paginating, limit the number of returned results to this many. (optional)</param>
        /// <param name="filter">Expression to filter the result set.              For example, to filter on the Provider, use \&quot;quoteId.quoteSeriesId.provider eq &#39;string&#39;\&quot;              Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid. (optional)</param>
        /// <returns>Task of ResourceListOfQuote</returns>
        public async System.Threading.Tasks.Task<ResourceListOfQuote> ListQuotesAsync (string scope, DateTimeOffset? asAt = null, string page = null, int? start = null, int? limit = null, string filter = null)
        {
             ApiResponse<ResourceListOfQuote> localVarResponse = await ListQuotesAsyncWithHttpInfo(scope, asAt, page, start, limit, filter);
             return localVarResponse.Data;

        }

        /// <summary>
        /// [BETA] List quotes List all the quotes from a single scope at the specified date/time
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the quotes to list.</param>
        /// <param name="asAt">The asAt datetime at which to list the quotes. Defaults to latest if not specified. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing quotes from a previous call to list quotes.              This value is returned from the previous call. If a pagination token is provided the sortBy, filter, effectiveAt, and asAt fields              must not have changed since the original request. Also, if set, a start value cannot be provided. (optional)</param>
        /// <param name="start">When paginating, skip this number of results. (optional)</param>
        /// <param name="limit">When paginating, limit the number of returned results to this many. (optional)</param>
        /// <param name="filter">Expression to filter the result set.              For example, to filter on the Provider, use \&quot;quoteId.quoteSeriesId.provider eq &#39;string&#39;\&quot;              Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid. (optional)</param>
        /// <returns>Task of ApiResponse (ResourceListOfQuote)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<ResourceListOfQuote>> ListQuotesAsyncWithHttpInfo (string scope, DateTimeOffset? asAt = null, string page = null, int? start = null, int? limit = null, string filter = null)
        {
            // verify the required parameter 'scope' is set
            if (scope == null)
                throw new ApiException(400, "Missing required parameter 'scope' when calling QuotesApi->ListQuotes");

            var localVarPath = "./api/quotes/{scope}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "text/plain",
                "application/json",
                "text/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (scope != null) localVarPathParams.Add("scope", this.Configuration.ApiClient.ParameterToString(scope)); // path parameter
            if (asAt != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "asAt", asAt)); // query parameter
            if (page != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "page", page)); // query parameter
            if (start != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "start", start)); // query parameter
            if (limit != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "limit", limit)); // query parameter
            if (filter != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "filter", filter)); // query parameter

            // authentication (oauth2) required
            // oauth required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ListQuotes", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<ResourceListOfQuote>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => string.Join(",", x.Value)),
                (ResourceListOfQuote) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(ResourceListOfQuote)));
        }

        /// <summary>
        /// [EXPERIMENTAL] List all quote access metadata rules in a scope Get all the quote access metadata rules in the specified scope
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the Quote Access Metadata Rule to retrieve.</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the access metadata rule. Defaults to return the latest version if not specified. (optional)</param>
        /// <returns>ResourceListOfQuoteAccessMetadataRule</returns>
        public ResourceListOfQuoteAccessMetadataRule ListQuotesAccessMetadataRules (string scope, DateTimeOffset? asAt = null)
        {
             ApiResponse<ResourceListOfQuoteAccessMetadataRule> localVarResponse = ListQuotesAccessMetadataRulesWithHttpInfo(scope, asAt);
             return localVarResponse.Data;
        }

        /// <summary>
        /// [EXPERIMENTAL] List all quote access metadata rules in a scope Get all the quote access metadata rules in the specified scope
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the Quote Access Metadata Rule to retrieve.</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the access metadata rule. Defaults to return the latest version if not specified. (optional)</param>
        /// <returns>ApiResponse of ResourceListOfQuoteAccessMetadataRule</returns>
        public ApiResponse< ResourceListOfQuoteAccessMetadataRule > ListQuotesAccessMetadataRulesWithHttpInfo (string scope, DateTimeOffset? asAt = null)
        {
            // verify the required parameter 'scope' is set
            if (scope == null)
                throw new ApiException(400, "Missing required parameter 'scope' when calling QuotesApi->ListQuotesAccessMetadataRules");

            var localVarPath = "./api/metadata/quotes/rules/{scope}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "text/plain",
                "application/json",
                "text/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (scope != null) localVarPathParams.Add("scope", this.Configuration.ApiClient.ParameterToString(scope)); // path parameter
            if (asAt != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "asAt", asAt)); // query parameter

            // authentication (oauth2) required
            // oauth required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ListQuotesAccessMetadataRules", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<ResourceListOfQuoteAccessMetadataRule>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => string.Join(",", x.Value)),
                (ResourceListOfQuoteAccessMetadataRule) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(ResourceListOfQuoteAccessMetadataRule)));
        }

        /// <summary>
        /// [EXPERIMENTAL] List all quote access metadata rules in a scope Get all the quote access metadata rules in the specified scope
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the Quote Access Metadata Rule to retrieve.</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the access metadata rule. Defaults to return the latest version if not specified. (optional)</param>
        /// <returns>Task of ResourceListOfQuoteAccessMetadataRule</returns>
        public async System.Threading.Tasks.Task<ResourceListOfQuoteAccessMetadataRule> ListQuotesAccessMetadataRulesAsync (string scope, DateTimeOffset? asAt = null)
        {
             ApiResponse<ResourceListOfQuoteAccessMetadataRule> localVarResponse = await ListQuotesAccessMetadataRulesAsyncWithHttpInfo(scope, asAt);
             return localVarResponse.Data;

        }

        /// <summary>
        /// [EXPERIMENTAL] List all quote access metadata rules in a scope Get all the quote access metadata rules in the specified scope
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the Quote Access Metadata Rule to retrieve.</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the access metadata rule. Defaults to return the latest version if not specified. (optional)</param>
        /// <returns>Task of ApiResponse (ResourceListOfQuoteAccessMetadataRule)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<ResourceListOfQuoteAccessMetadataRule>> ListQuotesAccessMetadataRulesAsyncWithHttpInfo (string scope, DateTimeOffset? asAt = null)
        {
            // verify the required parameter 'scope' is set
            if (scope == null)
                throw new ApiException(400, "Missing required parameter 'scope' when calling QuotesApi->ListQuotesAccessMetadataRules");

            var localVarPath = "./api/metadata/quotes/rules/{scope}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "text/plain",
                "application/json",
                "text/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (scope != null) localVarPathParams.Add("scope", this.Configuration.ApiClient.ParameterToString(scope)); // path parameter
            if (asAt != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "asAt", asAt)); // query parameter

            // authentication (oauth2) required
            // oauth required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ListQuotesAccessMetadataRules", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<ResourceListOfQuoteAccessMetadataRule>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => string.Join(",", x.Value)),
                (ResourceListOfQuoteAccessMetadataRule) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(ResourceListOfQuoteAccessMetadataRule)));
        }

        /// <summary>
        /// [EXPERIMENTAL] Upsert a Quote Access Metadata Rule. This creates or updates the data in LUSID. Update or insert one Quote Access Metadata Rule in a single scope. An item will be updated if it already exists  and inserted if it does not.    The response will return the successfully updated or inserted Quote Access Metadata Rule or failure message if unsuccessful    It is important to always check to verify success (or failure).                Multiple rules for a key can exists with different effective at dates, when resources are accessed the rule that is active for the current time will be fetched
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope to use when updating or inserting the Quote Access Metadata Rule.</param>
        /// <param name="request">The Quote Access Metadata Rule to update or insert</param>
        /// <param name="effectiveAt">The date this rule will effective from (optional)</param>
        /// <returns>QuoteAccessMetadataRule</returns>
        public QuoteAccessMetadataRule UpsertQuoteAccessMetadataRule (string scope, UpsertQuoteAccessMetadataRuleRequest request, DateTimeOrCutLabel effectiveAt = null)
        {
             ApiResponse<QuoteAccessMetadataRule> localVarResponse = UpsertQuoteAccessMetadataRuleWithHttpInfo(scope, request, effectiveAt);
             return localVarResponse.Data;
        }

        /// <summary>
        /// [EXPERIMENTAL] Upsert a Quote Access Metadata Rule. This creates or updates the data in LUSID. Update or insert one Quote Access Metadata Rule in a single scope. An item will be updated if it already exists  and inserted if it does not.    The response will return the successfully updated or inserted Quote Access Metadata Rule or failure message if unsuccessful    It is important to always check to verify success (or failure).                Multiple rules for a key can exists with different effective at dates, when resources are accessed the rule that is active for the current time will be fetched
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope to use when updating or inserting the Quote Access Metadata Rule.</param>
        /// <param name="request">The Quote Access Metadata Rule to update or insert</param>
        /// <param name="effectiveAt">The date this rule will effective from (optional)</param>
        /// <returns>ApiResponse of QuoteAccessMetadataRule</returns>
        public ApiResponse< QuoteAccessMetadataRule > UpsertQuoteAccessMetadataRuleWithHttpInfo (string scope, UpsertQuoteAccessMetadataRuleRequest request, DateTimeOrCutLabel effectiveAt = null)
        {
            // verify the required parameter 'scope' is set
            if (scope == null)
                throw new ApiException(400, "Missing required parameter 'scope' when calling QuotesApi->UpsertQuoteAccessMetadataRule");
            // verify the required parameter 'request' is set
            if (request == null)
                throw new ApiException(400, "Missing required parameter 'request' when calling QuotesApi->UpsertQuoteAccessMetadataRule");

            var localVarPath = "./api/metadata/quotes/rules/{scope}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "text/plain",
                "application/json",
                "text/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (scope != null) localVarPathParams.Add("scope", this.Configuration.ApiClient.ParameterToString(scope)); // path parameter
            if (effectiveAt != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "effectiveAt", effectiveAt)); // query parameter
            if (request != null && request.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(request); // http body (model) parameter
            }
            else
            {
                localVarPostBody = request; // byte array
            }

            // authentication (oauth2) required
            // oauth required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpsertQuoteAccessMetadataRule", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<QuoteAccessMetadataRule>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => string.Join(",", x.Value)),
                (QuoteAccessMetadataRule) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(QuoteAccessMetadataRule)));
        }

        /// <summary>
        /// [EXPERIMENTAL] Upsert a Quote Access Metadata Rule. This creates or updates the data in LUSID. Update or insert one Quote Access Metadata Rule in a single scope. An item will be updated if it already exists  and inserted if it does not.    The response will return the successfully updated or inserted Quote Access Metadata Rule or failure message if unsuccessful    It is important to always check to verify success (or failure).                Multiple rules for a key can exists with different effective at dates, when resources are accessed the rule that is active for the current time will be fetched
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope to use when updating or inserting the Quote Access Metadata Rule.</param>
        /// <param name="request">The Quote Access Metadata Rule to update or insert</param>
        /// <param name="effectiveAt">The date this rule will effective from (optional)</param>
        /// <returns>Task of QuoteAccessMetadataRule</returns>
        public async System.Threading.Tasks.Task<QuoteAccessMetadataRule> UpsertQuoteAccessMetadataRuleAsync (string scope, UpsertQuoteAccessMetadataRuleRequest request, DateTimeOrCutLabel effectiveAt = null)
        {
             ApiResponse<QuoteAccessMetadataRule> localVarResponse = await UpsertQuoteAccessMetadataRuleAsyncWithHttpInfo(scope, request, effectiveAt);
             return localVarResponse.Data;

        }

        /// <summary>
        /// [EXPERIMENTAL] Upsert a Quote Access Metadata Rule. This creates or updates the data in LUSID. Update or insert one Quote Access Metadata Rule in a single scope. An item will be updated if it already exists  and inserted if it does not.    The response will return the successfully updated or inserted Quote Access Metadata Rule or failure message if unsuccessful    It is important to always check to verify success (or failure).                Multiple rules for a key can exists with different effective at dates, when resources are accessed the rule that is active for the current time will be fetched
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope to use when updating or inserting the Quote Access Metadata Rule.</param>
        /// <param name="request">The Quote Access Metadata Rule to update or insert</param>
        /// <param name="effectiveAt">The date this rule will effective from (optional)</param>
        /// <returns>Task of ApiResponse (QuoteAccessMetadataRule)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<QuoteAccessMetadataRule>> UpsertQuoteAccessMetadataRuleAsyncWithHttpInfo (string scope, UpsertQuoteAccessMetadataRuleRequest request, DateTimeOrCutLabel effectiveAt = null)
        {
            // verify the required parameter 'scope' is set
            if (scope == null)
                throw new ApiException(400, "Missing required parameter 'scope' when calling QuotesApi->UpsertQuoteAccessMetadataRule");
            // verify the required parameter 'request' is set
            if (request == null)
                throw new ApiException(400, "Missing required parameter 'request' when calling QuotesApi->UpsertQuoteAccessMetadataRule");

            var localVarPath = "./api/metadata/quotes/rules/{scope}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "text/plain",
                "application/json",
                "text/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (scope != null) localVarPathParams.Add("scope", this.Configuration.ApiClient.ParameterToString(scope)); // path parameter
            if (effectiveAt != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "effectiveAt", effectiveAt)); // query parameter
            if (request != null && request.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(request); // http body (model) parameter
            }
            else
            {
                localVarPostBody = request; // byte array
            }

            // authentication (oauth2) required
            // oauth required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpsertQuoteAccessMetadataRule", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<QuoteAccessMetadataRule>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => string.Join(",", x.Value)),
                (QuoteAccessMetadataRule) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(QuoteAccessMetadataRule)));
        }

        /// <summary>
        /// [BETA] Upsert quotes Update or insert one or more quotes in a single scope. A quote will be updated if it already exists  and inserted if it does not.                In the request each quote must be keyed by a unique correlation id. This id is ephemeral and is not stored by LUSID.  It serves only as a way to easily identify each quote in the response.                The response will return both the collection of successfully updated or inserted quotes, as well as those that failed.  For the failures a reason will be provided explaining why the quote could not be updated or inserted.                It is important to always check the failed set for any unsuccessful results.  The maximum number of quotes that this method can upsert per request is 2,000.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope to use when updating or inserting the quotes.</param>
        /// <param name="quotes">The quotes to update or insert keyed by a unique correlation id. (optional)</param>
        /// <returns>UpsertQuotesResponse</returns>
        public UpsertQuotesResponse UpsertQuotes (string scope, Dictionary<string, UpsertQuoteRequest> quotes = null)
        {
             ApiResponse<UpsertQuotesResponse> localVarResponse = UpsertQuotesWithHttpInfo(scope, quotes);
             return localVarResponse.Data;
        }

        /// <summary>
        /// [BETA] Upsert quotes Update or insert one or more quotes in a single scope. A quote will be updated if it already exists  and inserted if it does not.                In the request each quote must be keyed by a unique correlation id. This id is ephemeral and is not stored by LUSID.  It serves only as a way to easily identify each quote in the response.                The response will return both the collection of successfully updated or inserted quotes, as well as those that failed.  For the failures a reason will be provided explaining why the quote could not be updated or inserted.                It is important to always check the failed set for any unsuccessful results.  The maximum number of quotes that this method can upsert per request is 2,000.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope to use when updating or inserting the quotes.</param>
        /// <param name="quotes">The quotes to update or insert keyed by a unique correlation id. (optional)</param>
        /// <returns>ApiResponse of UpsertQuotesResponse</returns>
        public ApiResponse< UpsertQuotesResponse > UpsertQuotesWithHttpInfo (string scope, Dictionary<string, UpsertQuoteRequest> quotes = null)
        {
            // verify the required parameter 'scope' is set
            if (scope == null)
                throw new ApiException(400, "Missing required parameter 'scope' when calling QuotesApi->UpsertQuotes");

            var localVarPath = "./api/quotes/{scope}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "text/plain",
                "application/json",
                "text/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (scope != null) localVarPathParams.Add("scope", this.Configuration.ApiClient.ParameterToString(scope)); // path parameter
            if (quotes != null && quotes.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(quotes); // http body (model) parameter
            }
            else
            {
                localVarPostBody = quotes; // byte array
            }

            // authentication (oauth2) required
            // oauth required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpsertQuotes", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<UpsertQuotesResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => string.Join(",", x.Value)),
                (UpsertQuotesResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(UpsertQuotesResponse)));
        }

        /// <summary>
        /// [BETA] Upsert quotes Update or insert one or more quotes in a single scope. A quote will be updated if it already exists  and inserted if it does not.                In the request each quote must be keyed by a unique correlation id. This id is ephemeral and is not stored by LUSID.  It serves only as a way to easily identify each quote in the response.                The response will return both the collection of successfully updated or inserted quotes, as well as those that failed.  For the failures a reason will be provided explaining why the quote could not be updated or inserted.                It is important to always check the failed set for any unsuccessful results.  The maximum number of quotes that this method can upsert per request is 2,000.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope to use when updating or inserting the quotes.</param>
        /// <param name="quotes">The quotes to update or insert keyed by a unique correlation id. (optional)</param>
        /// <returns>Task of UpsertQuotesResponse</returns>
        public async System.Threading.Tasks.Task<UpsertQuotesResponse> UpsertQuotesAsync (string scope, Dictionary<string, UpsertQuoteRequest> quotes = null)
        {
             ApiResponse<UpsertQuotesResponse> localVarResponse = await UpsertQuotesAsyncWithHttpInfo(scope, quotes);
             return localVarResponse.Data;

        }

        /// <summary>
        /// [BETA] Upsert quotes Update or insert one or more quotes in a single scope. A quote will be updated if it already exists  and inserted if it does not.                In the request each quote must be keyed by a unique correlation id. This id is ephemeral and is not stored by LUSID.  It serves only as a way to easily identify each quote in the response.                The response will return both the collection of successfully updated or inserted quotes, as well as those that failed.  For the failures a reason will be provided explaining why the quote could not be updated or inserted.                It is important to always check the failed set for any unsuccessful results.  The maximum number of quotes that this method can upsert per request is 2,000.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope to use when updating or inserting the quotes.</param>
        /// <param name="quotes">The quotes to update or insert keyed by a unique correlation id. (optional)</param>
        /// <returns>Task of ApiResponse (UpsertQuotesResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<UpsertQuotesResponse>> UpsertQuotesAsyncWithHttpInfo (string scope, Dictionary<string, UpsertQuoteRequest> quotes = null)
        {
            // verify the required parameter 'scope' is set
            if (scope == null)
                throw new ApiException(400, "Missing required parameter 'scope' when calling QuotesApi->UpsertQuotes");

            var localVarPath = "./api/quotes/{scope}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "text/plain",
                "application/json",
                "text/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (scope != null) localVarPathParams.Add("scope", this.Configuration.ApiClient.ParameterToString(scope)); // path parameter
            if (quotes != null && quotes.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(quotes); // http body (model) parameter
            }
            else
            {
                localVarPostBody = quotes; // byte array
            }

            // authentication (oauth2) required
            // oauth required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpsertQuotes", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<UpsertQuotesResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => string.Join(",", x.Value)),
                (UpsertQuotesResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(UpsertQuotesResponse)));
        }

    }
}
