/* 
 * LUSID API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.10.1389
 * Contact: info@finbourne.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Runtime.Serialization;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using OpenAPIDateConverter = Lusid.Sdk.Client.OpenAPIDateConverter;

namespace Lusid.Sdk.Model
{
    /// <summary>
    /// CreateResults
    /// </summary>
    [DataContract]
    public partial class CreateResults :  IEquatable<CreateResults>
    {
        /// <summary>
        /// The format in which the results are stored/structured.
        /// </summary>
        /// <value>The format in which the results are stored/structured.</value>
        [JsonConverter(typeof(StringEnumConverter))]
        public enum FormatEnum
        {
            /// <summary>
            /// Enum DataReader for value: DataReader
            /// </summary>
            [EnumMember(Value = "DataReader")]
            DataReader = 1,

            /// <summary>
            /// Enum Portfolio for value: Portfolio
            /// </summary>
            [EnumMember(Value = "Portfolio")]
            Portfolio = 2,

            /// <summary>
            /// Enum Csv for value: Csv
            /// </summary>
            [EnumMember(Value = "Csv")]
            Csv = 3,

            /// <summary>
            /// Enum Unknown for value: Unknown
            /// </summary>
            [EnumMember(Value = "Unknown")]
            Unknown = 4

        }

        /// <summary>
        /// The format in which the results are stored/structured.
        /// </summary>
        /// <value>The format in which the results are stored/structured.</value>
        [DataMember(Name="format", EmitDefaultValue=false)]
        public FormatEnum? Format { get; set; }
        /// <summary>
        /// Initializes a new instance of the <see cref="CreateResults" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected CreateResults() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="CreateResults" /> class.
        /// </summary>
        /// <param name="effectiveAt">The effective market date for which results are calculated and are to be stored. (required).</param>
        /// <param name="entityScope">Scope of the entity code (required).</param>
        /// <param name="entityCode">The code of the entity for which the data has been calculated. (required).</param>
        /// <param name="calculationScope">Scope of the calculation code. (required).</param>
        /// <param name="calculationCode">This is the identifier which denotes some hash of, or recipe, that cumulatively represents the configuration through which  the results being stored are obtained. For example, the recipe denotes the pricing model, the market data and any other  settings. If the results were calculated externally it should be some repeatable hash or other Id that denotes the particular  configuration under which those results were obtained. (required).</param>
        /// <param name="format">The format in which the results are stored/structured..</param>
        /// <param name="data">The data that should be stored in the results cube..</param>
        public CreateResults(DateTimeOffset? effectiveAt = default(DateTimeOffset?), string entityScope = default(string), string entityCode = default(string), string calculationScope = default(string), string calculationCode = default(string), FormatEnum? format = default(FormatEnum?), string data = default(string))
        {
            // to ensure "effectiveAt" is required (not null)
            if (effectiveAt == null)
            {
                throw new InvalidDataException("effectiveAt is a required property for CreateResults and cannot be null");
            }
            else
            {
                this.EffectiveAt = effectiveAt;
            }
            
            // to ensure "entityScope" is required (not null)
            if (entityScope == null)
            {
                throw new InvalidDataException("entityScope is a required property for CreateResults and cannot be null");
            }
            else
            {
                this.EntityScope = entityScope;
            }
            
            // to ensure "entityCode" is required (not null)
            if (entityCode == null)
            {
                throw new InvalidDataException("entityCode is a required property for CreateResults and cannot be null");
            }
            else
            {
                this.EntityCode = entityCode;
            }
            
            // to ensure "calculationScope" is required (not null)
            if (calculationScope == null)
            {
                throw new InvalidDataException("calculationScope is a required property for CreateResults and cannot be null");
            }
            else
            {
                this.CalculationScope = calculationScope;
            }
            
            // to ensure "calculationCode" is required (not null)
            if (calculationCode == null)
            {
                throw new InvalidDataException("calculationCode is a required property for CreateResults and cannot be null");
            }
            else
            {
                this.CalculationCode = calculationCode;
            }
            
            this.Format = format;
            this.Data = data;
        }
        
        /// <summary>
        /// The effective market date for which results are calculated and are to be stored.
        /// </summary>
        /// <value>The effective market date for which results are calculated and are to be stored.</value>
        [DataMember(Name="effectiveAt", EmitDefaultValue=false)]
        public DateTimeOffset? EffectiveAt { get; set; }

        /// <summary>
        /// Scope of the entity code
        /// </summary>
        /// <value>Scope of the entity code</value>
        [DataMember(Name="entityScope", EmitDefaultValue=false)]
        public string EntityScope { get; set; }

        /// <summary>
        /// The code of the entity for which the data has been calculated.
        /// </summary>
        /// <value>The code of the entity for which the data has been calculated.</value>
        [DataMember(Name="entityCode", EmitDefaultValue=false)]
        public string EntityCode { get; set; }

        /// <summary>
        /// Scope of the calculation code.
        /// </summary>
        /// <value>Scope of the calculation code.</value>
        [DataMember(Name="calculationScope", EmitDefaultValue=false)]
        public string CalculationScope { get; set; }

        /// <summary>
        /// This is the identifier which denotes some hash of, or recipe, that cumulatively represents the configuration through which  the results being stored are obtained. For example, the recipe denotes the pricing model, the market data and any other  settings. If the results were calculated externally it should be some repeatable hash or other Id that denotes the particular  configuration under which those results were obtained.
        /// </summary>
        /// <value>This is the identifier which denotes some hash of, or recipe, that cumulatively represents the configuration through which  the results being stored are obtained. For example, the recipe denotes the pricing model, the market data and any other  settings. If the results were calculated externally it should be some repeatable hash or other Id that denotes the particular  configuration under which those results were obtained.</value>
        [DataMember(Name="calculationCode", EmitDefaultValue=false)]
        public string CalculationCode { get; set; }


        /// <summary>
        /// The data that should be stored in the results cube.
        /// </summary>
        /// <value>The data that should be stored in the results cube.</value>
        [DataMember(Name="data", EmitDefaultValue=false)]
        public string Data { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class CreateResults {\n");
            sb.Append("  EffectiveAt: ").Append(EffectiveAt).Append("\n");
            sb.Append("  EntityScope: ").Append(EntityScope).Append("\n");
            sb.Append("  EntityCode: ").Append(EntityCode).Append("\n");
            sb.Append("  CalculationScope: ").Append(CalculationScope).Append("\n");
            sb.Append("  CalculationCode: ").Append(CalculationCode).Append("\n");
            sb.Append("  Format: ").Append(Format).Append("\n");
            sb.Append("  Data: ").Append(Data).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
  
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return JsonConvert.SerializeObject(this, Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as CreateResults);
        }

        /// <summary>
        /// Returns true if CreateResults instances are equal
        /// </summary>
        /// <param name="input">Instance of CreateResults to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(CreateResults input)
        {
            if (input == null)
                return false;

            return 
                (
                    this.EffectiveAt == input.EffectiveAt ||
                    (this.EffectiveAt != null &&
                    this.EffectiveAt.Equals(input.EffectiveAt))
                ) && 
                (
                    this.EntityScope == input.EntityScope ||
                    (this.EntityScope != null &&
                    this.EntityScope.Equals(input.EntityScope))
                ) && 
                (
                    this.EntityCode == input.EntityCode ||
                    (this.EntityCode != null &&
                    this.EntityCode.Equals(input.EntityCode))
                ) && 
                (
                    this.CalculationScope == input.CalculationScope ||
                    (this.CalculationScope != null &&
                    this.CalculationScope.Equals(input.CalculationScope))
                ) && 
                (
                    this.CalculationCode == input.CalculationCode ||
                    (this.CalculationCode != null &&
                    this.CalculationCode.Equals(input.CalculationCode))
                ) && 
                (
                    this.Format == input.Format ||
                    (this.Format != null &&
                    this.Format.Equals(input.Format))
                ) && 
                (
                    this.Data == input.Data ||
                    (this.Data != null &&
                    this.Data.Equals(input.Data))
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.EffectiveAt != null)
                    hashCode = hashCode * 59 + this.EffectiveAt.GetHashCode();
                if (this.EntityScope != null)
                    hashCode = hashCode * 59 + this.EntityScope.GetHashCode();
                if (this.EntityCode != null)
                    hashCode = hashCode * 59 + this.EntityCode.GetHashCode();
                if (this.CalculationScope != null)
                    hashCode = hashCode * 59 + this.CalculationScope.GetHashCode();
                if (this.CalculationCode != null)
                    hashCode = hashCode * 59 + this.CalculationCode.GetHashCode();
                if (this.Format != null)
                    hashCode = hashCode * 59 + this.Format.GetHashCode();
                if (this.Data != null)
                    hashCode = hashCode * 59 + this.Data.GetHashCode();
                return hashCode;
            }
        }
    }

}
