/* 
 * LUSID API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.10.1392
 * Contact: info@finbourne.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Runtime.Serialization;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using OpenAPIDateConverter = Lusid.Sdk.Client.OpenAPIDateConverter;

namespace Lusid.Sdk.Model
{
    /// <summary>
    /// When importing data from an external source there are essentially three levels of interaction with LUSID.  (1) The data is a raw document that LUSID does not understand. You can store and retrieve it but it does not full interact with other documents inside LUSID  (2) The data has a map from fields and paths to &#39;properties&#39; in LUSID. In essence, LUSID can then treat the data as weakly typed (decimal, string) data that can be returned through queries      and where various aggregation requests will then work.  (3) The data is fully translatable into LUSID and understood, in some sense, natively. This means that it can be used for context sensitive calculations such as pricing or risk calculations.  The data map object is designed to allow data to transition from step 1 to 2 and in some cases as an alternative for step 2 to 3.
    /// </summary>
    [DataContract]
    public partial class DataMapping :  IEquatable<DataMapping>
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="DataMapping" /> class.
        /// </summary>
        /// <param name="dataFieldNameMappings">A map from LUSID item keys to data definitions that define the names, types and degree of uniqueness of data provided to LUSID in structured data stores..</param>
        /// <param name="links">links.</param>
        public DataMapping(Dictionary<string, DataDefinition> dataFieldNameMappings = default(Dictionary<string, DataDefinition>), List<Link> links = default(List<Link>))
        {
            this.DataFieldNameMappings = dataFieldNameMappings;
            this.Links = links;
        }
        
        /// <summary>
        /// A map from LUSID item keys to data definitions that define the names, types and degree of uniqueness of data provided to LUSID in structured data stores.
        /// </summary>
        /// <value>A map from LUSID item keys to data definitions that define the names, types and degree of uniqueness of data provided to LUSID in structured data stores.</value>
        [DataMember(Name="dataFieldNameMappings", EmitDefaultValue=false)]
        public Dictionary<string, DataDefinition> DataFieldNameMappings { get; set; }

        /// <summary>
        /// Gets or Sets Links
        /// </summary>
        [DataMember(Name="links", EmitDefaultValue=false)]
        public List<Link> Links { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class DataMapping {\n");
            sb.Append("  DataFieldNameMappings: ").Append(DataFieldNameMappings).Append("\n");
            sb.Append("  Links: ").Append(Links).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
  
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return JsonConvert.SerializeObject(this, Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as DataMapping);
        }

        /// <summary>
        /// Returns true if DataMapping instances are equal
        /// </summary>
        /// <param name="input">Instance of DataMapping to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(DataMapping input)
        {
            if (input == null)
                return false;

            return 
                (
                    this.DataFieldNameMappings == input.DataFieldNameMappings ||
                    this.DataFieldNameMappings != null &&
                    input.DataFieldNameMappings != null &&
                    this.DataFieldNameMappings.SequenceEqual(input.DataFieldNameMappings)
                ) && 
                (
                    this.Links == input.Links ||
                    this.Links != null &&
                    input.Links != null &&
                    this.Links.SequenceEqual(input.Links)
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.DataFieldNameMappings != null)
                    hashCode = hashCode * 59 + this.DataFieldNameMappings.GetHashCode();
                if (this.Links != null)
                    hashCode = hashCode * 59 + this.Links.GetHashCode();
                return hashCode;
            }
        }
    }

}
